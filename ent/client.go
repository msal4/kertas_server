// Code generated by entc, DO NOT EDIT.

package ent

import (
	"context"
	"fmt"
	"log"

	"github.com/google/uuid"
	"github.com/msal4/hassah_school_server/ent/migrate"

	"github.com/msal4/hassah_school_server/ent/assignment"
	"github.com/msal4/hassah_school_server/ent/assignmentsubmission"
	"github.com/msal4/hassah_school_server/ent/attendance"
	"github.com/msal4/hassah_school_server/ent/class"
	"github.com/msal4/hassah_school_server/ent/grade"
	"github.com/msal4/hassah_school_server/ent/group"
	"github.com/msal4/hassah_school_server/ent/message"
	"github.com/msal4/hassah_school_server/ent/schedule"
	"github.com/msal4/hassah_school_server/ent/school"
	"github.com/msal4/hassah_school_server/ent/stage"
	"github.com/msal4/hassah_school_server/ent/tuitionpayment"
	"github.com/msal4/hassah_school_server/ent/user"

	"entgo.io/ent/dialect"
	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
)

// Client is the client that holds all ent builders.
type Client struct {
	config
	// Schema is the client for creating, migrating and dropping schema.
	Schema *migrate.Schema
	// Assignment is the client for interacting with the Assignment builders.
	Assignment *AssignmentClient
	// AssignmentSubmission is the client for interacting with the AssignmentSubmission builders.
	AssignmentSubmission *AssignmentSubmissionClient
	// Attendance is the client for interacting with the Attendance builders.
	Attendance *AttendanceClient
	// Class is the client for interacting with the Class builders.
	Class *ClassClient
	// Grade is the client for interacting with the Grade builders.
	Grade *GradeClient
	// Group is the client for interacting with the Group builders.
	Group *GroupClient
	// Message is the client for interacting with the Message builders.
	Message *MessageClient
	// Schedule is the client for interacting with the Schedule builders.
	Schedule *ScheduleClient
	// School is the client for interacting with the School builders.
	School *SchoolClient
	// Stage is the client for interacting with the Stage builders.
	Stage *StageClient
	// TuitionPayment is the client for interacting with the TuitionPayment builders.
	TuitionPayment *TuitionPaymentClient
	// User is the client for interacting with the User builders.
	User *UserClient
}

// NewClient creates a new client configured with the given options.
func NewClient(opts ...Option) *Client {
	cfg := config{log: log.Println, hooks: &hooks{}}
	cfg.options(opts...)
	client := &Client{config: cfg}
	client.init()
	return client
}

func (c *Client) init() {
	c.Schema = migrate.NewSchema(c.driver)
	c.Assignment = NewAssignmentClient(c.config)
	c.AssignmentSubmission = NewAssignmentSubmissionClient(c.config)
	c.Attendance = NewAttendanceClient(c.config)
	c.Class = NewClassClient(c.config)
	c.Grade = NewGradeClient(c.config)
	c.Group = NewGroupClient(c.config)
	c.Message = NewMessageClient(c.config)
	c.Schedule = NewScheduleClient(c.config)
	c.School = NewSchoolClient(c.config)
	c.Stage = NewStageClient(c.config)
	c.TuitionPayment = NewTuitionPaymentClient(c.config)
	c.User = NewUserClient(c.config)
}

// Open opens a database/sql.DB specified by the driver name and
// the data source name, and returns a new client attached to it.
// Optional parameters can be added for configuring the client.
func Open(driverName, dataSourceName string, options ...Option) (*Client, error) {
	switch driverName {
	case dialect.MySQL, dialect.Postgres, dialect.SQLite:
		drv, err := sql.Open(driverName, dataSourceName)
		if err != nil {
			return nil, err
		}
		return NewClient(append(options, Driver(drv))...), nil
	default:
		return nil, fmt.Errorf("unsupported driver: %q", driverName)
	}
}

// Tx returns a new transactional client. The provided context
// is used until the transaction is committed or rolled back.
func (c *Client) Tx(ctx context.Context) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, fmt.Errorf("ent: cannot start a transaction within a transaction")
	}
	tx, err := newTx(ctx, c.driver)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = tx
	return &Tx{
		ctx:                  ctx,
		config:               cfg,
		Assignment:           NewAssignmentClient(cfg),
		AssignmentSubmission: NewAssignmentSubmissionClient(cfg),
		Attendance:           NewAttendanceClient(cfg),
		Class:                NewClassClient(cfg),
		Grade:                NewGradeClient(cfg),
		Group:                NewGroupClient(cfg),
		Message:              NewMessageClient(cfg),
		Schedule:             NewScheduleClient(cfg),
		School:               NewSchoolClient(cfg),
		Stage:                NewStageClient(cfg),
		TuitionPayment:       NewTuitionPaymentClient(cfg),
		User:                 NewUserClient(cfg),
	}, nil
}

// BeginTx returns a transactional client with specified options.
func (c *Client) BeginTx(ctx context.Context, opts *sql.TxOptions) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, fmt.Errorf("ent: cannot start a transaction within a transaction")
	}
	tx, err := c.driver.(interface {
		BeginTx(context.Context, *sql.TxOptions) (dialect.Tx, error)
	}).BeginTx(ctx, opts)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = &txDriver{tx: tx, drv: c.driver}
	return &Tx{
		config:               cfg,
		Assignment:           NewAssignmentClient(cfg),
		AssignmentSubmission: NewAssignmentSubmissionClient(cfg),
		Attendance:           NewAttendanceClient(cfg),
		Class:                NewClassClient(cfg),
		Grade:                NewGradeClient(cfg),
		Group:                NewGroupClient(cfg),
		Message:              NewMessageClient(cfg),
		Schedule:             NewScheduleClient(cfg),
		School:               NewSchoolClient(cfg),
		Stage:                NewStageClient(cfg),
		TuitionPayment:       NewTuitionPaymentClient(cfg),
		User:                 NewUserClient(cfg),
	}, nil
}

// Debug returns a new debug-client. It's used to get verbose logging on specific operations.
//
//	client.Debug().
//		Assignment.
//		Query().
//		Count(ctx)
//
func (c *Client) Debug() *Client {
	if c.debug {
		return c
	}
	cfg := c.config
	cfg.driver = dialect.Debug(c.driver, c.log)
	client := &Client{config: cfg}
	client.init()
	return client
}

// Close closes the database connection and prevents new queries from starting.
func (c *Client) Close() error {
	return c.driver.Close()
}

// Use adds the mutation hooks to all the entity clients.
// In order to add hooks to a specific client, call: `client.Node.Use(...)`.
func (c *Client) Use(hooks ...Hook) {
	c.Assignment.Use(hooks...)
	c.AssignmentSubmission.Use(hooks...)
	c.Attendance.Use(hooks...)
	c.Class.Use(hooks...)
	c.Grade.Use(hooks...)
	c.Group.Use(hooks...)
	c.Message.Use(hooks...)
	c.Schedule.Use(hooks...)
	c.School.Use(hooks...)
	c.Stage.Use(hooks...)
	c.TuitionPayment.Use(hooks...)
	c.User.Use(hooks...)
}

// AssignmentClient is a client for the Assignment schema.
type AssignmentClient struct {
	config
}

// NewAssignmentClient returns a client for the Assignment from the given config.
func NewAssignmentClient(c config) *AssignmentClient {
	return &AssignmentClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `assignment.Hooks(f(g(h())))`.
func (c *AssignmentClient) Use(hooks ...Hook) {
	c.hooks.Assignment = append(c.hooks.Assignment, hooks...)
}

// Create returns a create builder for Assignment.
func (c *AssignmentClient) Create() *AssignmentCreate {
	mutation := newAssignmentMutation(c.config, OpCreate)
	return &AssignmentCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Assignment entities.
func (c *AssignmentClient) CreateBulk(builders ...*AssignmentCreate) *AssignmentCreateBulk {
	return &AssignmentCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Assignment.
func (c *AssignmentClient) Update() *AssignmentUpdate {
	mutation := newAssignmentMutation(c.config, OpUpdate)
	return &AssignmentUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *AssignmentClient) UpdateOne(a *Assignment) *AssignmentUpdateOne {
	mutation := newAssignmentMutation(c.config, OpUpdateOne, withAssignment(a))
	return &AssignmentUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *AssignmentClient) UpdateOneID(id uuid.UUID) *AssignmentUpdateOne {
	mutation := newAssignmentMutation(c.config, OpUpdateOne, withAssignmentID(id))
	return &AssignmentUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Assignment.
func (c *AssignmentClient) Delete() *AssignmentDelete {
	mutation := newAssignmentMutation(c.config, OpDelete)
	return &AssignmentDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *AssignmentClient) DeleteOne(a *Assignment) *AssignmentDeleteOne {
	return c.DeleteOneID(a.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *AssignmentClient) DeleteOneID(id uuid.UUID) *AssignmentDeleteOne {
	builder := c.Delete().Where(assignment.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &AssignmentDeleteOne{builder}
}

// Query returns a query builder for Assignment.
func (c *AssignmentClient) Query() *AssignmentQuery {
	return &AssignmentQuery{
		config: c.config,
	}
}

// Get returns a Assignment entity by its id.
func (c *AssignmentClient) Get(ctx context.Context, id uuid.UUID) (*Assignment, error) {
	return c.Query().Where(assignment.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *AssignmentClient) GetX(ctx context.Context, id uuid.UUID) *Assignment {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryClass queries the class edge of a Assignment.
func (c *AssignmentClient) QueryClass(a *Assignment) *ClassQuery {
	query := &ClassQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := a.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(assignment.Table, assignment.FieldID, id),
			sqlgraph.To(class.Table, class.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, assignment.ClassTable, assignment.ClassColumn),
		)
		fromV = sqlgraph.Neighbors(a.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QuerySubmissions queries the submissions edge of a Assignment.
func (c *AssignmentClient) QuerySubmissions(a *Assignment) *AssignmentSubmissionQuery {
	query := &AssignmentSubmissionQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := a.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(assignment.Table, assignment.FieldID, id),
			sqlgraph.To(assignmentsubmission.Table, assignmentsubmission.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, assignment.SubmissionsTable, assignment.SubmissionsColumn),
		)
		fromV = sqlgraph.Neighbors(a.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryGrades queries the grades edge of a Assignment.
func (c *AssignmentClient) QueryGrades(a *Assignment) *GradeQuery {
	query := &GradeQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := a.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(assignment.Table, assignment.FieldID, id),
			sqlgraph.To(grade.Table, grade.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, assignment.GradesTable, assignment.GradesColumn),
		)
		fromV = sqlgraph.Neighbors(a.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *AssignmentClient) Hooks() []Hook {
	return c.hooks.Assignment
}

// AssignmentSubmissionClient is a client for the AssignmentSubmission schema.
type AssignmentSubmissionClient struct {
	config
}

// NewAssignmentSubmissionClient returns a client for the AssignmentSubmission from the given config.
func NewAssignmentSubmissionClient(c config) *AssignmentSubmissionClient {
	return &AssignmentSubmissionClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `assignmentsubmission.Hooks(f(g(h())))`.
func (c *AssignmentSubmissionClient) Use(hooks ...Hook) {
	c.hooks.AssignmentSubmission = append(c.hooks.AssignmentSubmission, hooks...)
}

// Create returns a create builder for AssignmentSubmission.
func (c *AssignmentSubmissionClient) Create() *AssignmentSubmissionCreate {
	mutation := newAssignmentSubmissionMutation(c.config, OpCreate)
	return &AssignmentSubmissionCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of AssignmentSubmission entities.
func (c *AssignmentSubmissionClient) CreateBulk(builders ...*AssignmentSubmissionCreate) *AssignmentSubmissionCreateBulk {
	return &AssignmentSubmissionCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for AssignmentSubmission.
func (c *AssignmentSubmissionClient) Update() *AssignmentSubmissionUpdate {
	mutation := newAssignmentSubmissionMutation(c.config, OpUpdate)
	return &AssignmentSubmissionUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *AssignmentSubmissionClient) UpdateOne(as *AssignmentSubmission) *AssignmentSubmissionUpdateOne {
	mutation := newAssignmentSubmissionMutation(c.config, OpUpdateOne, withAssignmentSubmission(as))
	return &AssignmentSubmissionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *AssignmentSubmissionClient) UpdateOneID(id uuid.UUID) *AssignmentSubmissionUpdateOne {
	mutation := newAssignmentSubmissionMutation(c.config, OpUpdateOne, withAssignmentSubmissionID(id))
	return &AssignmentSubmissionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for AssignmentSubmission.
func (c *AssignmentSubmissionClient) Delete() *AssignmentSubmissionDelete {
	mutation := newAssignmentSubmissionMutation(c.config, OpDelete)
	return &AssignmentSubmissionDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *AssignmentSubmissionClient) DeleteOne(as *AssignmentSubmission) *AssignmentSubmissionDeleteOne {
	return c.DeleteOneID(as.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *AssignmentSubmissionClient) DeleteOneID(id uuid.UUID) *AssignmentSubmissionDeleteOne {
	builder := c.Delete().Where(assignmentsubmission.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &AssignmentSubmissionDeleteOne{builder}
}

// Query returns a query builder for AssignmentSubmission.
func (c *AssignmentSubmissionClient) Query() *AssignmentSubmissionQuery {
	return &AssignmentSubmissionQuery{
		config: c.config,
	}
}

// Get returns a AssignmentSubmission entity by its id.
func (c *AssignmentSubmissionClient) Get(ctx context.Context, id uuid.UUID) (*AssignmentSubmission, error) {
	return c.Query().Where(assignmentsubmission.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *AssignmentSubmissionClient) GetX(ctx context.Context, id uuid.UUID) *AssignmentSubmission {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryStudent queries the student edge of a AssignmentSubmission.
func (c *AssignmentSubmissionClient) QueryStudent(as *AssignmentSubmission) *UserQuery {
	query := &UserQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := as.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(assignmentsubmission.Table, assignmentsubmission.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, assignmentsubmission.StudentTable, assignmentsubmission.StudentColumn),
		)
		fromV = sqlgraph.Neighbors(as.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryAssignment queries the assignment edge of a AssignmentSubmission.
func (c *AssignmentSubmissionClient) QueryAssignment(as *AssignmentSubmission) *AssignmentQuery {
	query := &AssignmentQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := as.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(assignmentsubmission.Table, assignmentsubmission.FieldID, id),
			sqlgraph.To(assignment.Table, assignment.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, assignmentsubmission.AssignmentTable, assignmentsubmission.AssignmentColumn),
		)
		fromV = sqlgraph.Neighbors(as.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *AssignmentSubmissionClient) Hooks() []Hook {
	return c.hooks.AssignmentSubmission
}

// AttendanceClient is a client for the Attendance schema.
type AttendanceClient struct {
	config
}

// NewAttendanceClient returns a client for the Attendance from the given config.
func NewAttendanceClient(c config) *AttendanceClient {
	return &AttendanceClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `attendance.Hooks(f(g(h())))`.
func (c *AttendanceClient) Use(hooks ...Hook) {
	c.hooks.Attendance = append(c.hooks.Attendance, hooks...)
}

// Create returns a create builder for Attendance.
func (c *AttendanceClient) Create() *AttendanceCreate {
	mutation := newAttendanceMutation(c.config, OpCreate)
	return &AttendanceCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Attendance entities.
func (c *AttendanceClient) CreateBulk(builders ...*AttendanceCreate) *AttendanceCreateBulk {
	return &AttendanceCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Attendance.
func (c *AttendanceClient) Update() *AttendanceUpdate {
	mutation := newAttendanceMutation(c.config, OpUpdate)
	return &AttendanceUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *AttendanceClient) UpdateOne(a *Attendance) *AttendanceUpdateOne {
	mutation := newAttendanceMutation(c.config, OpUpdateOne, withAttendance(a))
	return &AttendanceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *AttendanceClient) UpdateOneID(id uuid.UUID) *AttendanceUpdateOne {
	mutation := newAttendanceMutation(c.config, OpUpdateOne, withAttendanceID(id))
	return &AttendanceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Attendance.
func (c *AttendanceClient) Delete() *AttendanceDelete {
	mutation := newAttendanceMutation(c.config, OpDelete)
	return &AttendanceDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *AttendanceClient) DeleteOne(a *Attendance) *AttendanceDeleteOne {
	return c.DeleteOneID(a.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *AttendanceClient) DeleteOneID(id uuid.UUID) *AttendanceDeleteOne {
	builder := c.Delete().Where(attendance.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &AttendanceDeleteOne{builder}
}

// Query returns a query builder for Attendance.
func (c *AttendanceClient) Query() *AttendanceQuery {
	return &AttendanceQuery{
		config: c.config,
	}
}

// Get returns a Attendance entity by its id.
func (c *AttendanceClient) Get(ctx context.Context, id uuid.UUID) (*Attendance, error) {
	return c.Query().Where(attendance.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *AttendanceClient) GetX(ctx context.Context, id uuid.UUID) *Attendance {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryClass queries the class edge of a Attendance.
func (c *AttendanceClient) QueryClass(a *Attendance) *ClassQuery {
	query := &ClassQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := a.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(attendance.Table, attendance.FieldID, id),
			sqlgraph.To(class.Table, class.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, attendance.ClassTable, attendance.ClassColumn),
		)
		fromV = sqlgraph.Neighbors(a.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryStudent queries the student edge of a Attendance.
func (c *AttendanceClient) QueryStudent(a *Attendance) *UserQuery {
	query := &UserQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := a.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(attendance.Table, attendance.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, attendance.StudentTable, attendance.StudentColumn),
		)
		fromV = sqlgraph.Neighbors(a.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *AttendanceClient) Hooks() []Hook {
	return c.hooks.Attendance
}

// ClassClient is a client for the Class schema.
type ClassClient struct {
	config
}

// NewClassClient returns a client for the Class from the given config.
func NewClassClient(c config) *ClassClient {
	return &ClassClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `class.Hooks(f(g(h())))`.
func (c *ClassClient) Use(hooks ...Hook) {
	c.hooks.Class = append(c.hooks.Class, hooks...)
}

// Create returns a create builder for Class.
func (c *ClassClient) Create() *ClassCreate {
	mutation := newClassMutation(c.config, OpCreate)
	return &ClassCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Class entities.
func (c *ClassClient) CreateBulk(builders ...*ClassCreate) *ClassCreateBulk {
	return &ClassCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Class.
func (c *ClassClient) Update() *ClassUpdate {
	mutation := newClassMutation(c.config, OpUpdate)
	return &ClassUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ClassClient) UpdateOne(cl *Class) *ClassUpdateOne {
	mutation := newClassMutation(c.config, OpUpdateOne, withClass(cl))
	return &ClassUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ClassClient) UpdateOneID(id uuid.UUID) *ClassUpdateOne {
	mutation := newClassMutation(c.config, OpUpdateOne, withClassID(id))
	return &ClassUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Class.
func (c *ClassClient) Delete() *ClassDelete {
	mutation := newClassMutation(c.config, OpDelete)
	return &ClassDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *ClassClient) DeleteOne(cl *Class) *ClassDeleteOne {
	return c.DeleteOneID(cl.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *ClassClient) DeleteOneID(id uuid.UUID) *ClassDeleteOne {
	builder := c.Delete().Where(class.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ClassDeleteOne{builder}
}

// Query returns a query builder for Class.
func (c *ClassClient) Query() *ClassQuery {
	return &ClassQuery{
		config: c.config,
	}
}

// Get returns a Class entity by its id.
func (c *ClassClient) Get(ctx context.Context, id uuid.UUID) (*Class, error) {
	return c.Query().Where(class.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ClassClient) GetX(ctx context.Context, id uuid.UUID) *Class {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryStage queries the stage edge of a Class.
func (c *ClassClient) QueryStage(cl *Class) *StageQuery {
	query := &StageQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := cl.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(class.Table, class.FieldID, id),
			sqlgraph.To(stage.Table, stage.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, class.StageTable, class.StageColumn),
		)
		fromV = sqlgraph.Neighbors(cl.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTeacher queries the teacher edge of a Class.
func (c *ClassClient) QueryTeacher(cl *Class) *UserQuery {
	query := &UserQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := cl.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(class.Table, class.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, class.TeacherTable, class.TeacherColumn),
		)
		fromV = sqlgraph.Neighbors(cl.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryGroup queries the group edge of a Class.
func (c *ClassClient) QueryGroup(cl *Class) *GroupQuery {
	query := &GroupQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := cl.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(class.Table, class.FieldID, id),
			sqlgraph.To(group.Table, group.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, class.GroupTable, class.GroupColumn),
		)
		fromV = sqlgraph.Neighbors(cl.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryAssignments queries the assignments edge of a Class.
func (c *ClassClient) QueryAssignments(cl *Class) *AssignmentQuery {
	query := &AssignmentQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := cl.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(class.Table, class.FieldID, id),
			sqlgraph.To(assignment.Table, assignment.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, class.AssignmentsTable, class.AssignmentsColumn),
		)
		fromV = sqlgraph.Neighbors(cl.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryAttendances queries the attendances edge of a Class.
func (c *ClassClient) QueryAttendances(cl *Class) *AttendanceQuery {
	query := &AttendanceQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := cl.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(class.Table, class.FieldID, id),
			sqlgraph.To(attendance.Table, attendance.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, class.AttendancesTable, class.AttendancesColumn),
		)
		fromV = sqlgraph.Neighbors(cl.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QuerySchedules queries the schedules edge of a Class.
func (c *ClassClient) QuerySchedules(cl *Class) *ScheduleQuery {
	query := &ScheduleQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := cl.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(class.Table, class.FieldID, id),
			sqlgraph.To(schedule.Table, schedule.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, class.SchedulesTable, class.SchedulesColumn),
		)
		fromV = sqlgraph.Neighbors(cl.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ClassClient) Hooks() []Hook {
	return c.hooks.Class
}

// GradeClient is a client for the Grade schema.
type GradeClient struct {
	config
}

// NewGradeClient returns a client for the Grade from the given config.
func NewGradeClient(c config) *GradeClient {
	return &GradeClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `grade.Hooks(f(g(h())))`.
func (c *GradeClient) Use(hooks ...Hook) {
	c.hooks.Grade = append(c.hooks.Grade, hooks...)
}

// Create returns a create builder for Grade.
func (c *GradeClient) Create() *GradeCreate {
	mutation := newGradeMutation(c.config, OpCreate)
	return &GradeCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Grade entities.
func (c *GradeClient) CreateBulk(builders ...*GradeCreate) *GradeCreateBulk {
	return &GradeCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Grade.
func (c *GradeClient) Update() *GradeUpdate {
	mutation := newGradeMutation(c.config, OpUpdate)
	return &GradeUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *GradeClient) UpdateOne(gr *Grade) *GradeUpdateOne {
	mutation := newGradeMutation(c.config, OpUpdateOne, withGrade(gr))
	return &GradeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *GradeClient) UpdateOneID(id uuid.UUID) *GradeUpdateOne {
	mutation := newGradeMutation(c.config, OpUpdateOne, withGradeID(id))
	return &GradeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Grade.
func (c *GradeClient) Delete() *GradeDelete {
	mutation := newGradeMutation(c.config, OpDelete)
	return &GradeDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *GradeClient) DeleteOne(gr *Grade) *GradeDeleteOne {
	return c.DeleteOneID(gr.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *GradeClient) DeleteOneID(id uuid.UUID) *GradeDeleteOne {
	builder := c.Delete().Where(grade.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &GradeDeleteOne{builder}
}

// Query returns a query builder for Grade.
func (c *GradeClient) Query() *GradeQuery {
	return &GradeQuery{
		config: c.config,
	}
}

// Get returns a Grade entity by its id.
func (c *GradeClient) Get(ctx context.Context, id uuid.UUID) (*Grade, error) {
	return c.Query().Where(grade.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *GradeClient) GetX(ctx context.Context, id uuid.UUID) *Grade {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryStudent queries the student edge of a Grade.
func (c *GradeClient) QueryStudent(gr *Grade) *UserQuery {
	query := &UserQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := gr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(grade.Table, grade.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, grade.StudentTable, grade.StudentColumn),
		)
		fromV = sqlgraph.Neighbors(gr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryExam queries the exam edge of a Grade.
func (c *GradeClient) QueryExam(gr *Grade) *AssignmentQuery {
	query := &AssignmentQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := gr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(grade.Table, grade.FieldID, id),
			sqlgraph.To(assignment.Table, assignment.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, grade.ExamTable, grade.ExamColumn),
		)
		fromV = sqlgraph.Neighbors(gr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *GradeClient) Hooks() []Hook {
	return c.hooks.Grade
}

// GroupClient is a client for the Group schema.
type GroupClient struct {
	config
}

// NewGroupClient returns a client for the Group from the given config.
func NewGroupClient(c config) *GroupClient {
	return &GroupClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `group.Hooks(f(g(h())))`.
func (c *GroupClient) Use(hooks ...Hook) {
	c.hooks.Group = append(c.hooks.Group, hooks...)
}

// Create returns a create builder for Group.
func (c *GroupClient) Create() *GroupCreate {
	mutation := newGroupMutation(c.config, OpCreate)
	return &GroupCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Group entities.
func (c *GroupClient) CreateBulk(builders ...*GroupCreate) *GroupCreateBulk {
	return &GroupCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Group.
func (c *GroupClient) Update() *GroupUpdate {
	mutation := newGroupMutation(c.config, OpUpdate)
	return &GroupUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *GroupClient) UpdateOne(gr *Group) *GroupUpdateOne {
	mutation := newGroupMutation(c.config, OpUpdateOne, withGroup(gr))
	return &GroupUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *GroupClient) UpdateOneID(id uuid.UUID) *GroupUpdateOne {
	mutation := newGroupMutation(c.config, OpUpdateOne, withGroupID(id))
	return &GroupUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Group.
func (c *GroupClient) Delete() *GroupDelete {
	mutation := newGroupMutation(c.config, OpDelete)
	return &GroupDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *GroupClient) DeleteOne(gr *Group) *GroupDeleteOne {
	return c.DeleteOneID(gr.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *GroupClient) DeleteOneID(id uuid.UUID) *GroupDeleteOne {
	builder := c.Delete().Where(group.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &GroupDeleteOne{builder}
}

// Query returns a query builder for Group.
func (c *GroupClient) Query() *GroupQuery {
	return &GroupQuery{
		config: c.config,
	}
}

// Get returns a Group entity by its id.
func (c *GroupClient) Get(ctx context.Context, id uuid.UUID) (*Group, error) {
	return c.Query().Where(group.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *GroupClient) GetX(ctx context.Context, id uuid.UUID) *Group {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryClass queries the class edge of a Group.
func (c *GroupClient) QueryClass(gr *Group) *ClassQuery {
	query := &ClassQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := gr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(group.Table, group.FieldID, id),
			sqlgraph.To(class.Table, class.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, group.ClassTable, group.ClassColumn),
		)
		fromV = sqlgraph.Neighbors(gr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryUsers queries the users edge of a Group.
func (c *GroupClient) QueryUsers(gr *Group) *UserQuery {
	query := &UserQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := gr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(group.Table, group.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, group.UsersTable, group.UsersPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(gr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryMessages queries the messages edge of a Group.
func (c *GroupClient) QueryMessages(gr *Group) *MessageQuery {
	query := &MessageQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := gr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(group.Table, group.FieldID, id),
			sqlgraph.To(message.Table, message.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, group.MessagesTable, group.MessagesColumn),
		)
		fromV = sqlgraph.Neighbors(gr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *GroupClient) Hooks() []Hook {
	return c.hooks.Group
}

// MessageClient is a client for the Message schema.
type MessageClient struct {
	config
}

// NewMessageClient returns a client for the Message from the given config.
func NewMessageClient(c config) *MessageClient {
	return &MessageClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `message.Hooks(f(g(h())))`.
func (c *MessageClient) Use(hooks ...Hook) {
	c.hooks.Message = append(c.hooks.Message, hooks...)
}

// Create returns a create builder for Message.
func (c *MessageClient) Create() *MessageCreate {
	mutation := newMessageMutation(c.config, OpCreate)
	return &MessageCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Message entities.
func (c *MessageClient) CreateBulk(builders ...*MessageCreate) *MessageCreateBulk {
	return &MessageCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Message.
func (c *MessageClient) Update() *MessageUpdate {
	mutation := newMessageMutation(c.config, OpUpdate)
	return &MessageUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *MessageClient) UpdateOne(m *Message) *MessageUpdateOne {
	mutation := newMessageMutation(c.config, OpUpdateOne, withMessage(m))
	return &MessageUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *MessageClient) UpdateOneID(id uuid.UUID) *MessageUpdateOne {
	mutation := newMessageMutation(c.config, OpUpdateOne, withMessageID(id))
	return &MessageUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Message.
func (c *MessageClient) Delete() *MessageDelete {
	mutation := newMessageMutation(c.config, OpDelete)
	return &MessageDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *MessageClient) DeleteOne(m *Message) *MessageDeleteOne {
	return c.DeleteOneID(m.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *MessageClient) DeleteOneID(id uuid.UUID) *MessageDeleteOne {
	builder := c.Delete().Where(message.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &MessageDeleteOne{builder}
}

// Query returns a query builder for Message.
func (c *MessageClient) Query() *MessageQuery {
	return &MessageQuery{
		config: c.config,
	}
}

// Get returns a Message entity by its id.
func (c *MessageClient) Get(ctx context.Context, id uuid.UUID) (*Message, error) {
	return c.Query().Where(message.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *MessageClient) GetX(ctx context.Context, id uuid.UUID) *Message {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryGroup queries the group edge of a Message.
func (c *MessageClient) QueryGroup(m *Message) *GroupQuery {
	query := &GroupQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(message.Table, message.FieldID, id),
			sqlgraph.To(group.Table, group.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, message.GroupTable, message.GroupColumn),
		)
		fromV = sqlgraph.Neighbors(m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryOwner queries the owner edge of a Message.
func (c *MessageClient) QueryOwner(m *Message) *UserQuery {
	query := &UserQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(message.Table, message.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, message.OwnerTable, message.OwnerColumn),
		)
		fromV = sqlgraph.Neighbors(m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *MessageClient) Hooks() []Hook {
	return c.hooks.Message
}

// ScheduleClient is a client for the Schedule schema.
type ScheduleClient struct {
	config
}

// NewScheduleClient returns a client for the Schedule from the given config.
func NewScheduleClient(c config) *ScheduleClient {
	return &ScheduleClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `schedule.Hooks(f(g(h())))`.
func (c *ScheduleClient) Use(hooks ...Hook) {
	c.hooks.Schedule = append(c.hooks.Schedule, hooks...)
}

// Create returns a create builder for Schedule.
func (c *ScheduleClient) Create() *ScheduleCreate {
	mutation := newScheduleMutation(c.config, OpCreate)
	return &ScheduleCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Schedule entities.
func (c *ScheduleClient) CreateBulk(builders ...*ScheduleCreate) *ScheduleCreateBulk {
	return &ScheduleCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Schedule.
func (c *ScheduleClient) Update() *ScheduleUpdate {
	mutation := newScheduleMutation(c.config, OpUpdate)
	return &ScheduleUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ScheduleClient) UpdateOne(s *Schedule) *ScheduleUpdateOne {
	mutation := newScheduleMutation(c.config, OpUpdateOne, withSchedule(s))
	return &ScheduleUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ScheduleClient) UpdateOneID(id uuid.UUID) *ScheduleUpdateOne {
	mutation := newScheduleMutation(c.config, OpUpdateOne, withScheduleID(id))
	return &ScheduleUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Schedule.
func (c *ScheduleClient) Delete() *ScheduleDelete {
	mutation := newScheduleMutation(c.config, OpDelete)
	return &ScheduleDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *ScheduleClient) DeleteOne(s *Schedule) *ScheduleDeleteOne {
	return c.DeleteOneID(s.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *ScheduleClient) DeleteOneID(id uuid.UUID) *ScheduleDeleteOne {
	builder := c.Delete().Where(schedule.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ScheduleDeleteOne{builder}
}

// Query returns a query builder for Schedule.
func (c *ScheduleClient) Query() *ScheduleQuery {
	return &ScheduleQuery{
		config: c.config,
	}
}

// Get returns a Schedule entity by its id.
func (c *ScheduleClient) Get(ctx context.Context, id uuid.UUID) (*Schedule, error) {
	return c.Query().Where(schedule.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ScheduleClient) GetX(ctx context.Context, id uuid.UUID) *Schedule {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryClass queries the class edge of a Schedule.
func (c *ScheduleClient) QueryClass(s *Schedule) *ClassQuery {
	query := &ClassQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := s.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(schedule.Table, schedule.FieldID, id),
			sqlgraph.To(class.Table, class.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, schedule.ClassTable, schedule.ClassColumn),
		)
		fromV = sqlgraph.Neighbors(s.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ScheduleClient) Hooks() []Hook {
	return c.hooks.Schedule
}

// SchoolClient is a client for the School schema.
type SchoolClient struct {
	config
}

// NewSchoolClient returns a client for the School from the given config.
func NewSchoolClient(c config) *SchoolClient {
	return &SchoolClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `school.Hooks(f(g(h())))`.
func (c *SchoolClient) Use(hooks ...Hook) {
	c.hooks.School = append(c.hooks.School, hooks...)
}

// Create returns a create builder for School.
func (c *SchoolClient) Create() *SchoolCreate {
	mutation := newSchoolMutation(c.config, OpCreate)
	return &SchoolCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of School entities.
func (c *SchoolClient) CreateBulk(builders ...*SchoolCreate) *SchoolCreateBulk {
	return &SchoolCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for School.
func (c *SchoolClient) Update() *SchoolUpdate {
	mutation := newSchoolMutation(c.config, OpUpdate)
	return &SchoolUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *SchoolClient) UpdateOne(s *School) *SchoolUpdateOne {
	mutation := newSchoolMutation(c.config, OpUpdateOne, withSchool(s))
	return &SchoolUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *SchoolClient) UpdateOneID(id uuid.UUID) *SchoolUpdateOne {
	mutation := newSchoolMutation(c.config, OpUpdateOne, withSchoolID(id))
	return &SchoolUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for School.
func (c *SchoolClient) Delete() *SchoolDelete {
	mutation := newSchoolMutation(c.config, OpDelete)
	return &SchoolDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *SchoolClient) DeleteOne(s *School) *SchoolDeleteOne {
	return c.DeleteOneID(s.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *SchoolClient) DeleteOneID(id uuid.UUID) *SchoolDeleteOne {
	builder := c.Delete().Where(school.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &SchoolDeleteOne{builder}
}

// Query returns a query builder for School.
func (c *SchoolClient) Query() *SchoolQuery {
	return &SchoolQuery{
		config: c.config,
	}
}

// Get returns a School entity by its id.
func (c *SchoolClient) Get(ctx context.Context, id uuid.UUID) (*School, error) {
	return c.Query().Where(school.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *SchoolClient) GetX(ctx context.Context, id uuid.UUID) *School {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUsers queries the users edge of a School.
func (c *SchoolClient) QueryUsers(s *School) *UserQuery {
	query := &UserQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := s.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(school.Table, school.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, school.UsersTable, school.UsersColumn),
		)
		fromV = sqlgraph.Neighbors(s.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryStages queries the stages edge of a School.
func (c *SchoolClient) QueryStages(s *School) *StageQuery {
	query := &StageQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := s.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(school.Table, school.FieldID, id),
			sqlgraph.To(stage.Table, stage.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, school.StagesTable, school.StagesColumn),
		)
		fromV = sqlgraph.Neighbors(s.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *SchoolClient) Hooks() []Hook {
	return c.hooks.School
}

// StageClient is a client for the Stage schema.
type StageClient struct {
	config
}

// NewStageClient returns a client for the Stage from the given config.
func NewStageClient(c config) *StageClient {
	return &StageClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `stage.Hooks(f(g(h())))`.
func (c *StageClient) Use(hooks ...Hook) {
	c.hooks.Stage = append(c.hooks.Stage, hooks...)
}

// Create returns a create builder for Stage.
func (c *StageClient) Create() *StageCreate {
	mutation := newStageMutation(c.config, OpCreate)
	return &StageCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Stage entities.
func (c *StageClient) CreateBulk(builders ...*StageCreate) *StageCreateBulk {
	return &StageCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Stage.
func (c *StageClient) Update() *StageUpdate {
	mutation := newStageMutation(c.config, OpUpdate)
	return &StageUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *StageClient) UpdateOne(s *Stage) *StageUpdateOne {
	mutation := newStageMutation(c.config, OpUpdateOne, withStage(s))
	return &StageUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *StageClient) UpdateOneID(id uuid.UUID) *StageUpdateOne {
	mutation := newStageMutation(c.config, OpUpdateOne, withStageID(id))
	return &StageUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Stage.
func (c *StageClient) Delete() *StageDelete {
	mutation := newStageMutation(c.config, OpDelete)
	return &StageDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *StageClient) DeleteOne(s *Stage) *StageDeleteOne {
	return c.DeleteOneID(s.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *StageClient) DeleteOneID(id uuid.UUID) *StageDeleteOne {
	builder := c.Delete().Where(stage.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &StageDeleteOne{builder}
}

// Query returns a query builder for Stage.
func (c *StageClient) Query() *StageQuery {
	return &StageQuery{
		config: c.config,
	}
}

// Get returns a Stage entity by its id.
func (c *StageClient) Get(ctx context.Context, id uuid.UUID) (*Stage, error) {
	return c.Query().Where(stage.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *StageClient) GetX(ctx context.Context, id uuid.UUID) *Stage {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QuerySchool queries the school edge of a Stage.
func (c *StageClient) QuerySchool(s *Stage) *SchoolQuery {
	query := &SchoolQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := s.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(stage.Table, stage.FieldID, id),
			sqlgraph.To(school.Table, school.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, stage.SchoolTable, stage.SchoolColumn),
		)
		fromV = sqlgraph.Neighbors(s.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryClasses queries the classes edge of a Stage.
func (c *StageClient) QueryClasses(s *Stage) *ClassQuery {
	query := &ClassQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := s.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(stage.Table, stage.FieldID, id),
			sqlgraph.To(class.Table, class.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, stage.ClassesTable, stage.ClassesColumn),
		)
		fromV = sqlgraph.Neighbors(s.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPayments queries the payments edge of a Stage.
func (c *StageClient) QueryPayments(s *Stage) *TuitionPaymentQuery {
	query := &TuitionPaymentQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := s.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(stage.Table, stage.FieldID, id),
			sqlgraph.To(tuitionpayment.Table, tuitionpayment.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, stage.PaymentsTable, stage.PaymentsColumn),
		)
		fromV = sqlgraph.Neighbors(s.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryStudents queries the students edge of a Stage.
func (c *StageClient) QueryStudents(s *Stage) *UserQuery {
	query := &UserQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := s.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(stage.Table, stage.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, stage.StudentsTable, stage.StudentsColumn),
		)
		fromV = sqlgraph.Neighbors(s.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *StageClient) Hooks() []Hook {
	return c.hooks.Stage
}

// TuitionPaymentClient is a client for the TuitionPayment schema.
type TuitionPaymentClient struct {
	config
}

// NewTuitionPaymentClient returns a client for the TuitionPayment from the given config.
func NewTuitionPaymentClient(c config) *TuitionPaymentClient {
	return &TuitionPaymentClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `tuitionpayment.Hooks(f(g(h())))`.
func (c *TuitionPaymentClient) Use(hooks ...Hook) {
	c.hooks.TuitionPayment = append(c.hooks.TuitionPayment, hooks...)
}

// Create returns a create builder for TuitionPayment.
func (c *TuitionPaymentClient) Create() *TuitionPaymentCreate {
	mutation := newTuitionPaymentMutation(c.config, OpCreate)
	return &TuitionPaymentCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of TuitionPayment entities.
func (c *TuitionPaymentClient) CreateBulk(builders ...*TuitionPaymentCreate) *TuitionPaymentCreateBulk {
	return &TuitionPaymentCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for TuitionPayment.
func (c *TuitionPaymentClient) Update() *TuitionPaymentUpdate {
	mutation := newTuitionPaymentMutation(c.config, OpUpdate)
	return &TuitionPaymentUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *TuitionPaymentClient) UpdateOne(tp *TuitionPayment) *TuitionPaymentUpdateOne {
	mutation := newTuitionPaymentMutation(c.config, OpUpdateOne, withTuitionPayment(tp))
	return &TuitionPaymentUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *TuitionPaymentClient) UpdateOneID(id uuid.UUID) *TuitionPaymentUpdateOne {
	mutation := newTuitionPaymentMutation(c.config, OpUpdateOne, withTuitionPaymentID(id))
	return &TuitionPaymentUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for TuitionPayment.
func (c *TuitionPaymentClient) Delete() *TuitionPaymentDelete {
	mutation := newTuitionPaymentMutation(c.config, OpDelete)
	return &TuitionPaymentDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *TuitionPaymentClient) DeleteOne(tp *TuitionPayment) *TuitionPaymentDeleteOne {
	return c.DeleteOneID(tp.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *TuitionPaymentClient) DeleteOneID(id uuid.UUID) *TuitionPaymentDeleteOne {
	builder := c.Delete().Where(tuitionpayment.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &TuitionPaymentDeleteOne{builder}
}

// Query returns a query builder for TuitionPayment.
func (c *TuitionPaymentClient) Query() *TuitionPaymentQuery {
	return &TuitionPaymentQuery{
		config: c.config,
	}
}

// Get returns a TuitionPayment entity by its id.
func (c *TuitionPaymentClient) Get(ctx context.Context, id uuid.UUID) (*TuitionPayment, error) {
	return c.Query().Where(tuitionpayment.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *TuitionPaymentClient) GetX(ctx context.Context, id uuid.UUID) *TuitionPayment {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryStudent queries the student edge of a TuitionPayment.
func (c *TuitionPaymentClient) QueryStudent(tp *TuitionPayment) *UserQuery {
	query := &UserQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := tp.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(tuitionpayment.Table, tuitionpayment.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, tuitionpayment.StudentTable, tuitionpayment.StudentColumn),
		)
		fromV = sqlgraph.Neighbors(tp.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryStage queries the stage edge of a TuitionPayment.
func (c *TuitionPaymentClient) QueryStage(tp *TuitionPayment) *StageQuery {
	query := &StageQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := tp.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(tuitionpayment.Table, tuitionpayment.FieldID, id),
			sqlgraph.To(stage.Table, stage.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, tuitionpayment.StageTable, tuitionpayment.StageColumn),
		)
		fromV = sqlgraph.Neighbors(tp.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *TuitionPaymentClient) Hooks() []Hook {
	return c.hooks.TuitionPayment
}

// UserClient is a client for the User schema.
type UserClient struct {
	config
}

// NewUserClient returns a client for the User from the given config.
func NewUserClient(c config) *UserClient {
	return &UserClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `user.Hooks(f(g(h())))`.
func (c *UserClient) Use(hooks ...Hook) {
	c.hooks.User = append(c.hooks.User, hooks...)
}

// Create returns a create builder for User.
func (c *UserClient) Create() *UserCreate {
	mutation := newUserMutation(c.config, OpCreate)
	return &UserCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of User entities.
func (c *UserClient) CreateBulk(builders ...*UserCreate) *UserCreateBulk {
	return &UserCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for User.
func (c *UserClient) Update() *UserUpdate {
	mutation := newUserMutation(c.config, OpUpdate)
	return &UserUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *UserClient) UpdateOne(u *User) *UserUpdateOne {
	mutation := newUserMutation(c.config, OpUpdateOne, withUser(u))
	return &UserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *UserClient) UpdateOneID(id uuid.UUID) *UserUpdateOne {
	mutation := newUserMutation(c.config, OpUpdateOne, withUserID(id))
	return &UserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for User.
func (c *UserClient) Delete() *UserDelete {
	mutation := newUserMutation(c.config, OpDelete)
	return &UserDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *UserClient) DeleteOne(u *User) *UserDeleteOne {
	return c.DeleteOneID(u.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *UserClient) DeleteOneID(id uuid.UUID) *UserDeleteOne {
	builder := c.Delete().Where(user.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &UserDeleteOne{builder}
}

// Query returns a query builder for User.
func (c *UserClient) Query() *UserQuery {
	return &UserQuery{
		config: c.config,
	}
}

// Get returns a User entity by its id.
func (c *UserClient) Get(ctx context.Context, id uuid.UUID) (*User, error) {
	return c.Query().Where(user.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *UserClient) GetX(ctx context.Context, id uuid.UUID) *User {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryStage queries the stage edge of a User.
func (c *UserClient) QueryStage(u *User) *StageQuery {
	query := &StageQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(stage.Table, stage.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, user.StageTable, user.StageColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QuerySchool queries the school edge of a User.
func (c *UserClient) QuerySchool(u *User) *SchoolQuery {
	query := &SchoolQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(school.Table, school.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, user.SchoolTable, user.SchoolColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryClasses queries the classes edge of a User.
func (c *UserClient) QueryClasses(u *User) *ClassQuery {
	query := &ClassQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(class.Table, class.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.ClassesTable, user.ClassesColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryMessages queries the messages edge of a User.
func (c *UserClient) QueryMessages(u *User) *MessageQuery {
	query := &MessageQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(message.Table, message.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.MessagesTable, user.MessagesColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QuerySubmissions queries the submissions edge of a User.
func (c *UserClient) QuerySubmissions(u *User) *AssignmentSubmissionQuery {
	query := &AssignmentSubmissionQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(assignmentsubmission.Table, assignmentsubmission.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.SubmissionsTable, user.SubmissionsColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryAttendances queries the attendances edge of a User.
func (c *UserClient) QueryAttendances(u *User) *AttendanceQuery {
	query := &AttendanceQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(attendance.Table, attendance.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.AttendancesTable, user.AttendancesColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPayments queries the payments edge of a User.
func (c *UserClient) QueryPayments(u *User) *TuitionPaymentQuery {
	query := &TuitionPaymentQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(tuitionpayment.Table, tuitionpayment.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.PaymentsTable, user.PaymentsColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryGrades queries the grades edge of a User.
func (c *UserClient) QueryGrades(u *User) *GradeQuery {
	query := &GradeQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(grade.Table, grade.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.GradesTable, user.GradesColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryGroups queries the groups edge of a User.
func (c *UserClient) QueryGroups(u *User) *GroupQuery {
	query := &GroupQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(group.Table, group.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, user.GroupsTable, user.GroupsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *UserClient) Hooks() []Hook {
	return c.hooks.User
}
