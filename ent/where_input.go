// Code generated by entc, DO NOT EDIT.

package ent

import (
	"fmt"
	"time"

	"github.com/google/uuid"
	"github.com/msal4/hassah_school_server/ent/assignment"
	"github.com/msal4/hassah_school_server/ent/assignmentsubmission"
	"github.com/msal4/hassah_school_server/ent/attendance"
	"github.com/msal4/hassah_school_server/ent/class"
	"github.com/msal4/hassah_school_server/ent/coursegrade"
	"github.com/msal4/hassah_school_server/ent/grade"
	"github.com/msal4/hassah_school_server/ent/group"
	"github.com/msal4/hassah_school_server/ent/message"
	"github.com/msal4/hassah_school_server/ent/predicate"
	"github.com/msal4/hassah_school_server/ent/schedule"
	"github.com/msal4/hassah_school_server/ent/school"
	"github.com/msal4/hassah_school_server/ent/stage"
	"github.com/msal4/hassah_school_server/ent/tuitionpayment"
	"github.com/msal4/hassah_school_server/ent/user"
)

// AssignmentWhereInput represents a where input for filtering Assignment queries.
type AssignmentWhereInput struct {
	Not *AssignmentWhereInput   `json:"not,omitempty"`
	Or  []*AssignmentWhereInput `json:"or,omitempty"`
	And []*AssignmentWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *uuid.UUID  `json:"id,omitempty"`
	IDNEQ   *uuid.UUID  `json:"idNEQ,omitempty"`
	IDIn    []uuid.UUID `json:"idIn,omitempty"`
	IDNotIn []uuid.UUID `json:"idNotIn,omitempty"`
	IDGT    *uuid.UUID  `json:"idGT,omitempty"`
	IDGTE   *uuid.UUID  `json:"idGTE,omitempty"`
	IDLT    *uuid.UUID  `json:"idLT,omitempty"`
	IDLTE   *uuid.UUID  `json:"idLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt      *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedAtLTE,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "description" field predicates.
	Description             *string  `json:"description,omitempty"`
	DescriptionNEQ          *string  `json:"descriptionNEQ,omitempty"`
	DescriptionIn           []string `json:"descriptionIn,omitempty"`
	DescriptionNotIn        []string `json:"descriptionNotIn,omitempty"`
	DescriptionGT           *string  `json:"descriptionGT,omitempty"`
	DescriptionGTE          *string  `json:"descriptionGTE,omitempty"`
	DescriptionLT           *string  `json:"descriptionLT,omitempty"`
	DescriptionLTE          *string  `json:"descriptionLTE,omitempty"`
	DescriptionContains     *string  `json:"descriptionContains,omitempty"`
	DescriptionHasPrefix    *string  `json:"descriptionHasPrefix,omitempty"`
	DescriptionHasSuffix    *string  `json:"descriptionHasSuffix,omitempty"`
	DescriptionIsNil        bool     `json:"descriptionIsNil,omitempty"`
	DescriptionNotNil       bool     `json:"descriptionNotNil,omitempty"`
	DescriptionEqualFold    *string  `json:"descriptionEqualFold,omitempty"`
	DescriptionContainsFold *string  `json:"descriptionContainsFold,omitempty"`

	// "file" field predicates.
	File             *string  `json:"file,omitempty"`
	FileNEQ          *string  `json:"fileNEQ,omitempty"`
	FileIn           []string `json:"fileIn,omitempty"`
	FileNotIn        []string `json:"fileNotIn,omitempty"`
	FileGT           *string  `json:"fileGT,omitempty"`
	FileGTE          *string  `json:"fileGTE,omitempty"`
	FileLT           *string  `json:"fileLT,omitempty"`
	FileLTE          *string  `json:"fileLTE,omitempty"`
	FileContains     *string  `json:"fileContains,omitempty"`
	FileHasPrefix    *string  `json:"fileHasPrefix,omitempty"`
	FileHasSuffix    *string  `json:"fileHasSuffix,omitempty"`
	FileIsNil        bool     `json:"fileIsNil,omitempty"`
	FileNotNil       bool     `json:"fileNotNil,omitempty"`
	FileEqualFold    *string  `json:"fileEqualFold,omitempty"`
	FileContainsFold *string  `json:"fileContainsFold,omitempty"`

	// "is_exam" field predicates.
	IsExam    *bool `json:"isExam,omitempty"`
	IsExamNEQ *bool `json:"isExamNEQ,omitempty"`

	// "due_date" field predicates.
	DueDate      *time.Time  `json:"dueDate,omitempty"`
	DueDateNEQ   *time.Time  `json:"dueDateNEQ,omitempty"`
	DueDateIn    []time.Time `json:"dueDateIn,omitempty"`
	DueDateNotIn []time.Time `json:"dueDateNotIn,omitempty"`
	DueDateGT    *time.Time  `json:"dueDateGT,omitempty"`
	DueDateGTE   *time.Time  `json:"dueDateGTE,omitempty"`
	DueDateLT    *time.Time  `json:"dueDateLT,omitempty"`
	DueDateLTE   *time.Time  `json:"dueDateLTE,omitempty"`

	// "duration" field predicates.
	Duration       *time.Duration  `json:"duration,omitempty"`
	DurationNEQ    *time.Duration  `json:"durationNEQ,omitempty"`
	DurationIn     []time.Duration `json:"durationIn,omitempty"`
	DurationNotIn  []time.Duration `json:"durationNotIn,omitempty"`
	DurationGT     *time.Duration  `json:"durationGT,omitempty"`
	DurationGTE    *time.Duration  `json:"durationGTE,omitempty"`
	DurationLT     *time.Duration  `json:"durationLT,omitempty"`
	DurationLTE    *time.Duration  `json:"durationLTE,omitempty"`
	DurationIsNil  bool            `json:"durationIsNil,omitempty"`
	DurationNotNil bool            `json:"durationNotNil,omitempty"`

	// "deleted_at" field predicates.
	DeletedAt       *time.Time  `json:"deletedAt,omitempty"`
	DeletedAtNEQ    *time.Time  `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGT     *time.Time  `json:"deletedAtGT,omitempty"`
	DeletedAtGTE    *time.Time  `json:"deletedAtGTE,omitempty"`
	DeletedAtLT     *time.Time  `json:"deletedAtLT,omitempty"`
	DeletedAtLTE    *time.Time  `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil bool        `json:"deletedAtNotNil,omitempty"`

	// "class" edge predicates.
	HasClass     *bool              `json:"hasClass,omitempty"`
	HasClassWith []*ClassWhereInput `json:"hasClassWith,omitempty"`

	// "submissions" edge predicates.
	HasSubmissions     *bool                             `json:"hasSubmissions,omitempty"`
	HasSubmissionsWith []*AssignmentSubmissionWhereInput `json:"hasSubmissionsWith,omitempty"`

	// "grades" edge predicates.
	HasGrades     *bool              `json:"hasGrades,omitempty"`
	HasGradesWith []*GradeWhereInput `json:"hasGradesWith,omitempty"`
}

// Filter applies the AssignmentWhereInput filter on the AssignmentQuery builder.
func (i *AssignmentWhereInput) Filter(q *AssignmentQuery) (*AssignmentQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		return nil, err
	}
	return q.Where(p), nil
}

// P returns a predicate for filtering assignments.
// An error is returned if the input is empty or invalid.
func (i *AssignmentWhereInput) P() (predicate.Assignment, error) {
	var predicates []predicate.Assignment
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, assignment.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Assignment, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			or = append(or, p)
		}
		predicates = append(predicates, assignment.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Assignment, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			and = append(and, p)
		}
		predicates = append(predicates, assignment.And(and...))
	}
	if i.ID != nil {
		predicates = append(predicates, assignment.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, assignment.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, assignment.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, assignment.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, assignment.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, assignment.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, assignment.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, assignment.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, assignment.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, assignment.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, assignment.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, assignment.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, assignment.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, assignment.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, assignment.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, assignment.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, assignment.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, assignment.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, assignment.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, assignment.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, assignment.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, assignment.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, assignment.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, assignment.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.Name != nil {
		predicates = append(predicates, assignment.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, assignment.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, assignment.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, assignment.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, assignment.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, assignment.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, assignment.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, assignment.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, assignment.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, assignment.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, assignment.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, assignment.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, assignment.NameContainsFold(*i.NameContainsFold))
	}
	if i.Description != nil {
		predicates = append(predicates, assignment.DescriptionEQ(*i.Description))
	}
	if i.DescriptionNEQ != nil {
		predicates = append(predicates, assignment.DescriptionNEQ(*i.DescriptionNEQ))
	}
	if len(i.DescriptionIn) > 0 {
		predicates = append(predicates, assignment.DescriptionIn(i.DescriptionIn...))
	}
	if len(i.DescriptionNotIn) > 0 {
		predicates = append(predicates, assignment.DescriptionNotIn(i.DescriptionNotIn...))
	}
	if i.DescriptionGT != nil {
		predicates = append(predicates, assignment.DescriptionGT(*i.DescriptionGT))
	}
	if i.DescriptionGTE != nil {
		predicates = append(predicates, assignment.DescriptionGTE(*i.DescriptionGTE))
	}
	if i.DescriptionLT != nil {
		predicates = append(predicates, assignment.DescriptionLT(*i.DescriptionLT))
	}
	if i.DescriptionLTE != nil {
		predicates = append(predicates, assignment.DescriptionLTE(*i.DescriptionLTE))
	}
	if i.DescriptionContains != nil {
		predicates = append(predicates, assignment.DescriptionContains(*i.DescriptionContains))
	}
	if i.DescriptionHasPrefix != nil {
		predicates = append(predicates, assignment.DescriptionHasPrefix(*i.DescriptionHasPrefix))
	}
	if i.DescriptionHasSuffix != nil {
		predicates = append(predicates, assignment.DescriptionHasSuffix(*i.DescriptionHasSuffix))
	}
	if i.DescriptionIsNil {
		predicates = append(predicates, assignment.DescriptionIsNil())
	}
	if i.DescriptionNotNil {
		predicates = append(predicates, assignment.DescriptionNotNil())
	}
	if i.DescriptionEqualFold != nil {
		predicates = append(predicates, assignment.DescriptionEqualFold(*i.DescriptionEqualFold))
	}
	if i.DescriptionContainsFold != nil {
		predicates = append(predicates, assignment.DescriptionContainsFold(*i.DescriptionContainsFold))
	}
	if i.File != nil {
		predicates = append(predicates, assignment.FileEQ(*i.File))
	}
	if i.FileNEQ != nil {
		predicates = append(predicates, assignment.FileNEQ(*i.FileNEQ))
	}
	if len(i.FileIn) > 0 {
		predicates = append(predicates, assignment.FileIn(i.FileIn...))
	}
	if len(i.FileNotIn) > 0 {
		predicates = append(predicates, assignment.FileNotIn(i.FileNotIn...))
	}
	if i.FileGT != nil {
		predicates = append(predicates, assignment.FileGT(*i.FileGT))
	}
	if i.FileGTE != nil {
		predicates = append(predicates, assignment.FileGTE(*i.FileGTE))
	}
	if i.FileLT != nil {
		predicates = append(predicates, assignment.FileLT(*i.FileLT))
	}
	if i.FileLTE != nil {
		predicates = append(predicates, assignment.FileLTE(*i.FileLTE))
	}
	if i.FileContains != nil {
		predicates = append(predicates, assignment.FileContains(*i.FileContains))
	}
	if i.FileHasPrefix != nil {
		predicates = append(predicates, assignment.FileHasPrefix(*i.FileHasPrefix))
	}
	if i.FileHasSuffix != nil {
		predicates = append(predicates, assignment.FileHasSuffix(*i.FileHasSuffix))
	}
	if i.FileIsNil {
		predicates = append(predicates, assignment.FileIsNil())
	}
	if i.FileNotNil {
		predicates = append(predicates, assignment.FileNotNil())
	}
	if i.FileEqualFold != nil {
		predicates = append(predicates, assignment.FileEqualFold(*i.FileEqualFold))
	}
	if i.FileContainsFold != nil {
		predicates = append(predicates, assignment.FileContainsFold(*i.FileContainsFold))
	}
	if i.IsExam != nil {
		predicates = append(predicates, assignment.IsExamEQ(*i.IsExam))
	}
	if i.IsExamNEQ != nil {
		predicates = append(predicates, assignment.IsExamNEQ(*i.IsExamNEQ))
	}
	if i.DueDate != nil {
		predicates = append(predicates, assignment.DueDateEQ(*i.DueDate))
	}
	if i.DueDateNEQ != nil {
		predicates = append(predicates, assignment.DueDateNEQ(*i.DueDateNEQ))
	}
	if len(i.DueDateIn) > 0 {
		predicates = append(predicates, assignment.DueDateIn(i.DueDateIn...))
	}
	if len(i.DueDateNotIn) > 0 {
		predicates = append(predicates, assignment.DueDateNotIn(i.DueDateNotIn...))
	}
	if i.DueDateGT != nil {
		predicates = append(predicates, assignment.DueDateGT(*i.DueDateGT))
	}
	if i.DueDateGTE != nil {
		predicates = append(predicates, assignment.DueDateGTE(*i.DueDateGTE))
	}
	if i.DueDateLT != nil {
		predicates = append(predicates, assignment.DueDateLT(*i.DueDateLT))
	}
	if i.DueDateLTE != nil {
		predicates = append(predicates, assignment.DueDateLTE(*i.DueDateLTE))
	}
	if i.Duration != nil {
		predicates = append(predicates, assignment.DurationEQ(*i.Duration))
	}
	if i.DurationNEQ != nil {
		predicates = append(predicates, assignment.DurationNEQ(*i.DurationNEQ))
	}
	if len(i.DurationIn) > 0 {
		predicates = append(predicates, assignment.DurationIn(i.DurationIn...))
	}
	if len(i.DurationNotIn) > 0 {
		predicates = append(predicates, assignment.DurationNotIn(i.DurationNotIn...))
	}
	if i.DurationGT != nil {
		predicates = append(predicates, assignment.DurationGT(*i.DurationGT))
	}
	if i.DurationGTE != nil {
		predicates = append(predicates, assignment.DurationGTE(*i.DurationGTE))
	}
	if i.DurationLT != nil {
		predicates = append(predicates, assignment.DurationLT(*i.DurationLT))
	}
	if i.DurationLTE != nil {
		predicates = append(predicates, assignment.DurationLTE(*i.DurationLTE))
	}
	if i.DurationIsNil {
		predicates = append(predicates, assignment.DurationIsNil())
	}
	if i.DurationNotNil {
		predicates = append(predicates, assignment.DurationNotNil())
	}
	if i.DeletedAt != nil {
		predicates = append(predicates, assignment.DeletedAtEQ(*i.DeletedAt))
	}
	if i.DeletedAtNEQ != nil {
		predicates = append(predicates, assignment.DeletedAtNEQ(*i.DeletedAtNEQ))
	}
	if len(i.DeletedAtIn) > 0 {
		predicates = append(predicates, assignment.DeletedAtIn(i.DeletedAtIn...))
	}
	if len(i.DeletedAtNotIn) > 0 {
		predicates = append(predicates, assignment.DeletedAtNotIn(i.DeletedAtNotIn...))
	}
	if i.DeletedAtGT != nil {
		predicates = append(predicates, assignment.DeletedAtGT(*i.DeletedAtGT))
	}
	if i.DeletedAtGTE != nil {
		predicates = append(predicates, assignment.DeletedAtGTE(*i.DeletedAtGTE))
	}
	if i.DeletedAtLT != nil {
		predicates = append(predicates, assignment.DeletedAtLT(*i.DeletedAtLT))
	}
	if i.DeletedAtLTE != nil {
		predicates = append(predicates, assignment.DeletedAtLTE(*i.DeletedAtLTE))
	}
	if i.DeletedAtIsNil {
		predicates = append(predicates, assignment.DeletedAtIsNil())
	}
	if i.DeletedAtNotNil {
		predicates = append(predicates, assignment.DeletedAtNotNil())
	}

	if i.HasClass != nil {
		p := assignment.HasClass()
		if !*i.HasClass {
			p = assignment.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasClassWith) > 0 {
		with := make([]predicate.Class, 0, len(i.HasClassWith))
		for _, w := range i.HasClassWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, assignment.HasClassWith(with...))
	}
	if i.HasSubmissions != nil {
		p := assignment.HasSubmissions()
		if !*i.HasSubmissions {
			p = assignment.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasSubmissionsWith) > 0 {
		with := make([]predicate.AssignmentSubmission, 0, len(i.HasSubmissionsWith))
		for _, w := range i.HasSubmissionsWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, assignment.HasSubmissionsWith(with...))
	}
	if i.HasGrades != nil {
		p := assignment.HasGrades()
		if !*i.HasGrades {
			p = assignment.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasGradesWith) > 0 {
		with := make([]predicate.Grade, 0, len(i.HasGradesWith))
		for _, w := range i.HasGradesWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, assignment.HasGradesWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, fmt.Errorf("github.com/msal4/hassah_school_server/ent: empty predicate AssignmentWhereInput")
	case 1:
		return predicates[0], nil
	default:
		return assignment.And(predicates...), nil
	}
}

// AssignmentSubmissionWhereInput represents a where input for filtering AssignmentSubmission queries.
type AssignmentSubmissionWhereInput struct {
	Not *AssignmentSubmissionWhereInput   `json:"not,omitempty"`
	Or  []*AssignmentSubmissionWhereInput `json:"or,omitempty"`
	And []*AssignmentSubmissionWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *uuid.UUID  `json:"id,omitempty"`
	IDNEQ   *uuid.UUID  `json:"idNEQ,omitempty"`
	IDIn    []uuid.UUID `json:"idIn,omitempty"`
	IDNotIn []uuid.UUID `json:"idNotIn,omitempty"`
	IDGT    *uuid.UUID  `json:"idGT,omitempty"`
	IDGTE   *uuid.UUID  `json:"idGTE,omitempty"`
	IDLT    *uuid.UUID  `json:"idLT,omitempty"`
	IDLTE   *uuid.UUID  `json:"idLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt      *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedAtLTE,omitempty"`

	// "submitted_at" field predicates.
	SubmittedAt       *time.Time  `json:"submittedAt,omitempty"`
	SubmittedAtNEQ    *time.Time  `json:"submittedAtNEQ,omitempty"`
	SubmittedAtIn     []time.Time `json:"submittedAtIn,omitempty"`
	SubmittedAtNotIn  []time.Time `json:"submittedAtNotIn,omitempty"`
	SubmittedAtGT     *time.Time  `json:"submittedAtGT,omitempty"`
	SubmittedAtGTE    *time.Time  `json:"submittedAtGTE,omitempty"`
	SubmittedAtLT     *time.Time  `json:"submittedAtLT,omitempty"`
	SubmittedAtLTE    *time.Time  `json:"submittedAtLTE,omitempty"`
	SubmittedAtIsNil  bool        `json:"submittedAtIsNil,omitempty"`
	SubmittedAtNotNil bool        `json:"submittedAtNotNil,omitempty"`

	// "student" edge predicates.
	HasStudent     *bool             `json:"hasStudent,omitempty"`
	HasStudentWith []*UserWhereInput `json:"hasStudentWith,omitempty"`

	// "assignment" edge predicates.
	HasAssignment     *bool                   `json:"hasAssignment,omitempty"`
	HasAssignmentWith []*AssignmentWhereInput `json:"hasAssignmentWith,omitempty"`
}

// Filter applies the AssignmentSubmissionWhereInput filter on the AssignmentSubmissionQuery builder.
func (i *AssignmentSubmissionWhereInput) Filter(q *AssignmentSubmissionQuery) (*AssignmentSubmissionQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		return nil, err
	}
	return q.Where(p), nil
}

// P returns a predicate for filtering assignmentsubmissions.
// An error is returned if the input is empty or invalid.
func (i *AssignmentSubmissionWhereInput) P() (predicate.AssignmentSubmission, error) {
	var predicates []predicate.AssignmentSubmission
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, assignmentsubmission.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.AssignmentSubmission, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			or = append(or, p)
		}
		predicates = append(predicates, assignmentsubmission.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.AssignmentSubmission, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			and = append(and, p)
		}
		predicates = append(predicates, assignmentsubmission.And(and...))
	}
	if i.ID != nil {
		predicates = append(predicates, assignmentsubmission.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, assignmentsubmission.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, assignmentsubmission.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, assignmentsubmission.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, assignmentsubmission.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, assignmentsubmission.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, assignmentsubmission.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, assignmentsubmission.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, assignmentsubmission.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, assignmentsubmission.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, assignmentsubmission.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, assignmentsubmission.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, assignmentsubmission.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, assignmentsubmission.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, assignmentsubmission.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, assignmentsubmission.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, assignmentsubmission.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, assignmentsubmission.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, assignmentsubmission.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, assignmentsubmission.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, assignmentsubmission.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, assignmentsubmission.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, assignmentsubmission.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, assignmentsubmission.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.SubmittedAt != nil {
		predicates = append(predicates, assignmentsubmission.SubmittedAtEQ(*i.SubmittedAt))
	}
	if i.SubmittedAtNEQ != nil {
		predicates = append(predicates, assignmentsubmission.SubmittedAtNEQ(*i.SubmittedAtNEQ))
	}
	if len(i.SubmittedAtIn) > 0 {
		predicates = append(predicates, assignmentsubmission.SubmittedAtIn(i.SubmittedAtIn...))
	}
	if len(i.SubmittedAtNotIn) > 0 {
		predicates = append(predicates, assignmentsubmission.SubmittedAtNotIn(i.SubmittedAtNotIn...))
	}
	if i.SubmittedAtGT != nil {
		predicates = append(predicates, assignmentsubmission.SubmittedAtGT(*i.SubmittedAtGT))
	}
	if i.SubmittedAtGTE != nil {
		predicates = append(predicates, assignmentsubmission.SubmittedAtGTE(*i.SubmittedAtGTE))
	}
	if i.SubmittedAtLT != nil {
		predicates = append(predicates, assignmentsubmission.SubmittedAtLT(*i.SubmittedAtLT))
	}
	if i.SubmittedAtLTE != nil {
		predicates = append(predicates, assignmentsubmission.SubmittedAtLTE(*i.SubmittedAtLTE))
	}
	if i.SubmittedAtIsNil {
		predicates = append(predicates, assignmentsubmission.SubmittedAtIsNil())
	}
	if i.SubmittedAtNotNil {
		predicates = append(predicates, assignmentsubmission.SubmittedAtNotNil())
	}

	if i.HasStudent != nil {
		p := assignmentsubmission.HasStudent()
		if !*i.HasStudent {
			p = assignmentsubmission.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasStudentWith) > 0 {
		with := make([]predicate.User, 0, len(i.HasStudentWith))
		for _, w := range i.HasStudentWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, assignmentsubmission.HasStudentWith(with...))
	}
	if i.HasAssignment != nil {
		p := assignmentsubmission.HasAssignment()
		if !*i.HasAssignment {
			p = assignmentsubmission.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasAssignmentWith) > 0 {
		with := make([]predicate.Assignment, 0, len(i.HasAssignmentWith))
		for _, w := range i.HasAssignmentWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, assignmentsubmission.HasAssignmentWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, fmt.Errorf("github.com/msal4/hassah_school_server/ent: empty predicate AssignmentSubmissionWhereInput")
	case 1:
		return predicates[0], nil
	default:
		return assignmentsubmission.And(predicates...), nil
	}
}

// AttendanceWhereInput represents a where input for filtering Attendance queries.
type AttendanceWhereInput struct {
	Not *AttendanceWhereInput   `json:"not,omitempty"`
	Or  []*AttendanceWhereInput `json:"or,omitempty"`
	And []*AttendanceWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *uuid.UUID  `json:"id,omitempty"`
	IDNEQ   *uuid.UUID  `json:"idNEQ,omitempty"`
	IDIn    []uuid.UUID `json:"idIn,omitempty"`
	IDNotIn []uuid.UUID `json:"idNotIn,omitempty"`
	IDGT    *uuid.UUID  `json:"idGT,omitempty"`
	IDGTE   *uuid.UUID  `json:"idGTE,omitempty"`
	IDLT    *uuid.UUID  `json:"idLT,omitempty"`
	IDLTE   *uuid.UUID  `json:"idLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt      *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedAtLTE,omitempty"`

	// "date" field predicates.
	Date      *time.Time  `json:"date,omitempty"`
	DateNEQ   *time.Time  `json:"dateNEQ,omitempty"`
	DateIn    []time.Time `json:"dateIn,omitempty"`
	DateNotIn []time.Time `json:"dateNotIn,omitempty"`
	DateGT    *time.Time  `json:"dateGT,omitempty"`
	DateGTE   *time.Time  `json:"dateGTE,omitempty"`
	DateLT    *time.Time  `json:"dateLT,omitempty"`
	DateLTE   *time.Time  `json:"dateLTE,omitempty"`

	// "state" field predicates.
	State      *attendance.State  `json:"state,omitempty"`
	StateNEQ   *attendance.State  `json:"stateNEQ,omitempty"`
	StateIn    []attendance.State `json:"stateIn,omitempty"`
	StateNotIn []attendance.State `json:"stateNotIn,omitempty"`

	// "class" edge predicates.
	HasClass     *bool              `json:"hasClass,omitempty"`
	HasClassWith []*ClassWhereInput `json:"hasClassWith,omitempty"`

	// "student" edge predicates.
	HasStudent     *bool             `json:"hasStudent,omitempty"`
	HasStudentWith []*UserWhereInput `json:"hasStudentWith,omitempty"`
}

// Filter applies the AttendanceWhereInput filter on the AttendanceQuery builder.
func (i *AttendanceWhereInput) Filter(q *AttendanceQuery) (*AttendanceQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		return nil, err
	}
	return q.Where(p), nil
}

// P returns a predicate for filtering attendances.
// An error is returned if the input is empty or invalid.
func (i *AttendanceWhereInput) P() (predicate.Attendance, error) {
	var predicates []predicate.Attendance
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, attendance.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Attendance, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			or = append(or, p)
		}
		predicates = append(predicates, attendance.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Attendance, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			and = append(and, p)
		}
		predicates = append(predicates, attendance.And(and...))
	}
	if i.ID != nil {
		predicates = append(predicates, attendance.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, attendance.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, attendance.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, attendance.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, attendance.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, attendance.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, attendance.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, attendance.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, attendance.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, attendance.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, attendance.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, attendance.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, attendance.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, attendance.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, attendance.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, attendance.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, attendance.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, attendance.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, attendance.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, attendance.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, attendance.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, attendance.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, attendance.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, attendance.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.Date != nil {
		predicates = append(predicates, attendance.DateEQ(*i.Date))
	}
	if i.DateNEQ != nil {
		predicates = append(predicates, attendance.DateNEQ(*i.DateNEQ))
	}
	if len(i.DateIn) > 0 {
		predicates = append(predicates, attendance.DateIn(i.DateIn...))
	}
	if len(i.DateNotIn) > 0 {
		predicates = append(predicates, attendance.DateNotIn(i.DateNotIn...))
	}
	if i.DateGT != nil {
		predicates = append(predicates, attendance.DateGT(*i.DateGT))
	}
	if i.DateGTE != nil {
		predicates = append(predicates, attendance.DateGTE(*i.DateGTE))
	}
	if i.DateLT != nil {
		predicates = append(predicates, attendance.DateLT(*i.DateLT))
	}
	if i.DateLTE != nil {
		predicates = append(predicates, attendance.DateLTE(*i.DateLTE))
	}
	if i.State != nil {
		predicates = append(predicates, attendance.StateEQ(*i.State))
	}
	if i.StateNEQ != nil {
		predicates = append(predicates, attendance.StateNEQ(*i.StateNEQ))
	}
	if len(i.StateIn) > 0 {
		predicates = append(predicates, attendance.StateIn(i.StateIn...))
	}
	if len(i.StateNotIn) > 0 {
		predicates = append(predicates, attendance.StateNotIn(i.StateNotIn...))
	}

	if i.HasClass != nil {
		p := attendance.HasClass()
		if !*i.HasClass {
			p = attendance.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasClassWith) > 0 {
		with := make([]predicate.Class, 0, len(i.HasClassWith))
		for _, w := range i.HasClassWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, attendance.HasClassWith(with...))
	}
	if i.HasStudent != nil {
		p := attendance.HasStudent()
		if !*i.HasStudent {
			p = attendance.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasStudentWith) > 0 {
		with := make([]predicate.User, 0, len(i.HasStudentWith))
		for _, w := range i.HasStudentWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, attendance.HasStudentWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, fmt.Errorf("github.com/msal4/hassah_school_server/ent: empty predicate AttendanceWhereInput")
	case 1:
		return predicates[0], nil
	default:
		return attendance.And(predicates...), nil
	}
}

// ClassWhereInput represents a where input for filtering Class queries.
type ClassWhereInput struct {
	Not *ClassWhereInput   `json:"not,omitempty"`
	Or  []*ClassWhereInput `json:"or,omitempty"`
	And []*ClassWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *uuid.UUID  `json:"id,omitempty"`
	IDNEQ   *uuid.UUID  `json:"idNEQ,omitempty"`
	IDIn    []uuid.UUID `json:"idIn,omitempty"`
	IDNotIn []uuid.UUID `json:"idNotIn,omitempty"`
	IDGT    *uuid.UUID  `json:"idGT,omitempty"`
	IDGTE   *uuid.UUID  `json:"idGTE,omitempty"`
	IDLT    *uuid.UUID  `json:"idLT,omitempty"`
	IDLTE   *uuid.UUID  `json:"idLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt      *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedAtLTE,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "active" field predicates.
	Active    *bool `json:"active,omitempty"`
	ActiveNEQ *bool `json:"activeNEQ,omitempty"`

	// "deleted_at" field predicates.
	DeletedAt       *time.Time  `json:"deletedAt,omitempty"`
	DeletedAtNEQ    *time.Time  `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGT     *time.Time  `json:"deletedAtGT,omitempty"`
	DeletedAtGTE    *time.Time  `json:"deletedAtGTE,omitempty"`
	DeletedAtLT     *time.Time  `json:"deletedAtLT,omitempty"`
	DeletedAtLTE    *time.Time  `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil bool        `json:"deletedAtNotNil,omitempty"`

	// "stage" edge predicates.
	HasStage     *bool              `json:"hasStage,omitempty"`
	HasStageWith []*StageWhereInput `json:"hasStageWith,omitempty"`

	// "teacher" edge predicates.
	HasTeacher     *bool             `json:"hasTeacher,omitempty"`
	HasTeacherWith []*UserWhereInput `json:"hasTeacherWith,omitempty"`

	// "group" edge predicates.
	HasGroup     *bool              `json:"hasGroup,omitempty"`
	HasGroupWith []*GroupWhereInput `json:"hasGroupWith,omitempty"`

	// "assignments" edge predicates.
	HasAssignments     *bool                   `json:"hasAssignments,omitempty"`
	HasAssignmentsWith []*AssignmentWhereInput `json:"hasAssignmentsWith,omitempty"`

	// "attendances" edge predicates.
	HasAttendances     *bool                   `json:"hasAttendances,omitempty"`
	HasAttendancesWith []*AttendanceWhereInput `json:"hasAttendancesWith,omitempty"`

	// "schedules" edge predicates.
	HasSchedules     *bool                 `json:"hasSchedules,omitempty"`
	HasSchedulesWith []*ScheduleWhereInput `json:"hasSchedulesWith,omitempty"`

	// "course_grades" edge predicates.
	HasCourseGrades     *bool                    `json:"hasCourseGrades,omitempty"`
	HasCourseGradesWith []*CourseGradeWhereInput `json:"hasCourseGradesWith,omitempty"`
}

// Filter applies the ClassWhereInput filter on the ClassQuery builder.
func (i *ClassWhereInput) Filter(q *ClassQuery) (*ClassQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		return nil, err
	}
	return q.Where(p), nil
}

// P returns a predicate for filtering classes.
// An error is returned if the input is empty or invalid.
func (i *ClassWhereInput) P() (predicate.Class, error) {
	var predicates []predicate.Class
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, class.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Class, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			or = append(or, p)
		}
		predicates = append(predicates, class.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Class, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			and = append(and, p)
		}
		predicates = append(predicates, class.And(and...))
	}
	if i.ID != nil {
		predicates = append(predicates, class.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, class.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, class.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, class.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, class.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, class.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, class.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, class.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, class.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, class.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, class.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, class.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, class.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, class.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, class.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, class.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, class.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, class.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, class.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, class.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, class.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, class.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, class.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, class.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.Name != nil {
		predicates = append(predicates, class.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, class.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, class.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, class.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, class.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, class.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, class.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, class.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, class.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, class.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, class.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, class.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, class.NameContainsFold(*i.NameContainsFold))
	}
	if i.Active != nil {
		predicates = append(predicates, class.ActiveEQ(*i.Active))
	}
	if i.ActiveNEQ != nil {
		predicates = append(predicates, class.ActiveNEQ(*i.ActiveNEQ))
	}
	if i.DeletedAt != nil {
		predicates = append(predicates, class.DeletedAtEQ(*i.DeletedAt))
	}
	if i.DeletedAtNEQ != nil {
		predicates = append(predicates, class.DeletedAtNEQ(*i.DeletedAtNEQ))
	}
	if len(i.DeletedAtIn) > 0 {
		predicates = append(predicates, class.DeletedAtIn(i.DeletedAtIn...))
	}
	if len(i.DeletedAtNotIn) > 0 {
		predicates = append(predicates, class.DeletedAtNotIn(i.DeletedAtNotIn...))
	}
	if i.DeletedAtGT != nil {
		predicates = append(predicates, class.DeletedAtGT(*i.DeletedAtGT))
	}
	if i.DeletedAtGTE != nil {
		predicates = append(predicates, class.DeletedAtGTE(*i.DeletedAtGTE))
	}
	if i.DeletedAtLT != nil {
		predicates = append(predicates, class.DeletedAtLT(*i.DeletedAtLT))
	}
	if i.DeletedAtLTE != nil {
		predicates = append(predicates, class.DeletedAtLTE(*i.DeletedAtLTE))
	}
	if i.DeletedAtIsNil {
		predicates = append(predicates, class.DeletedAtIsNil())
	}
	if i.DeletedAtNotNil {
		predicates = append(predicates, class.DeletedAtNotNil())
	}

	if i.HasStage != nil {
		p := class.HasStage()
		if !*i.HasStage {
			p = class.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasStageWith) > 0 {
		with := make([]predicate.Stage, 0, len(i.HasStageWith))
		for _, w := range i.HasStageWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, class.HasStageWith(with...))
	}
	if i.HasTeacher != nil {
		p := class.HasTeacher()
		if !*i.HasTeacher {
			p = class.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasTeacherWith) > 0 {
		with := make([]predicate.User, 0, len(i.HasTeacherWith))
		for _, w := range i.HasTeacherWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, class.HasTeacherWith(with...))
	}
	if i.HasGroup != nil {
		p := class.HasGroup()
		if !*i.HasGroup {
			p = class.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasGroupWith) > 0 {
		with := make([]predicate.Group, 0, len(i.HasGroupWith))
		for _, w := range i.HasGroupWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, class.HasGroupWith(with...))
	}
	if i.HasAssignments != nil {
		p := class.HasAssignments()
		if !*i.HasAssignments {
			p = class.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasAssignmentsWith) > 0 {
		with := make([]predicate.Assignment, 0, len(i.HasAssignmentsWith))
		for _, w := range i.HasAssignmentsWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, class.HasAssignmentsWith(with...))
	}
	if i.HasAttendances != nil {
		p := class.HasAttendances()
		if !*i.HasAttendances {
			p = class.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasAttendancesWith) > 0 {
		with := make([]predicate.Attendance, 0, len(i.HasAttendancesWith))
		for _, w := range i.HasAttendancesWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, class.HasAttendancesWith(with...))
	}
	if i.HasSchedules != nil {
		p := class.HasSchedules()
		if !*i.HasSchedules {
			p = class.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasSchedulesWith) > 0 {
		with := make([]predicate.Schedule, 0, len(i.HasSchedulesWith))
		for _, w := range i.HasSchedulesWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, class.HasSchedulesWith(with...))
	}
	if i.HasCourseGrades != nil {
		p := class.HasCourseGrades()
		if !*i.HasCourseGrades {
			p = class.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCourseGradesWith) > 0 {
		with := make([]predicate.CourseGrade, 0, len(i.HasCourseGradesWith))
		for _, w := range i.HasCourseGradesWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, class.HasCourseGradesWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, fmt.Errorf("github.com/msal4/hassah_school_server/ent: empty predicate ClassWhereInput")
	case 1:
		return predicates[0], nil
	default:
		return class.And(predicates...), nil
	}
}

// CourseGradeWhereInput represents a where input for filtering CourseGrade queries.
type CourseGradeWhereInput struct {
	Not *CourseGradeWhereInput   `json:"not,omitempty"`
	Or  []*CourseGradeWhereInput `json:"or,omitempty"`
	And []*CourseGradeWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *uuid.UUID  `json:"id,omitempty"`
	IDNEQ   *uuid.UUID  `json:"idNEQ,omitempty"`
	IDIn    []uuid.UUID `json:"idIn,omitempty"`
	IDNotIn []uuid.UUID `json:"idNotIn,omitempty"`
	IDGT    *uuid.UUID  `json:"idGT,omitempty"`
	IDGTE   *uuid.UUID  `json:"idGTE,omitempty"`
	IDLT    *uuid.UUID  `json:"idLT,omitempty"`
	IDLTE   *uuid.UUID  `json:"idLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt      *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedAtLTE,omitempty"`

	// "activity_first" field predicates.
	ActivityFirst       *int  `json:"activityFirst,omitempty"`
	ActivityFirstNEQ    *int  `json:"activityFirstNEQ,omitempty"`
	ActivityFirstIn     []int `json:"activityFirstIn,omitempty"`
	ActivityFirstNotIn  []int `json:"activityFirstNotIn,omitempty"`
	ActivityFirstGT     *int  `json:"activityFirstGT,omitempty"`
	ActivityFirstGTE    *int  `json:"activityFirstGTE,omitempty"`
	ActivityFirstLT     *int  `json:"activityFirstLT,omitempty"`
	ActivityFirstLTE    *int  `json:"activityFirstLTE,omitempty"`
	ActivityFirstIsNil  bool  `json:"activityFirstIsNil,omitempty"`
	ActivityFirstNotNil bool  `json:"activityFirstNotNil,omitempty"`

	// "activity_second" field predicates.
	ActivitySecond       *int  `json:"activitySecond,omitempty"`
	ActivitySecondNEQ    *int  `json:"activitySecondNEQ,omitempty"`
	ActivitySecondIn     []int `json:"activitySecondIn,omitempty"`
	ActivitySecondNotIn  []int `json:"activitySecondNotIn,omitempty"`
	ActivitySecondGT     *int  `json:"activitySecondGT,omitempty"`
	ActivitySecondGTE    *int  `json:"activitySecondGTE,omitempty"`
	ActivitySecondLT     *int  `json:"activitySecondLT,omitempty"`
	ActivitySecondLTE    *int  `json:"activitySecondLTE,omitempty"`
	ActivitySecondIsNil  bool  `json:"activitySecondIsNil,omitempty"`
	ActivitySecondNotNil bool  `json:"activitySecondNotNil,omitempty"`

	// "written_first" field predicates.
	WrittenFirst      *int  `json:"writtenFirst,omitempty"`
	WrittenFirstNEQ   *int  `json:"writtenFirstNEQ,omitempty"`
	WrittenFirstIn    []int `json:"writtenFirstIn,omitempty"`
	WrittenFirstNotIn []int `json:"writtenFirstNotIn,omitempty"`
	WrittenFirstGT    *int  `json:"writtenFirstGT,omitempty"`
	WrittenFirstGTE   *int  `json:"writtenFirstGTE,omitempty"`
	WrittenFirstLT    *int  `json:"writtenFirstLT,omitempty"`
	WrittenFirstLTE   *int  `json:"writtenFirstLTE,omitempty"`

	// "written_second" field predicates.
	WrittenSecond      *int  `json:"writtenSecond,omitempty"`
	WrittenSecondNEQ   *int  `json:"writtenSecondNEQ,omitempty"`
	WrittenSecondIn    []int `json:"writtenSecondIn,omitempty"`
	WrittenSecondNotIn []int `json:"writtenSecondNotIn,omitempty"`
	WrittenSecondGT    *int  `json:"writtenSecondGT,omitempty"`
	WrittenSecondGTE   *int  `json:"writtenSecondGTE,omitempty"`
	WrittenSecondLT    *int  `json:"writtenSecondLT,omitempty"`
	WrittenSecondLTE   *int  `json:"writtenSecondLTE,omitempty"`

	// "course_final" field predicates.
	CourseFinal      *int  `json:"courseFinal,omitempty"`
	CourseFinalNEQ   *int  `json:"courseFinalNEQ,omitempty"`
	CourseFinalIn    []int `json:"courseFinalIn,omitempty"`
	CourseFinalNotIn []int `json:"courseFinalNotIn,omitempty"`
	CourseFinalGT    *int  `json:"courseFinalGT,omitempty"`
	CourseFinalGTE   *int  `json:"courseFinalGTE,omitempty"`
	CourseFinalLT    *int  `json:"courseFinalLT,omitempty"`
	CourseFinalLTE   *int  `json:"courseFinalLTE,omitempty"`

	// "student" edge predicates.
	HasStudent     *bool             `json:"hasStudent,omitempty"`
	HasStudentWith []*UserWhereInput `json:"hasStudentWith,omitempty"`

	// "class" edge predicates.
	HasClass     *bool              `json:"hasClass,omitempty"`
	HasClassWith []*ClassWhereInput `json:"hasClassWith,omitempty"`

	// "stage" edge predicates.
	HasStage     *bool              `json:"hasStage,omitempty"`
	HasStageWith []*StageWhereInput `json:"hasStageWith,omitempty"`
}

// Filter applies the CourseGradeWhereInput filter on the CourseGradeQuery builder.
func (i *CourseGradeWhereInput) Filter(q *CourseGradeQuery) (*CourseGradeQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		return nil, err
	}
	return q.Where(p), nil
}

// P returns a predicate for filtering coursegrades.
// An error is returned if the input is empty or invalid.
func (i *CourseGradeWhereInput) P() (predicate.CourseGrade, error) {
	var predicates []predicate.CourseGrade
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, coursegrade.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.CourseGrade, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			or = append(or, p)
		}
		predicates = append(predicates, coursegrade.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.CourseGrade, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			and = append(and, p)
		}
		predicates = append(predicates, coursegrade.And(and...))
	}
	if i.ID != nil {
		predicates = append(predicates, coursegrade.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, coursegrade.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, coursegrade.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, coursegrade.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, coursegrade.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, coursegrade.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, coursegrade.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, coursegrade.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, coursegrade.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, coursegrade.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, coursegrade.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, coursegrade.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, coursegrade.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, coursegrade.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, coursegrade.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, coursegrade.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, coursegrade.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, coursegrade.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, coursegrade.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, coursegrade.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, coursegrade.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, coursegrade.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, coursegrade.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, coursegrade.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.ActivityFirst != nil {
		predicates = append(predicates, coursegrade.ActivityFirstEQ(*i.ActivityFirst))
	}
	if i.ActivityFirstNEQ != nil {
		predicates = append(predicates, coursegrade.ActivityFirstNEQ(*i.ActivityFirstNEQ))
	}
	if len(i.ActivityFirstIn) > 0 {
		predicates = append(predicates, coursegrade.ActivityFirstIn(i.ActivityFirstIn...))
	}
	if len(i.ActivityFirstNotIn) > 0 {
		predicates = append(predicates, coursegrade.ActivityFirstNotIn(i.ActivityFirstNotIn...))
	}
	if i.ActivityFirstGT != nil {
		predicates = append(predicates, coursegrade.ActivityFirstGT(*i.ActivityFirstGT))
	}
	if i.ActivityFirstGTE != nil {
		predicates = append(predicates, coursegrade.ActivityFirstGTE(*i.ActivityFirstGTE))
	}
	if i.ActivityFirstLT != nil {
		predicates = append(predicates, coursegrade.ActivityFirstLT(*i.ActivityFirstLT))
	}
	if i.ActivityFirstLTE != nil {
		predicates = append(predicates, coursegrade.ActivityFirstLTE(*i.ActivityFirstLTE))
	}
	if i.ActivityFirstIsNil {
		predicates = append(predicates, coursegrade.ActivityFirstIsNil())
	}
	if i.ActivityFirstNotNil {
		predicates = append(predicates, coursegrade.ActivityFirstNotNil())
	}
	if i.ActivitySecond != nil {
		predicates = append(predicates, coursegrade.ActivitySecondEQ(*i.ActivitySecond))
	}
	if i.ActivitySecondNEQ != nil {
		predicates = append(predicates, coursegrade.ActivitySecondNEQ(*i.ActivitySecondNEQ))
	}
	if len(i.ActivitySecondIn) > 0 {
		predicates = append(predicates, coursegrade.ActivitySecondIn(i.ActivitySecondIn...))
	}
	if len(i.ActivitySecondNotIn) > 0 {
		predicates = append(predicates, coursegrade.ActivitySecondNotIn(i.ActivitySecondNotIn...))
	}
	if i.ActivitySecondGT != nil {
		predicates = append(predicates, coursegrade.ActivitySecondGT(*i.ActivitySecondGT))
	}
	if i.ActivitySecondGTE != nil {
		predicates = append(predicates, coursegrade.ActivitySecondGTE(*i.ActivitySecondGTE))
	}
	if i.ActivitySecondLT != nil {
		predicates = append(predicates, coursegrade.ActivitySecondLT(*i.ActivitySecondLT))
	}
	if i.ActivitySecondLTE != nil {
		predicates = append(predicates, coursegrade.ActivitySecondLTE(*i.ActivitySecondLTE))
	}
	if i.ActivitySecondIsNil {
		predicates = append(predicates, coursegrade.ActivitySecondIsNil())
	}
	if i.ActivitySecondNotNil {
		predicates = append(predicates, coursegrade.ActivitySecondNotNil())
	}
	if i.WrittenFirst != nil {
		predicates = append(predicates, coursegrade.WrittenFirstEQ(*i.WrittenFirst))
	}
	if i.WrittenFirstNEQ != nil {
		predicates = append(predicates, coursegrade.WrittenFirstNEQ(*i.WrittenFirstNEQ))
	}
	if len(i.WrittenFirstIn) > 0 {
		predicates = append(predicates, coursegrade.WrittenFirstIn(i.WrittenFirstIn...))
	}
	if len(i.WrittenFirstNotIn) > 0 {
		predicates = append(predicates, coursegrade.WrittenFirstNotIn(i.WrittenFirstNotIn...))
	}
	if i.WrittenFirstGT != nil {
		predicates = append(predicates, coursegrade.WrittenFirstGT(*i.WrittenFirstGT))
	}
	if i.WrittenFirstGTE != nil {
		predicates = append(predicates, coursegrade.WrittenFirstGTE(*i.WrittenFirstGTE))
	}
	if i.WrittenFirstLT != nil {
		predicates = append(predicates, coursegrade.WrittenFirstLT(*i.WrittenFirstLT))
	}
	if i.WrittenFirstLTE != nil {
		predicates = append(predicates, coursegrade.WrittenFirstLTE(*i.WrittenFirstLTE))
	}
	if i.WrittenSecond != nil {
		predicates = append(predicates, coursegrade.WrittenSecondEQ(*i.WrittenSecond))
	}
	if i.WrittenSecondNEQ != nil {
		predicates = append(predicates, coursegrade.WrittenSecondNEQ(*i.WrittenSecondNEQ))
	}
	if len(i.WrittenSecondIn) > 0 {
		predicates = append(predicates, coursegrade.WrittenSecondIn(i.WrittenSecondIn...))
	}
	if len(i.WrittenSecondNotIn) > 0 {
		predicates = append(predicates, coursegrade.WrittenSecondNotIn(i.WrittenSecondNotIn...))
	}
	if i.WrittenSecondGT != nil {
		predicates = append(predicates, coursegrade.WrittenSecondGT(*i.WrittenSecondGT))
	}
	if i.WrittenSecondGTE != nil {
		predicates = append(predicates, coursegrade.WrittenSecondGTE(*i.WrittenSecondGTE))
	}
	if i.WrittenSecondLT != nil {
		predicates = append(predicates, coursegrade.WrittenSecondLT(*i.WrittenSecondLT))
	}
	if i.WrittenSecondLTE != nil {
		predicates = append(predicates, coursegrade.WrittenSecondLTE(*i.WrittenSecondLTE))
	}
	if i.CourseFinal != nil {
		predicates = append(predicates, coursegrade.CourseFinalEQ(*i.CourseFinal))
	}
	if i.CourseFinalNEQ != nil {
		predicates = append(predicates, coursegrade.CourseFinalNEQ(*i.CourseFinalNEQ))
	}
	if len(i.CourseFinalIn) > 0 {
		predicates = append(predicates, coursegrade.CourseFinalIn(i.CourseFinalIn...))
	}
	if len(i.CourseFinalNotIn) > 0 {
		predicates = append(predicates, coursegrade.CourseFinalNotIn(i.CourseFinalNotIn...))
	}
	if i.CourseFinalGT != nil {
		predicates = append(predicates, coursegrade.CourseFinalGT(*i.CourseFinalGT))
	}
	if i.CourseFinalGTE != nil {
		predicates = append(predicates, coursegrade.CourseFinalGTE(*i.CourseFinalGTE))
	}
	if i.CourseFinalLT != nil {
		predicates = append(predicates, coursegrade.CourseFinalLT(*i.CourseFinalLT))
	}
	if i.CourseFinalLTE != nil {
		predicates = append(predicates, coursegrade.CourseFinalLTE(*i.CourseFinalLTE))
	}

	if i.HasStudent != nil {
		p := coursegrade.HasStudent()
		if !*i.HasStudent {
			p = coursegrade.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasStudentWith) > 0 {
		with := make([]predicate.User, 0, len(i.HasStudentWith))
		for _, w := range i.HasStudentWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, coursegrade.HasStudentWith(with...))
	}
	if i.HasClass != nil {
		p := coursegrade.HasClass()
		if !*i.HasClass {
			p = coursegrade.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasClassWith) > 0 {
		with := make([]predicate.Class, 0, len(i.HasClassWith))
		for _, w := range i.HasClassWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, coursegrade.HasClassWith(with...))
	}
	if i.HasStage != nil {
		p := coursegrade.HasStage()
		if !*i.HasStage {
			p = coursegrade.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasStageWith) > 0 {
		with := make([]predicate.Stage, 0, len(i.HasStageWith))
		for _, w := range i.HasStageWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, coursegrade.HasStageWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, fmt.Errorf("github.com/msal4/hassah_school_server/ent: empty predicate CourseGradeWhereInput")
	case 1:
		return predicates[0], nil
	default:
		return coursegrade.And(predicates...), nil
	}
}

// GradeWhereInput represents a where input for filtering Grade queries.
type GradeWhereInput struct {
	Not *GradeWhereInput   `json:"not,omitempty"`
	Or  []*GradeWhereInput `json:"or,omitempty"`
	And []*GradeWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *uuid.UUID  `json:"id,omitempty"`
	IDNEQ   *uuid.UUID  `json:"idNEQ,omitempty"`
	IDIn    []uuid.UUID `json:"idIn,omitempty"`
	IDNotIn []uuid.UUID `json:"idNotIn,omitempty"`
	IDGT    *uuid.UUID  `json:"idGT,omitempty"`
	IDGTE   *uuid.UUID  `json:"idGTE,omitempty"`
	IDLT    *uuid.UUID  `json:"idLT,omitempty"`
	IDLTE   *uuid.UUID  `json:"idLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt      *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedAtLTE,omitempty"`

	// "exam_grade" field predicates.
	ExamGrade      *int  `json:"examGrade,omitempty"`
	ExamGradeNEQ   *int  `json:"examGradeNEQ,omitempty"`
	ExamGradeIn    []int `json:"examGradeIn,omitempty"`
	ExamGradeNotIn []int `json:"examGradeNotIn,omitempty"`
	ExamGradeGT    *int  `json:"examGradeGT,omitempty"`
	ExamGradeGTE   *int  `json:"examGradeGTE,omitempty"`
	ExamGradeLT    *int  `json:"examGradeLT,omitempty"`
	ExamGradeLTE   *int  `json:"examGradeLTE,omitempty"`

	// "student" edge predicates.
	HasStudent     *bool             `json:"hasStudent,omitempty"`
	HasStudentWith []*UserWhereInput `json:"hasStudentWith,omitempty"`

	// "exam" edge predicates.
	HasExam     *bool                   `json:"hasExam,omitempty"`
	HasExamWith []*AssignmentWhereInput `json:"hasExamWith,omitempty"`
}

// Filter applies the GradeWhereInput filter on the GradeQuery builder.
func (i *GradeWhereInput) Filter(q *GradeQuery) (*GradeQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		return nil, err
	}
	return q.Where(p), nil
}

// P returns a predicate for filtering grades.
// An error is returned if the input is empty or invalid.
func (i *GradeWhereInput) P() (predicate.Grade, error) {
	var predicates []predicate.Grade
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, grade.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Grade, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			or = append(or, p)
		}
		predicates = append(predicates, grade.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Grade, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			and = append(and, p)
		}
		predicates = append(predicates, grade.And(and...))
	}
	if i.ID != nil {
		predicates = append(predicates, grade.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, grade.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, grade.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, grade.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, grade.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, grade.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, grade.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, grade.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, grade.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, grade.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, grade.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, grade.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, grade.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, grade.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, grade.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, grade.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, grade.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, grade.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, grade.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, grade.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, grade.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, grade.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, grade.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, grade.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.ExamGrade != nil {
		predicates = append(predicates, grade.ExamGradeEQ(*i.ExamGrade))
	}
	if i.ExamGradeNEQ != nil {
		predicates = append(predicates, grade.ExamGradeNEQ(*i.ExamGradeNEQ))
	}
	if len(i.ExamGradeIn) > 0 {
		predicates = append(predicates, grade.ExamGradeIn(i.ExamGradeIn...))
	}
	if len(i.ExamGradeNotIn) > 0 {
		predicates = append(predicates, grade.ExamGradeNotIn(i.ExamGradeNotIn...))
	}
	if i.ExamGradeGT != nil {
		predicates = append(predicates, grade.ExamGradeGT(*i.ExamGradeGT))
	}
	if i.ExamGradeGTE != nil {
		predicates = append(predicates, grade.ExamGradeGTE(*i.ExamGradeGTE))
	}
	if i.ExamGradeLT != nil {
		predicates = append(predicates, grade.ExamGradeLT(*i.ExamGradeLT))
	}
	if i.ExamGradeLTE != nil {
		predicates = append(predicates, grade.ExamGradeLTE(*i.ExamGradeLTE))
	}

	if i.HasStudent != nil {
		p := grade.HasStudent()
		if !*i.HasStudent {
			p = grade.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasStudentWith) > 0 {
		with := make([]predicate.User, 0, len(i.HasStudentWith))
		for _, w := range i.HasStudentWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, grade.HasStudentWith(with...))
	}
	if i.HasExam != nil {
		p := grade.HasExam()
		if !*i.HasExam {
			p = grade.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasExamWith) > 0 {
		with := make([]predicate.Assignment, 0, len(i.HasExamWith))
		for _, w := range i.HasExamWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, grade.HasExamWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, fmt.Errorf("github.com/msal4/hassah_school_server/ent: empty predicate GradeWhereInput")
	case 1:
		return predicates[0], nil
	default:
		return grade.And(predicates...), nil
	}
}

// GroupWhereInput represents a where input for filtering Group queries.
type GroupWhereInput struct {
	Not *GroupWhereInput   `json:"not,omitempty"`
	Or  []*GroupWhereInput `json:"or,omitempty"`
	And []*GroupWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *uuid.UUID  `json:"id,omitempty"`
	IDNEQ   *uuid.UUID  `json:"idNEQ,omitempty"`
	IDIn    []uuid.UUID `json:"idIn,omitempty"`
	IDNotIn []uuid.UUID `json:"idNotIn,omitempty"`
	IDGT    *uuid.UUID  `json:"idGT,omitempty"`
	IDGTE   *uuid.UUID  `json:"idGTE,omitempty"`
	IDLT    *uuid.UUID  `json:"idLT,omitempty"`
	IDLTE   *uuid.UUID  `json:"idLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt      *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedAtLTE,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameIsNil        bool     `json:"nameIsNil,omitempty"`
	NameNotNil       bool     `json:"nameNotNil,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "group_type" field predicates.
	GroupType      *group.GroupType  `json:"groupType,omitempty"`
	GroupTypeNEQ   *group.GroupType  `json:"groupTypeNEQ,omitempty"`
	GroupTypeIn    []group.GroupType `json:"groupTypeIn,omitempty"`
	GroupTypeNotIn []group.GroupType `json:"groupTypeNotIn,omitempty"`

	// "active" field predicates.
	Active    *bool `json:"active,omitempty"`
	ActiveNEQ *bool `json:"activeNEQ,omitempty"`

	// "deleted_at" field predicates.
	DeletedAt       *time.Time  `json:"deletedAt,omitempty"`
	DeletedAtNEQ    *time.Time  `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGT     *time.Time  `json:"deletedAtGT,omitempty"`
	DeletedAtGTE    *time.Time  `json:"deletedAtGTE,omitempty"`
	DeletedAtLT     *time.Time  `json:"deletedAtLT,omitempty"`
	DeletedAtLTE    *time.Time  `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil bool        `json:"deletedAtNotNil,omitempty"`

	// "class" edge predicates.
	HasClass     *bool              `json:"hasClass,omitempty"`
	HasClassWith []*ClassWhereInput `json:"hasClassWith,omitempty"`

	// "users" edge predicates.
	HasUsers     *bool             `json:"hasUsers,omitempty"`
	HasUsersWith []*UserWhereInput `json:"hasUsersWith,omitempty"`

	// "messages" edge predicates.
	HasMessages     *bool                `json:"hasMessages,omitempty"`
	HasMessagesWith []*MessageWhereInput `json:"hasMessagesWith,omitempty"`
}

// Filter applies the GroupWhereInput filter on the GroupQuery builder.
func (i *GroupWhereInput) Filter(q *GroupQuery) (*GroupQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		return nil, err
	}
	return q.Where(p), nil
}

// P returns a predicate for filtering groups.
// An error is returned if the input is empty or invalid.
func (i *GroupWhereInput) P() (predicate.Group, error) {
	var predicates []predicate.Group
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, group.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Group, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			or = append(or, p)
		}
		predicates = append(predicates, group.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Group, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			and = append(and, p)
		}
		predicates = append(predicates, group.And(and...))
	}
	if i.ID != nil {
		predicates = append(predicates, group.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, group.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, group.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, group.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, group.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, group.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, group.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, group.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, group.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, group.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, group.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, group.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, group.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, group.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, group.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, group.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, group.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, group.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, group.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, group.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, group.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, group.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, group.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, group.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.Name != nil {
		predicates = append(predicates, group.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, group.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, group.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, group.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, group.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, group.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, group.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, group.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, group.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, group.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, group.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameIsNil {
		predicates = append(predicates, group.NameIsNil())
	}
	if i.NameNotNil {
		predicates = append(predicates, group.NameNotNil())
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, group.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, group.NameContainsFold(*i.NameContainsFold))
	}
	if i.GroupType != nil {
		predicates = append(predicates, group.GroupTypeEQ(*i.GroupType))
	}
	if i.GroupTypeNEQ != nil {
		predicates = append(predicates, group.GroupTypeNEQ(*i.GroupTypeNEQ))
	}
	if len(i.GroupTypeIn) > 0 {
		predicates = append(predicates, group.GroupTypeIn(i.GroupTypeIn...))
	}
	if len(i.GroupTypeNotIn) > 0 {
		predicates = append(predicates, group.GroupTypeNotIn(i.GroupTypeNotIn...))
	}
	if i.Active != nil {
		predicates = append(predicates, group.ActiveEQ(*i.Active))
	}
	if i.ActiveNEQ != nil {
		predicates = append(predicates, group.ActiveNEQ(*i.ActiveNEQ))
	}
	if i.DeletedAt != nil {
		predicates = append(predicates, group.DeletedAtEQ(*i.DeletedAt))
	}
	if i.DeletedAtNEQ != nil {
		predicates = append(predicates, group.DeletedAtNEQ(*i.DeletedAtNEQ))
	}
	if len(i.DeletedAtIn) > 0 {
		predicates = append(predicates, group.DeletedAtIn(i.DeletedAtIn...))
	}
	if len(i.DeletedAtNotIn) > 0 {
		predicates = append(predicates, group.DeletedAtNotIn(i.DeletedAtNotIn...))
	}
	if i.DeletedAtGT != nil {
		predicates = append(predicates, group.DeletedAtGT(*i.DeletedAtGT))
	}
	if i.DeletedAtGTE != nil {
		predicates = append(predicates, group.DeletedAtGTE(*i.DeletedAtGTE))
	}
	if i.DeletedAtLT != nil {
		predicates = append(predicates, group.DeletedAtLT(*i.DeletedAtLT))
	}
	if i.DeletedAtLTE != nil {
		predicates = append(predicates, group.DeletedAtLTE(*i.DeletedAtLTE))
	}
	if i.DeletedAtIsNil {
		predicates = append(predicates, group.DeletedAtIsNil())
	}
	if i.DeletedAtNotNil {
		predicates = append(predicates, group.DeletedAtNotNil())
	}

	if i.HasClass != nil {
		p := group.HasClass()
		if !*i.HasClass {
			p = group.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasClassWith) > 0 {
		with := make([]predicate.Class, 0, len(i.HasClassWith))
		for _, w := range i.HasClassWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, group.HasClassWith(with...))
	}
	if i.HasUsers != nil {
		p := group.HasUsers()
		if !*i.HasUsers {
			p = group.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasUsersWith) > 0 {
		with := make([]predicate.User, 0, len(i.HasUsersWith))
		for _, w := range i.HasUsersWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, group.HasUsersWith(with...))
	}
	if i.HasMessages != nil {
		p := group.HasMessages()
		if !*i.HasMessages {
			p = group.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasMessagesWith) > 0 {
		with := make([]predicate.Message, 0, len(i.HasMessagesWith))
		for _, w := range i.HasMessagesWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, group.HasMessagesWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, fmt.Errorf("github.com/msal4/hassah_school_server/ent: empty predicate GroupWhereInput")
	case 1:
		return predicates[0], nil
	default:
		return group.And(predicates...), nil
	}
}

// MessageWhereInput represents a where input for filtering Message queries.
type MessageWhereInput struct {
	Not *MessageWhereInput   `json:"not,omitempty"`
	Or  []*MessageWhereInput `json:"or,omitempty"`
	And []*MessageWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *uuid.UUID  `json:"id,omitempty"`
	IDNEQ   *uuid.UUID  `json:"idNEQ,omitempty"`
	IDIn    []uuid.UUID `json:"idIn,omitempty"`
	IDNotIn []uuid.UUID `json:"idNotIn,omitempty"`
	IDGT    *uuid.UUID  `json:"idGT,omitempty"`
	IDGTE   *uuid.UUID  `json:"idGTE,omitempty"`
	IDLT    *uuid.UUID  `json:"idLT,omitempty"`
	IDLTE   *uuid.UUID  `json:"idLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt      *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedAtLTE,omitempty"`

	// "content" field predicates.
	Content             *string  `json:"content,omitempty"`
	ContentNEQ          *string  `json:"contentNEQ,omitempty"`
	ContentIn           []string `json:"contentIn,omitempty"`
	ContentNotIn        []string `json:"contentNotIn,omitempty"`
	ContentGT           *string  `json:"contentGT,omitempty"`
	ContentGTE          *string  `json:"contentGTE,omitempty"`
	ContentLT           *string  `json:"contentLT,omitempty"`
	ContentLTE          *string  `json:"contentLTE,omitempty"`
	ContentContains     *string  `json:"contentContains,omitempty"`
	ContentHasPrefix    *string  `json:"contentHasPrefix,omitempty"`
	ContentHasSuffix    *string  `json:"contentHasSuffix,omitempty"`
	ContentIsNil        bool     `json:"contentIsNil,omitempty"`
	ContentNotNil       bool     `json:"contentNotNil,omitempty"`
	ContentEqualFold    *string  `json:"contentEqualFold,omitempty"`
	ContentContainsFold *string  `json:"contentContainsFold,omitempty"`

	// "attachment" field predicates.
	Attachment             *string  `json:"attachment,omitempty"`
	AttachmentNEQ          *string  `json:"attachmentNEQ,omitempty"`
	AttachmentIn           []string `json:"attachmentIn,omitempty"`
	AttachmentNotIn        []string `json:"attachmentNotIn,omitempty"`
	AttachmentGT           *string  `json:"attachmentGT,omitempty"`
	AttachmentGTE          *string  `json:"attachmentGTE,omitempty"`
	AttachmentLT           *string  `json:"attachmentLT,omitempty"`
	AttachmentLTE          *string  `json:"attachmentLTE,omitempty"`
	AttachmentContains     *string  `json:"attachmentContains,omitempty"`
	AttachmentHasPrefix    *string  `json:"attachmentHasPrefix,omitempty"`
	AttachmentHasSuffix    *string  `json:"attachmentHasSuffix,omitempty"`
	AttachmentIsNil        bool     `json:"attachmentIsNil,omitempty"`
	AttachmentNotNil       bool     `json:"attachmentNotNil,omitempty"`
	AttachmentEqualFold    *string  `json:"attachmentEqualFold,omitempty"`
	AttachmentContainsFold *string  `json:"attachmentContainsFold,omitempty"`

	// "deleted_at" field predicates.
	DeletedAt       *time.Time  `json:"deletedAt,omitempty"`
	DeletedAtNEQ    *time.Time  `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGT     *time.Time  `json:"deletedAtGT,omitempty"`
	DeletedAtGTE    *time.Time  `json:"deletedAtGTE,omitempty"`
	DeletedAtLT     *time.Time  `json:"deletedAtLT,omitempty"`
	DeletedAtLTE    *time.Time  `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil bool        `json:"deletedAtNotNil,omitempty"`

	// "group" edge predicates.
	HasGroup     *bool              `json:"hasGroup,omitempty"`
	HasGroupWith []*GroupWhereInput `json:"hasGroupWith,omitempty"`

	// "owner" edge predicates.
	HasOwner     *bool             `json:"hasOwner,omitempty"`
	HasOwnerWith []*UserWhereInput `json:"hasOwnerWith,omitempty"`
}

// Filter applies the MessageWhereInput filter on the MessageQuery builder.
func (i *MessageWhereInput) Filter(q *MessageQuery) (*MessageQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		return nil, err
	}
	return q.Where(p), nil
}

// P returns a predicate for filtering messages.
// An error is returned if the input is empty or invalid.
func (i *MessageWhereInput) P() (predicate.Message, error) {
	var predicates []predicate.Message
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, message.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Message, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			or = append(or, p)
		}
		predicates = append(predicates, message.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Message, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			and = append(and, p)
		}
		predicates = append(predicates, message.And(and...))
	}
	if i.ID != nil {
		predicates = append(predicates, message.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, message.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, message.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, message.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, message.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, message.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, message.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, message.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, message.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, message.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, message.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, message.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, message.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, message.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, message.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, message.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, message.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, message.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, message.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, message.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, message.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, message.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, message.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, message.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.Content != nil {
		predicates = append(predicates, message.ContentEQ(*i.Content))
	}
	if i.ContentNEQ != nil {
		predicates = append(predicates, message.ContentNEQ(*i.ContentNEQ))
	}
	if len(i.ContentIn) > 0 {
		predicates = append(predicates, message.ContentIn(i.ContentIn...))
	}
	if len(i.ContentNotIn) > 0 {
		predicates = append(predicates, message.ContentNotIn(i.ContentNotIn...))
	}
	if i.ContentGT != nil {
		predicates = append(predicates, message.ContentGT(*i.ContentGT))
	}
	if i.ContentGTE != nil {
		predicates = append(predicates, message.ContentGTE(*i.ContentGTE))
	}
	if i.ContentLT != nil {
		predicates = append(predicates, message.ContentLT(*i.ContentLT))
	}
	if i.ContentLTE != nil {
		predicates = append(predicates, message.ContentLTE(*i.ContentLTE))
	}
	if i.ContentContains != nil {
		predicates = append(predicates, message.ContentContains(*i.ContentContains))
	}
	if i.ContentHasPrefix != nil {
		predicates = append(predicates, message.ContentHasPrefix(*i.ContentHasPrefix))
	}
	if i.ContentHasSuffix != nil {
		predicates = append(predicates, message.ContentHasSuffix(*i.ContentHasSuffix))
	}
	if i.ContentIsNil {
		predicates = append(predicates, message.ContentIsNil())
	}
	if i.ContentNotNil {
		predicates = append(predicates, message.ContentNotNil())
	}
	if i.ContentEqualFold != nil {
		predicates = append(predicates, message.ContentEqualFold(*i.ContentEqualFold))
	}
	if i.ContentContainsFold != nil {
		predicates = append(predicates, message.ContentContainsFold(*i.ContentContainsFold))
	}
	if i.Attachment != nil {
		predicates = append(predicates, message.AttachmentEQ(*i.Attachment))
	}
	if i.AttachmentNEQ != nil {
		predicates = append(predicates, message.AttachmentNEQ(*i.AttachmentNEQ))
	}
	if len(i.AttachmentIn) > 0 {
		predicates = append(predicates, message.AttachmentIn(i.AttachmentIn...))
	}
	if len(i.AttachmentNotIn) > 0 {
		predicates = append(predicates, message.AttachmentNotIn(i.AttachmentNotIn...))
	}
	if i.AttachmentGT != nil {
		predicates = append(predicates, message.AttachmentGT(*i.AttachmentGT))
	}
	if i.AttachmentGTE != nil {
		predicates = append(predicates, message.AttachmentGTE(*i.AttachmentGTE))
	}
	if i.AttachmentLT != nil {
		predicates = append(predicates, message.AttachmentLT(*i.AttachmentLT))
	}
	if i.AttachmentLTE != nil {
		predicates = append(predicates, message.AttachmentLTE(*i.AttachmentLTE))
	}
	if i.AttachmentContains != nil {
		predicates = append(predicates, message.AttachmentContains(*i.AttachmentContains))
	}
	if i.AttachmentHasPrefix != nil {
		predicates = append(predicates, message.AttachmentHasPrefix(*i.AttachmentHasPrefix))
	}
	if i.AttachmentHasSuffix != nil {
		predicates = append(predicates, message.AttachmentHasSuffix(*i.AttachmentHasSuffix))
	}
	if i.AttachmentIsNil {
		predicates = append(predicates, message.AttachmentIsNil())
	}
	if i.AttachmentNotNil {
		predicates = append(predicates, message.AttachmentNotNil())
	}
	if i.AttachmentEqualFold != nil {
		predicates = append(predicates, message.AttachmentEqualFold(*i.AttachmentEqualFold))
	}
	if i.AttachmentContainsFold != nil {
		predicates = append(predicates, message.AttachmentContainsFold(*i.AttachmentContainsFold))
	}
	if i.DeletedAt != nil {
		predicates = append(predicates, message.DeletedAtEQ(*i.DeletedAt))
	}
	if i.DeletedAtNEQ != nil {
		predicates = append(predicates, message.DeletedAtNEQ(*i.DeletedAtNEQ))
	}
	if len(i.DeletedAtIn) > 0 {
		predicates = append(predicates, message.DeletedAtIn(i.DeletedAtIn...))
	}
	if len(i.DeletedAtNotIn) > 0 {
		predicates = append(predicates, message.DeletedAtNotIn(i.DeletedAtNotIn...))
	}
	if i.DeletedAtGT != nil {
		predicates = append(predicates, message.DeletedAtGT(*i.DeletedAtGT))
	}
	if i.DeletedAtGTE != nil {
		predicates = append(predicates, message.DeletedAtGTE(*i.DeletedAtGTE))
	}
	if i.DeletedAtLT != nil {
		predicates = append(predicates, message.DeletedAtLT(*i.DeletedAtLT))
	}
	if i.DeletedAtLTE != nil {
		predicates = append(predicates, message.DeletedAtLTE(*i.DeletedAtLTE))
	}
	if i.DeletedAtIsNil {
		predicates = append(predicates, message.DeletedAtIsNil())
	}
	if i.DeletedAtNotNil {
		predicates = append(predicates, message.DeletedAtNotNil())
	}

	if i.HasGroup != nil {
		p := message.HasGroup()
		if !*i.HasGroup {
			p = message.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasGroupWith) > 0 {
		with := make([]predicate.Group, 0, len(i.HasGroupWith))
		for _, w := range i.HasGroupWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, message.HasGroupWith(with...))
	}
	if i.HasOwner != nil {
		p := message.HasOwner()
		if !*i.HasOwner {
			p = message.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasOwnerWith) > 0 {
		with := make([]predicate.User, 0, len(i.HasOwnerWith))
		for _, w := range i.HasOwnerWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, message.HasOwnerWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, fmt.Errorf("github.com/msal4/hassah_school_server/ent: empty predicate MessageWhereInput")
	case 1:
		return predicates[0], nil
	default:
		return message.And(predicates...), nil
	}
}

// ScheduleWhereInput represents a where input for filtering Schedule queries.
type ScheduleWhereInput struct {
	Not *ScheduleWhereInput   `json:"not,omitempty"`
	Or  []*ScheduleWhereInput `json:"or,omitempty"`
	And []*ScheduleWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *uuid.UUID  `json:"id,omitempty"`
	IDNEQ   *uuid.UUID  `json:"idNEQ,omitempty"`
	IDIn    []uuid.UUID `json:"idIn,omitempty"`
	IDNotIn []uuid.UUID `json:"idNotIn,omitempty"`
	IDGT    *uuid.UUID  `json:"idGT,omitempty"`
	IDGTE   *uuid.UUID  `json:"idGTE,omitempty"`
	IDLT    *uuid.UUID  `json:"idLT,omitempty"`
	IDLTE   *uuid.UUID  `json:"idLTE,omitempty"`

	// "weekday" field predicates.
	Weekday      *time.Weekday  `json:"weekday,omitempty"`
	WeekdayNEQ   *time.Weekday  `json:"weekdayNEQ,omitempty"`
	WeekdayIn    []time.Weekday `json:"weekdayIn,omitempty"`
	WeekdayNotIn []time.Weekday `json:"weekdayNotIn,omitempty"`
	WeekdayGT    *time.Weekday  `json:"weekdayGT,omitempty"`
	WeekdayGTE   *time.Weekday  `json:"weekdayGTE,omitempty"`
	WeekdayLT    *time.Weekday  `json:"weekdayLT,omitempty"`
	WeekdayLTE   *time.Weekday  `json:"weekdayLTE,omitempty"`

	// "starts_at" field predicates.
	StartsAt      *time.Time  `json:"startsAt,omitempty"`
	StartsAtNEQ   *time.Time  `json:"startsAtNEQ,omitempty"`
	StartsAtIn    []time.Time `json:"startsAtIn,omitempty"`
	StartsAtNotIn []time.Time `json:"startsAtNotIn,omitempty"`
	StartsAtGT    *time.Time  `json:"startsAtGT,omitempty"`
	StartsAtGTE   *time.Time  `json:"startsAtGTE,omitempty"`
	StartsAtLT    *time.Time  `json:"startsAtLT,omitempty"`
	StartsAtLTE   *time.Time  `json:"startsAtLTE,omitempty"`

	// "duration" field predicates.
	Duration      *time.Duration  `json:"duration,omitempty"`
	DurationNEQ   *time.Duration  `json:"durationNEQ,omitempty"`
	DurationIn    []time.Duration `json:"durationIn,omitempty"`
	DurationNotIn []time.Duration `json:"durationNotIn,omitempty"`
	DurationGT    *time.Duration  `json:"durationGT,omitempty"`
	DurationGTE   *time.Duration  `json:"durationGTE,omitempty"`
	DurationLT    *time.Duration  `json:"durationLT,omitempty"`
	DurationLTE   *time.Duration  `json:"durationLTE,omitempty"`

	// "class" edge predicates.
	HasClass     *bool              `json:"hasClass,omitempty"`
	HasClassWith []*ClassWhereInput `json:"hasClassWith,omitempty"`
}

// Filter applies the ScheduleWhereInput filter on the ScheduleQuery builder.
func (i *ScheduleWhereInput) Filter(q *ScheduleQuery) (*ScheduleQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		return nil, err
	}
	return q.Where(p), nil
}

// P returns a predicate for filtering schedules.
// An error is returned if the input is empty or invalid.
func (i *ScheduleWhereInput) P() (predicate.Schedule, error) {
	var predicates []predicate.Schedule
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, schedule.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Schedule, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			or = append(or, p)
		}
		predicates = append(predicates, schedule.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Schedule, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			and = append(and, p)
		}
		predicates = append(predicates, schedule.And(and...))
	}
	if i.ID != nil {
		predicates = append(predicates, schedule.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, schedule.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, schedule.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, schedule.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, schedule.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, schedule.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, schedule.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, schedule.IDLTE(*i.IDLTE))
	}
	if i.Weekday != nil {
		predicates = append(predicates, schedule.WeekdayEQ(*i.Weekday))
	}
	if i.WeekdayNEQ != nil {
		predicates = append(predicates, schedule.WeekdayNEQ(*i.WeekdayNEQ))
	}
	if len(i.WeekdayIn) > 0 {
		predicates = append(predicates, schedule.WeekdayIn(i.WeekdayIn...))
	}
	if len(i.WeekdayNotIn) > 0 {
		predicates = append(predicates, schedule.WeekdayNotIn(i.WeekdayNotIn...))
	}
	if i.WeekdayGT != nil {
		predicates = append(predicates, schedule.WeekdayGT(*i.WeekdayGT))
	}
	if i.WeekdayGTE != nil {
		predicates = append(predicates, schedule.WeekdayGTE(*i.WeekdayGTE))
	}
	if i.WeekdayLT != nil {
		predicates = append(predicates, schedule.WeekdayLT(*i.WeekdayLT))
	}
	if i.WeekdayLTE != nil {
		predicates = append(predicates, schedule.WeekdayLTE(*i.WeekdayLTE))
	}
	if i.StartsAt != nil {
		predicates = append(predicates, schedule.StartsAtEQ(*i.StartsAt))
	}
	if i.StartsAtNEQ != nil {
		predicates = append(predicates, schedule.StartsAtNEQ(*i.StartsAtNEQ))
	}
	if len(i.StartsAtIn) > 0 {
		predicates = append(predicates, schedule.StartsAtIn(i.StartsAtIn...))
	}
	if len(i.StartsAtNotIn) > 0 {
		predicates = append(predicates, schedule.StartsAtNotIn(i.StartsAtNotIn...))
	}
	if i.StartsAtGT != nil {
		predicates = append(predicates, schedule.StartsAtGT(*i.StartsAtGT))
	}
	if i.StartsAtGTE != nil {
		predicates = append(predicates, schedule.StartsAtGTE(*i.StartsAtGTE))
	}
	if i.StartsAtLT != nil {
		predicates = append(predicates, schedule.StartsAtLT(*i.StartsAtLT))
	}
	if i.StartsAtLTE != nil {
		predicates = append(predicates, schedule.StartsAtLTE(*i.StartsAtLTE))
	}
	if i.Duration != nil {
		predicates = append(predicates, schedule.DurationEQ(*i.Duration))
	}
	if i.DurationNEQ != nil {
		predicates = append(predicates, schedule.DurationNEQ(*i.DurationNEQ))
	}
	if len(i.DurationIn) > 0 {
		predicates = append(predicates, schedule.DurationIn(i.DurationIn...))
	}
	if len(i.DurationNotIn) > 0 {
		predicates = append(predicates, schedule.DurationNotIn(i.DurationNotIn...))
	}
	if i.DurationGT != nil {
		predicates = append(predicates, schedule.DurationGT(*i.DurationGT))
	}
	if i.DurationGTE != nil {
		predicates = append(predicates, schedule.DurationGTE(*i.DurationGTE))
	}
	if i.DurationLT != nil {
		predicates = append(predicates, schedule.DurationLT(*i.DurationLT))
	}
	if i.DurationLTE != nil {
		predicates = append(predicates, schedule.DurationLTE(*i.DurationLTE))
	}

	if i.HasClass != nil {
		p := schedule.HasClass()
		if !*i.HasClass {
			p = schedule.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasClassWith) > 0 {
		with := make([]predicate.Class, 0, len(i.HasClassWith))
		for _, w := range i.HasClassWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, schedule.HasClassWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, fmt.Errorf("github.com/msal4/hassah_school_server/ent: empty predicate ScheduleWhereInput")
	case 1:
		return predicates[0], nil
	default:
		return schedule.And(predicates...), nil
	}
}

// SchoolWhereInput represents a where input for filtering School queries.
type SchoolWhereInput struct {
	Not *SchoolWhereInput   `json:"not,omitempty"`
	Or  []*SchoolWhereInput `json:"or,omitempty"`
	And []*SchoolWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *uuid.UUID  `json:"id,omitempty"`
	IDNEQ   *uuid.UUID  `json:"idNEQ,omitempty"`
	IDIn    []uuid.UUID `json:"idIn,omitempty"`
	IDNotIn []uuid.UUID `json:"idNotIn,omitempty"`
	IDGT    *uuid.UUID  `json:"idGT,omitempty"`
	IDGTE   *uuid.UUID  `json:"idGTE,omitempty"`
	IDLT    *uuid.UUID  `json:"idLT,omitempty"`
	IDLTE   *uuid.UUID  `json:"idLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt      *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedAtLTE,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "image" field predicates.
	Image             *string  `json:"image,omitempty"`
	ImageNEQ          *string  `json:"imageNEQ,omitempty"`
	ImageIn           []string `json:"imageIn,omitempty"`
	ImageNotIn        []string `json:"imageNotIn,omitempty"`
	ImageGT           *string  `json:"imageGT,omitempty"`
	ImageGTE          *string  `json:"imageGTE,omitempty"`
	ImageLT           *string  `json:"imageLT,omitempty"`
	ImageLTE          *string  `json:"imageLTE,omitempty"`
	ImageContains     *string  `json:"imageContains,omitempty"`
	ImageHasPrefix    *string  `json:"imageHasPrefix,omitempty"`
	ImageHasSuffix    *string  `json:"imageHasSuffix,omitempty"`
	ImageEqualFold    *string  `json:"imageEqualFold,omitempty"`
	ImageContainsFold *string  `json:"imageContainsFold,omitempty"`

	// "directory" field predicates.
	Directory             *string  `json:"directory,omitempty"`
	DirectoryNEQ          *string  `json:"directoryNEQ,omitempty"`
	DirectoryIn           []string `json:"directoryIn,omitempty"`
	DirectoryNotIn        []string `json:"directoryNotIn,omitempty"`
	DirectoryGT           *string  `json:"directoryGT,omitempty"`
	DirectoryGTE          *string  `json:"directoryGTE,omitempty"`
	DirectoryLT           *string  `json:"directoryLT,omitempty"`
	DirectoryLTE          *string  `json:"directoryLTE,omitempty"`
	DirectoryContains     *string  `json:"directoryContains,omitempty"`
	DirectoryHasPrefix    *string  `json:"directoryHasPrefix,omitempty"`
	DirectoryHasSuffix    *string  `json:"directoryHasSuffix,omitempty"`
	DirectoryEqualFold    *string  `json:"directoryEqualFold,omitempty"`
	DirectoryContainsFold *string  `json:"directoryContainsFold,omitempty"`

	// "active" field predicates.
	Active    *bool `json:"active,omitempty"`
	ActiveNEQ *bool `json:"activeNEQ,omitempty"`

	// "deleted_at" field predicates.
	DeletedAt       *time.Time  `json:"deletedAt,omitempty"`
	DeletedAtNEQ    *time.Time  `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGT     *time.Time  `json:"deletedAtGT,omitempty"`
	DeletedAtGTE    *time.Time  `json:"deletedAtGTE,omitempty"`
	DeletedAtLT     *time.Time  `json:"deletedAtLT,omitempty"`
	DeletedAtLTE    *time.Time  `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil bool        `json:"deletedAtNotNil,omitempty"`

	// "users" edge predicates.
	HasUsers     *bool             `json:"hasUsers,omitempty"`
	HasUsersWith []*UserWhereInput `json:"hasUsersWith,omitempty"`

	// "stages" edge predicates.
	HasStages     *bool              `json:"hasStages,omitempty"`
	HasStagesWith []*StageWhereInput `json:"hasStagesWith,omitempty"`
}

// Filter applies the SchoolWhereInput filter on the SchoolQuery builder.
func (i *SchoolWhereInput) Filter(q *SchoolQuery) (*SchoolQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		return nil, err
	}
	return q.Where(p), nil
}

// P returns a predicate for filtering schools.
// An error is returned if the input is empty or invalid.
func (i *SchoolWhereInput) P() (predicate.School, error) {
	var predicates []predicate.School
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, school.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.School, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			or = append(or, p)
		}
		predicates = append(predicates, school.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.School, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			and = append(and, p)
		}
		predicates = append(predicates, school.And(and...))
	}
	if i.ID != nil {
		predicates = append(predicates, school.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, school.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, school.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, school.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, school.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, school.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, school.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, school.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, school.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, school.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, school.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, school.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, school.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, school.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, school.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, school.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, school.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, school.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, school.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, school.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, school.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, school.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, school.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, school.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.Name != nil {
		predicates = append(predicates, school.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, school.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, school.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, school.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, school.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, school.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, school.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, school.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, school.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, school.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, school.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, school.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, school.NameContainsFold(*i.NameContainsFold))
	}
	if i.Image != nil {
		predicates = append(predicates, school.ImageEQ(*i.Image))
	}
	if i.ImageNEQ != nil {
		predicates = append(predicates, school.ImageNEQ(*i.ImageNEQ))
	}
	if len(i.ImageIn) > 0 {
		predicates = append(predicates, school.ImageIn(i.ImageIn...))
	}
	if len(i.ImageNotIn) > 0 {
		predicates = append(predicates, school.ImageNotIn(i.ImageNotIn...))
	}
	if i.ImageGT != nil {
		predicates = append(predicates, school.ImageGT(*i.ImageGT))
	}
	if i.ImageGTE != nil {
		predicates = append(predicates, school.ImageGTE(*i.ImageGTE))
	}
	if i.ImageLT != nil {
		predicates = append(predicates, school.ImageLT(*i.ImageLT))
	}
	if i.ImageLTE != nil {
		predicates = append(predicates, school.ImageLTE(*i.ImageLTE))
	}
	if i.ImageContains != nil {
		predicates = append(predicates, school.ImageContains(*i.ImageContains))
	}
	if i.ImageHasPrefix != nil {
		predicates = append(predicates, school.ImageHasPrefix(*i.ImageHasPrefix))
	}
	if i.ImageHasSuffix != nil {
		predicates = append(predicates, school.ImageHasSuffix(*i.ImageHasSuffix))
	}
	if i.ImageEqualFold != nil {
		predicates = append(predicates, school.ImageEqualFold(*i.ImageEqualFold))
	}
	if i.ImageContainsFold != nil {
		predicates = append(predicates, school.ImageContainsFold(*i.ImageContainsFold))
	}
	if i.Directory != nil {
		predicates = append(predicates, school.DirectoryEQ(*i.Directory))
	}
	if i.DirectoryNEQ != nil {
		predicates = append(predicates, school.DirectoryNEQ(*i.DirectoryNEQ))
	}
	if len(i.DirectoryIn) > 0 {
		predicates = append(predicates, school.DirectoryIn(i.DirectoryIn...))
	}
	if len(i.DirectoryNotIn) > 0 {
		predicates = append(predicates, school.DirectoryNotIn(i.DirectoryNotIn...))
	}
	if i.DirectoryGT != nil {
		predicates = append(predicates, school.DirectoryGT(*i.DirectoryGT))
	}
	if i.DirectoryGTE != nil {
		predicates = append(predicates, school.DirectoryGTE(*i.DirectoryGTE))
	}
	if i.DirectoryLT != nil {
		predicates = append(predicates, school.DirectoryLT(*i.DirectoryLT))
	}
	if i.DirectoryLTE != nil {
		predicates = append(predicates, school.DirectoryLTE(*i.DirectoryLTE))
	}
	if i.DirectoryContains != nil {
		predicates = append(predicates, school.DirectoryContains(*i.DirectoryContains))
	}
	if i.DirectoryHasPrefix != nil {
		predicates = append(predicates, school.DirectoryHasPrefix(*i.DirectoryHasPrefix))
	}
	if i.DirectoryHasSuffix != nil {
		predicates = append(predicates, school.DirectoryHasSuffix(*i.DirectoryHasSuffix))
	}
	if i.DirectoryEqualFold != nil {
		predicates = append(predicates, school.DirectoryEqualFold(*i.DirectoryEqualFold))
	}
	if i.DirectoryContainsFold != nil {
		predicates = append(predicates, school.DirectoryContainsFold(*i.DirectoryContainsFold))
	}
	if i.Active != nil {
		predicates = append(predicates, school.ActiveEQ(*i.Active))
	}
	if i.ActiveNEQ != nil {
		predicates = append(predicates, school.ActiveNEQ(*i.ActiveNEQ))
	}
	if i.DeletedAt != nil {
		predicates = append(predicates, school.DeletedAtEQ(*i.DeletedAt))
	}
	if i.DeletedAtNEQ != nil {
		predicates = append(predicates, school.DeletedAtNEQ(*i.DeletedAtNEQ))
	}
	if len(i.DeletedAtIn) > 0 {
		predicates = append(predicates, school.DeletedAtIn(i.DeletedAtIn...))
	}
	if len(i.DeletedAtNotIn) > 0 {
		predicates = append(predicates, school.DeletedAtNotIn(i.DeletedAtNotIn...))
	}
	if i.DeletedAtGT != nil {
		predicates = append(predicates, school.DeletedAtGT(*i.DeletedAtGT))
	}
	if i.DeletedAtGTE != nil {
		predicates = append(predicates, school.DeletedAtGTE(*i.DeletedAtGTE))
	}
	if i.DeletedAtLT != nil {
		predicates = append(predicates, school.DeletedAtLT(*i.DeletedAtLT))
	}
	if i.DeletedAtLTE != nil {
		predicates = append(predicates, school.DeletedAtLTE(*i.DeletedAtLTE))
	}
	if i.DeletedAtIsNil {
		predicates = append(predicates, school.DeletedAtIsNil())
	}
	if i.DeletedAtNotNil {
		predicates = append(predicates, school.DeletedAtNotNil())
	}

	if i.HasUsers != nil {
		p := school.HasUsers()
		if !*i.HasUsers {
			p = school.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasUsersWith) > 0 {
		with := make([]predicate.User, 0, len(i.HasUsersWith))
		for _, w := range i.HasUsersWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, school.HasUsersWith(with...))
	}
	if i.HasStages != nil {
		p := school.HasStages()
		if !*i.HasStages {
			p = school.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasStagesWith) > 0 {
		with := make([]predicate.Stage, 0, len(i.HasStagesWith))
		for _, w := range i.HasStagesWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, school.HasStagesWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, fmt.Errorf("github.com/msal4/hassah_school_server/ent: empty predicate SchoolWhereInput")
	case 1:
		return predicates[0], nil
	default:
		return school.And(predicates...), nil
	}
}

// StageWhereInput represents a where input for filtering Stage queries.
type StageWhereInput struct {
	Not *StageWhereInput   `json:"not,omitempty"`
	Or  []*StageWhereInput `json:"or,omitempty"`
	And []*StageWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *uuid.UUID  `json:"id,omitempty"`
	IDNEQ   *uuid.UUID  `json:"idNEQ,omitempty"`
	IDIn    []uuid.UUID `json:"idIn,omitempty"`
	IDNotIn []uuid.UUID `json:"idNotIn,omitempty"`
	IDGT    *uuid.UUID  `json:"idGT,omitempty"`
	IDGTE   *uuid.UUID  `json:"idGTE,omitempty"`
	IDLT    *uuid.UUID  `json:"idLT,omitempty"`
	IDLTE   *uuid.UUID  `json:"idLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt      *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedAtLTE,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "tuition_amount" field predicates.
	TuitionAmount      *int  `json:"tuitionAmount,omitempty"`
	TuitionAmountNEQ   *int  `json:"tuitionAmountNEQ,omitempty"`
	TuitionAmountIn    []int `json:"tuitionAmountIn,omitempty"`
	TuitionAmountNotIn []int `json:"tuitionAmountNotIn,omitempty"`
	TuitionAmountGT    *int  `json:"tuitionAmountGT,omitempty"`
	TuitionAmountGTE   *int  `json:"tuitionAmountGTE,omitempty"`
	TuitionAmountLT    *int  `json:"tuitionAmountLT,omitempty"`
	TuitionAmountLTE   *int  `json:"tuitionAmountLTE,omitempty"`

	// "directory" field predicates.
	Directory             *string  `json:"directory,omitempty"`
	DirectoryNEQ          *string  `json:"directoryNEQ,omitempty"`
	DirectoryIn           []string `json:"directoryIn,omitempty"`
	DirectoryNotIn        []string `json:"directoryNotIn,omitempty"`
	DirectoryGT           *string  `json:"directoryGT,omitempty"`
	DirectoryGTE          *string  `json:"directoryGTE,omitempty"`
	DirectoryLT           *string  `json:"directoryLT,omitempty"`
	DirectoryLTE          *string  `json:"directoryLTE,omitempty"`
	DirectoryContains     *string  `json:"directoryContains,omitempty"`
	DirectoryHasPrefix    *string  `json:"directoryHasPrefix,omitempty"`
	DirectoryHasSuffix    *string  `json:"directoryHasSuffix,omitempty"`
	DirectoryEqualFold    *string  `json:"directoryEqualFold,omitempty"`
	DirectoryContainsFold *string  `json:"directoryContainsFold,omitempty"`

	// "active" field predicates.
	Active    *bool `json:"active,omitempty"`
	ActiveNEQ *bool `json:"activeNEQ,omitempty"`

	// "deleted_at" field predicates.
	DeletedAt       *time.Time  `json:"deletedAt,omitempty"`
	DeletedAtNEQ    *time.Time  `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGT     *time.Time  `json:"deletedAtGT,omitempty"`
	DeletedAtGTE    *time.Time  `json:"deletedAtGTE,omitempty"`
	DeletedAtLT     *time.Time  `json:"deletedAtLT,omitempty"`
	DeletedAtLTE    *time.Time  `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil bool        `json:"deletedAtNotNil,omitempty"`

	// "school" edge predicates.
	HasSchool     *bool               `json:"hasSchool,omitempty"`
	HasSchoolWith []*SchoolWhereInput `json:"hasSchoolWith,omitempty"`

	// "classes" edge predicates.
	HasClasses     *bool              `json:"hasClasses,omitempty"`
	HasClassesWith []*ClassWhereInput `json:"hasClassesWith,omitempty"`

	// "payments" edge predicates.
	HasPayments     *bool                       `json:"hasPayments,omitempty"`
	HasPaymentsWith []*TuitionPaymentWhereInput `json:"hasPaymentsWith,omitempty"`

	// "students" edge predicates.
	HasStudents     *bool             `json:"hasStudents,omitempty"`
	HasStudentsWith []*UserWhereInput `json:"hasStudentsWith,omitempty"`

	// "course_grades" edge predicates.
	HasCourseGrades     *bool                    `json:"hasCourseGrades,omitempty"`
	HasCourseGradesWith []*CourseGradeWhereInput `json:"hasCourseGradesWith,omitempty"`
}

// Filter applies the StageWhereInput filter on the StageQuery builder.
func (i *StageWhereInput) Filter(q *StageQuery) (*StageQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		return nil, err
	}
	return q.Where(p), nil
}

// P returns a predicate for filtering stages.
// An error is returned if the input is empty or invalid.
func (i *StageWhereInput) P() (predicate.Stage, error) {
	var predicates []predicate.Stage
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, stage.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Stage, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			or = append(or, p)
		}
		predicates = append(predicates, stage.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Stage, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			and = append(and, p)
		}
		predicates = append(predicates, stage.And(and...))
	}
	if i.ID != nil {
		predicates = append(predicates, stage.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, stage.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, stage.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, stage.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, stage.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, stage.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, stage.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, stage.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, stage.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, stage.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, stage.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, stage.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, stage.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, stage.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, stage.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, stage.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, stage.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, stage.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, stage.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, stage.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, stage.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, stage.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, stage.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, stage.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.Name != nil {
		predicates = append(predicates, stage.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, stage.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, stage.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, stage.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, stage.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, stage.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, stage.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, stage.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, stage.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, stage.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, stage.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, stage.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, stage.NameContainsFold(*i.NameContainsFold))
	}
	if i.TuitionAmount != nil {
		predicates = append(predicates, stage.TuitionAmountEQ(*i.TuitionAmount))
	}
	if i.TuitionAmountNEQ != nil {
		predicates = append(predicates, stage.TuitionAmountNEQ(*i.TuitionAmountNEQ))
	}
	if len(i.TuitionAmountIn) > 0 {
		predicates = append(predicates, stage.TuitionAmountIn(i.TuitionAmountIn...))
	}
	if len(i.TuitionAmountNotIn) > 0 {
		predicates = append(predicates, stage.TuitionAmountNotIn(i.TuitionAmountNotIn...))
	}
	if i.TuitionAmountGT != nil {
		predicates = append(predicates, stage.TuitionAmountGT(*i.TuitionAmountGT))
	}
	if i.TuitionAmountGTE != nil {
		predicates = append(predicates, stage.TuitionAmountGTE(*i.TuitionAmountGTE))
	}
	if i.TuitionAmountLT != nil {
		predicates = append(predicates, stage.TuitionAmountLT(*i.TuitionAmountLT))
	}
	if i.TuitionAmountLTE != nil {
		predicates = append(predicates, stage.TuitionAmountLTE(*i.TuitionAmountLTE))
	}
	if i.Directory != nil {
		predicates = append(predicates, stage.DirectoryEQ(*i.Directory))
	}
	if i.DirectoryNEQ != nil {
		predicates = append(predicates, stage.DirectoryNEQ(*i.DirectoryNEQ))
	}
	if len(i.DirectoryIn) > 0 {
		predicates = append(predicates, stage.DirectoryIn(i.DirectoryIn...))
	}
	if len(i.DirectoryNotIn) > 0 {
		predicates = append(predicates, stage.DirectoryNotIn(i.DirectoryNotIn...))
	}
	if i.DirectoryGT != nil {
		predicates = append(predicates, stage.DirectoryGT(*i.DirectoryGT))
	}
	if i.DirectoryGTE != nil {
		predicates = append(predicates, stage.DirectoryGTE(*i.DirectoryGTE))
	}
	if i.DirectoryLT != nil {
		predicates = append(predicates, stage.DirectoryLT(*i.DirectoryLT))
	}
	if i.DirectoryLTE != nil {
		predicates = append(predicates, stage.DirectoryLTE(*i.DirectoryLTE))
	}
	if i.DirectoryContains != nil {
		predicates = append(predicates, stage.DirectoryContains(*i.DirectoryContains))
	}
	if i.DirectoryHasPrefix != nil {
		predicates = append(predicates, stage.DirectoryHasPrefix(*i.DirectoryHasPrefix))
	}
	if i.DirectoryHasSuffix != nil {
		predicates = append(predicates, stage.DirectoryHasSuffix(*i.DirectoryHasSuffix))
	}
	if i.DirectoryEqualFold != nil {
		predicates = append(predicates, stage.DirectoryEqualFold(*i.DirectoryEqualFold))
	}
	if i.DirectoryContainsFold != nil {
		predicates = append(predicates, stage.DirectoryContainsFold(*i.DirectoryContainsFold))
	}
	if i.Active != nil {
		predicates = append(predicates, stage.ActiveEQ(*i.Active))
	}
	if i.ActiveNEQ != nil {
		predicates = append(predicates, stage.ActiveNEQ(*i.ActiveNEQ))
	}
	if i.DeletedAt != nil {
		predicates = append(predicates, stage.DeletedAtEQ(*i.DeletedAt))
	}
	if i.DeletedAtNEQ != nil {
		predicates = append(predicates, stage.DeletedAtNEQ(*i.DeletedAtNEQ))
	}
	if len(i.DeletedAtIn) > 0 {
		predicates = append(predicates, stage.DeletedAtIn(i.DeletedAtIn...))
	}
	if len(i.DeletedAtNotIn) > 0 {
		predicates = append(predicates, stage.DeletedAtNotIn(i.DeletedAtNotIn...))
	}
	if i.DeletedAtGT != nil {
		predicates = append(predicates, stage.DeletedAtGT(*i.DeletedAtGT))
	}
	if i.DeletedAtGTE != nil {
		predicates = append(predicates, stage.DeletedAtGTE(*i.DeletedAtGTE))
	}
	if i.DeletedAtLT != nil {
		predicates = append(predicates, stage.DeletedAtLT(*i.DeletedAtLT))
	}
	if i.DeletedAtLTE != nil {
		predicates = append(predicates, stage.DeletedAtLTE(*i.DeletedAtLTE))
	}
	if i.DeletedAtIsNil {
		predicates = append(predicates, stage.DeletedAtIsNil())
	}
	if i.DeletedAtNotNil {
		predicates = append(predicates, stage.DeletedAtNotNil())
	}

	if i.HasSchool != nil {
		p := stage.HasSchool()
		if !*i.HasSchool {
			p = stage.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasSchoolWith) > 0 {
		with := make([]predicate.School, 0, len(i.HasSchoolWith))
		for _, w := range i.HasSchoolWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, stage.HasSchoolWith(with...))
	}
	if i.HasClasses != nil {
		p := stage.HasClasses()
		if !*i.HasClasses {
			p = stage.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasClassesWith) > 0 {
		with := make([]predicate.Class, 0, len(i.HasClassesWith))
		for _, w := range i.HasClassesWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, stage.HasClassesWith(with...))
	}
	if i.HasPayments != nil {
		p := stage.HasPayments()
		if !*i.HasPayments {
			p = stage.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasPaymentsWith) > 0 {
		with := make([]predicate.TuitionPayment, 0, len(i.HasPaymentsWith))
		for _, w := range i.HasPaymentsWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, stage.HasPaymentsWith(with...))
	}
	if i.HasStudents != nil {
		p := stage.HasStudents()
		if !*i.HasStudents {
			p = stage.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasStudentsWith) > 0 {
		with := make([]predicate.User, 0, len(i.HasStudentsWith))
		for _, w := range i.HasStudentsWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, stage.HasStudentsWith(with...))
	}
	if i.HasCourseGrades != nil {
		p := stage.HasCourseGrades()
		if !*i.HasCourseGrades {
			p = stage.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCourseGradesWith) > 0 {
		with := make([]predicate.CourseGrade, 0, len(i.HasCourseGradesWith))
		for _, w := range i.HasCourseGradesWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, stage.HasCourseGradesWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, fmt.Errorf("github.com/msal4/hassah_school_server/ent: empty predicate StageWhereInput")
	case 1:
		return predicates[0], nil
	default:
		return stage.And(predicates...), nil
	}
}

// TuitionPaymentWhereInput represents a where input for filtering TuitionPayment queries.
type TuitionPaymentWhereInput struct {
	Not *TuitionPaymentWhereInput   `json:"not,omitempty"`
	Or  []*TuitionPaymentWhereInput `json:"or,omitempty"`
	And []*TuitionPaymentWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *uuid.UUID  `json:"id,omitempty"`
	IDNEQ   *uuid.UUID  `json:"idNEQ,omitempty"`
	IDIn    []uuid.UUID `json:"idIn,omitempty"`
	IDNotIn []uuid.UUID `json:"idNotIn,omitempty"`
	IDGT    *uuid.UUID  `json:"idGT,omitempty"`
	IDGTE   *uuid.UUID  `json:"idGTE,omitempty"`
	IDLT    *uuid.UUID  `json:"idLT,omitempty"`
	IDLTE   *uuid.UUID  `json:"idLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt      *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedAtLTE,omitempty"`

	// "paid_amount" field predicates.
	PaidAmount      *int  `json:"paidAmount,omitempty"`
	PaidAmountNEQ   *int  `json:"paidAmountNEQ,omitempty"`
	PaidAmountIn    []int `json:"paidAmountIn,omitempty"`
	PaidAmountNotIn []int `json:"paidAmountNotIn,omitempty"`
	PaidAmountGT    *int  `json:"paidAmountGT,omitempty"`
	PaidAmountGTE   *int  `json:"paidAmountGTE,omitempty"`
	PaidAmountLT    *int  `json:"paidAmountLT,omitempty"`
	PaidAmountLTE   *int  `json:"paidAmountLTE,omitempty"`

	// "student" edge predicates.
	HasStudent     *bool             `json:"hasStudent,omitempty"`
	HasStudentWith []*UserWhereInput `json:"hasStudentWith,omitempty"`

	// "stage" edge predicates.
	HasStage     *bool              `json:"hasStage,omitempty"`
	HasStageWith []*StageWhereInput `json:"hasStageWith,omitempty"`
}

// Filter applies the TuitionPaymentWhereInput filter on the TuitionPaymentQuery builder.
func (i *TuitionPaymentWhereInput) Filter(q *TuitionPaymentQuery) (*TuitionPaymentQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		return nil, err
	}
	return q.Where(p), nil
}

// P returns a predicate for filtering tuitionpayments.
// An error is returned if the input is empty or invalid.
func (i *TuitionPaymentWhereInput) P() (predicate.TuitionPayment, error) {
	var predicates []predicate.TuitionPayment
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, tuitionpayment.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.TuitionPayment, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			or = append(or, p)
		}
		predicates = append(predicates, tuitionpayment.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.TuitionPayment, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			and = append(and, p)
		}
		predicates = append(predicates, tuitionpayment.And(and...))
	}
	if i.ID != nil {
		predicates = append(predicates, tuitionpayment.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, tuitionpayment.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, tuitionpayment.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, tuitionpayment.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, tuitionpayment.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, tuitionpayment.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, tuitionpayment.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, tuitionpayment.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, tuitionpayment.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, tuitionpayment.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, tuitionpayment.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, tuitionpayment.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, tuitionpayment.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, tuitionpayment.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, tuitionpayment.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, tuitionpayment.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, tuitionpayment.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, tuitionpayment.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, tuitionpayment.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, tuitionpayment.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, tuitionpayment.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, tuitionpayment.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, tuitionpayment.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, tuitionpayment.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.PaidAmount != nil {
		predicates = append(predicates, tuitionpayment.PaidAmountEQ(*i.PaidAmount))
	}
	if i.PaidAmountNEQ != nil {
		predicates = append(predicates, tuitionpayment.PaidAmountNEQ(*i.PaidAmountNEQ))
	}
	if len(i.PaidAmountIn) > 0 {
		predicates = append(predicates, tuitionpayment.PaidAmountIn(i.PaidAmountIn...))
	}
	if len(i.PaidAmountNotIn) > 0 {
		predicates = append(predicates, tuitionpayment.PaidAmountNotIn(i.PaidAmountNotIn...))
	}
	if i.PaidAmountGT != nil {
		predicates = append(predicates, tuitionpayment.PaidAmountGT(*i.PaidAmountGT))
	}
	if i.PaidAmountGTE != nil {
		predicates = append(predicates, tuitionpayment.PaidAmountGTE(*i.PaidAmountGTE))
	}
	if i.PaidAmountLT != nil {
		predicates = append(predicates, tuitionpayment.PaidAmountLT(*i.PaidAmountLT))
	}
	if i.PaidAmountLTE != nil {
		predicates = append(predicates, tuitionpayment.PaidAmountLTE(*i.PaidAmountLTE))
	}

	if i.HasStudent != nil {
		p := tuitionpayment.HasStudent()
		if !*i.HasStudent {
			p = tuitionpayment.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasStudentWith) > 0 {
		with := make([]predicate.User, 0, len(i.HasStudentWith))
		for _, w := range i.HasStudentWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, tuitionpayment.HasStudentWith(with...))
	}
	if i.HasStage != nil {
		p := tuitionpayment.HasStage()
		if !*i.HasStage {
			p = tuitionpayment.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasStageWith) > 0 {
		with := make([]predicate.Stage, 0, len(i.HasStageWith))
		for _, w := range i.HasStageWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, tuitionpayment.HasStageWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, fmt.Errorf("github.com/msal4/hassah_school_server/ent: empty predicate TuitionPaymentWhereInput")
	case 1:
		return predicates[0], nil
	default:
		return tuitionpayment.And(predicates...), nil
	}
}

// UserWhereInput represents a where input for filtering User queries.
type UserWhereInput struct {
	Not *UserWhereInput   `json:"not,omitempty"`
	Or  []*UserWhereInput `json:"or,omitempty"`
	And []*UserWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *uuid.UUID  `json:"id,omitempty"`
	IDNEQ   *uuid.UUID  `json:"idNEQ,omitempty"`
	IDIn    []uuid.UUID `json:"idIn,omitempty"`
	IDNotIn []uuid.UUID `json:"idNotIn,omitempty"`
	IDGT    *uuid.UUID  `json:"idGT,omitempty"`
	IDGTE   *uuid.UUID  `json:"idGTE,omitempty"`
	IDLT    *uuid.UUID  `json:"idLT,omitempty"`
	IDLTE   *uuid.UUID  `json:"idLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt      *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedAtLTE,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "username" field predicates.
	Username             *string  `json:"username,omitempty"`
	UsernameNEQ          *string  `json:"usernameNEQ,omitempty"`
	UsernameIn           []string `json:"usernameIn,omitempty"`
	UsernameNotIn        []string `json:"usernameNotIn,omitempty"`
	UsernameGT           *string  `json:"usernameGT,omitempty"`
	UsernameGTE          *string  `json:"usernameGTE,omitempty"`
	UsernameLT           *string  `json:"usernameLT,omitempty"`
	UsernameLTE          *string  `json:"usernameLTE,omitempty"`
	UsernameContains     *string  `json:"usernameContains,omitempty"`
	UsernameHasPrefix    *string  `json:"usernameHasPrefix,omitempty"`
	UsernameHasSuffix    *string  `json:"usernameHasSuffix,omitempty"`
	UsernameEqualFold    *string  `json:"usernameEqualFold,omitempty"`
	UsernameContainsFold *string  `json:"usernameContainsFold,omitempty"`

	// "phone" field predicates.
	Phone             *string  `json:"phone,omitempty"`
	PhoneNEQ          *string  `json:"phoneNEQ,omitempty"`
	PhoneIn           []string `json:"phoneIn,omitempty"`
	PhoneNotIn        []string `json:"phoneNotIn,omitempty"`
	PhoneGT           *string  `json:"phoneGT,omitempty"`
	PhoneGTE          *string  `json:"phoneGTE,omitempty"`
	PhoneLT           *string  `json:"phoneLT,omitempty"`
	PhoneLTE          *string  `json:"phoneLTE,omitempty"`
	PhoneContains     *string  `json:"phoneContains,omitempty"`
	PhoneHasPrefix    *string  `json:"phoneHasPrefix,omitempty"`
	PhoneHasSuffix    *string  `json:"phoneHasSuffix,omitempty"`
	PhoneEqualFold    *string  `json:"phoneEqualFold,omitempty"`
	PhoneContainsFold *string  `json:"phoneContainsFold,omitempty"`

	// "image" field predicates.
	Image             *string  `json:"image,omitempty"`
	ImageNEQ          *string  `json:"imageNEQ,omitempty"`
	ImageIn           []string `json:"imageIn,omitempty"`
	ImageNotIn        []string `json:"imageNotIn,omitempty"`
	ImageGT           *string  `json:"imageGT,omitempty"`
	ImageGTE          *string  `json:"imageGTE,omitempty"`
	ImageLT           *string  `json:"imageLT,omitempty"`
	ImageLTE          *string  `json:"imageLTE,omitempty"`
	ImageContains     *string  `json:"imageContains,omitempty"`
	ImageHasPrefix    *string  `json:"imageHasPrefix,omitempty"`
	ImageHasSuffix    *string  `json:"imageHasSuffix,omitempty"`
	ImageIsNil        bool     `json:"imageIsNil,omitempty"`
	ImageNotNil       bool     `json:"imageNotNil,omitempty"`
	ImageEqualFold    *string  `json:"imageEqualFold,omitempty"`
	ImageContainsFold *string  `json:"imageContainsFold,omitempty"`

	// "directory" field predicates.
	Directory             *string  `json:"directory,omitempty"`
	DirectoryNEQ          *string  `json:"directoryNEQ,omitempty"`
	DirectoryIn           []string `json:"directoryIn,omitempty"`
	DirectoryNotIn        []string `json:"directoryNotIn,omitempty"`
	DirectoryGT           *string  `json:"directoryGT,omitempty"`
	DirectoryGTE          *string  `json:"directoryGTE,omitempty"`
	DirectoryLT           *string  `json:"directoryLT,omitempty"`
	DirectoryLTE          *string  `json:"directoryLTE,omitempty"`
	DirectoryContains     *string  `json:"directoryContains,omitempty"`
	DirectoryHasPrefix    *string  `json:"directoryHasPrefix,omitempty"`
	DirectoryHasSuffix    *string  `json:"directoryHasSuffix,omitempty"`
	DirectoryEqualFold    *string  `json:"directoryEqualFold,omitempty"`
	DirectoryContainsFold *string  `json:"directoryContainsFold,omitempty"`

	// "token_version" field predicates.
	TokenVersion      *int  `json:"tokenVersion,omitempty"`
	TokenVersionNEQ   *int  `json:"tokenVersionNEQ,omitempty"`
	TokenVersionIn    []int `json:"tokenVersionIn,omitempty"`
	TokenVersionNotIn []int `json:"tokenVersionNotIn,omitempty"`
	TokenVersionGT    *int  `json:"tokenVersionGT,omitempty"`
	TokenVersionGTE   *int  `json:"tokenVersionGTE,omitempty"`
	TokenVersionLT    *int  `json:"tokenVersionLT,omitempty"`
	TokenVersionLTE   *int  `json:"tokenVersionLTE,omitempty"`

	// "role" field predicates.
	Role      *user.Role  `json:"role,omitempty"`
	RoleNEQ   *user.Role  `json:"roleNEQ,omitempty"`
	RoleIn    []user.Role `json:"roleIn,omitempty"`
	RoleNotIn []user.Role `json:"roleNotIn,omitempty"`

	// "active" field predicates.
	Active    *bool `json:"active,omitempty"`
	ActiveNEQ *bool `json:"activeNEQ,omitempty"`

	// "deleted_at" field predicates.
	DeletedAt       *time.Time  `json:"deletedAt,omitempty"`
	DeletedAtNEQ    *time.Time  `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGT     *time.Time  `json:"deletedAtGT,omitempty"`
	DeletedAtGTE    *time.Time  `json:"deletedAtGTE,omitempty"`
	DeletedAtLT     *time.Time  `json:"deletedAtLT,omitempty"`
	DeletedAtLTE    *time.Time  `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil bool        `json:"deletedAtNotNil,omitempty"`

	// "stage" edge predicates.
	HasStage     *bool              `json:"hasStage,omitempty"`
	HasStageWith []*StageWhereInput `json:"hasStageWith,omitempty"`

	// "school" edge predicates.
	HasSchool     *bool               `json:"hasSchool,omitempty"`
	HasSchoolWith []*SchoolWhereInput `json:"hasSchoolWith,omitempty"`

	// "classes" edge predicates.
	HasClasses     *bool              `json:"hasClasses,omitempty"`
	HasClassesWith []*ClassWhereInput `json:"hasClassesWith,omitempty"`

	// "messages" edge predicates.
	HasMessages     *bool                `json:"hasMessages,omitempty"`
	HasMessagesWith []*MessageWhereInput `json:"hasMessagesWith,omitempty"`

	// "submissions" edge predicates.
	HasSubmissions     *bool                             `json:"hasSubmissions,omitempty"`
	HasSubmissionsWith []*AssignmentSubmissionWhereInput `json:"hasSubmissionsWith,omitempty"`

	// "attendances" edge predicates.
	HasAttendances     *bool                   `json:"hasAttendances,omitempty"`
	HasAttendancesWith []*AttendanceWhereInput `json:"hasAttendancesWith,omitempty"`

	// "payments" edge predicates.
	HasPayments     *bool                       `json:"hasPayments,omitempty"`
	HasPaymentsWith []*TuitionPaymentWhereInput `json:"hasPaymentsWith,omitempty"`

	// "grades" edge predicates.
	HasGrades     *bool              `json:"hasGrades,omitempty"`
	HasGradesWith []*GradeWhereInput `json:"hasGradesWith,omitempty"`

	// "groups" edge predicates.
	HasGroups     *bool              `json:"hasGroups,omitempty"`
	HasGroupsWith []*GroupWhereInput `json:"hasGroupsWith,omitempty"`

	// "course_grades" edge predicates.
	HasCourseGrades     *bool                    `json:"hasCourseGrades,omitempty"`
	HasCourseGradesWith []*CourseGradeWhereInput `json:"hasCourseGradesWith,omitempty"`
}

// Filter applies the UserWhereInput filter on the UserQuery builder.
func (i *UserWhereInput) Filter(q *UserQuery) (*UserQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		return nil, err
	}
	return q.Where(p), nil
}

// P returns a predicate for filtering users.
// An error is returned if the input is empty or invalid.
func (i *UserWhereInput) P() (predicate.User, error) {
	var predicates []predicate.User
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, user.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.User, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			or = append(or, p)
		}
		predicates = append(predicates, user.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, err
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.User, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			and = append(and, p)
		}
		predicates = append(predicates, user.And(and...))
	}
	if i.ID != nil {
		predicates = append(predicates, user.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, user.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, user.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, user.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, user.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, user.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, user.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, user.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, user.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, user.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, user.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, user.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, user.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, user.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, user.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, user.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, user.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, user.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, user.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, user.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, user.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, user.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, user.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, user.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.Name != nil {
		predicates = append(predicates, user.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, user.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, user.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, user.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, user.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, user.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, user.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, user.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, user.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, user.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, user.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, user.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, user.NameContainsFold(*i.NameContainsFold))
	}
	if i.Username != nil {
		predicates = append(predicates, user.UsernameEQ(*i.Username))
	}
	if i.UsernameNEQ != nil {
		predicates = append(predicates, user.UsernameNEQ(*i.UsernameNEQ))
	}
	if len(i.UsernameIn) > 0 {
		predicates = append(predicates, user.UsernameIn(i.UsernameIn...))
	}
	if len(i.UsernameNotIn) > 0 {
		predicates = append(predicates, user.UsernameNotIn(i.UsernameNotIn...))
	}
	if i.UsernameGT != nil {
		predicates = append(predicates, user.UsernameGT(*i.UsernameGT))
	}
	if i.UsernameGTE != nil {
		predicates = append(predicates, user.UsernameGTE(*i.UsernameGTE))
	}
	if i.UsernameLT != nil {
		predicates = append(predicates, user.UsernameLT(*i.UsernameLT))
	}
	if i.UsernameLTE != nil {
		predicates = append(predicates, user.UsernameLTE(*i.UsernameLTE))
	}
	if i.UsernameContains != nil {
		predicates = append(predicates, user.UsernameContains(*i.UsernameContains))
	}
	if i.UsernameHasPrefix != nil {
		predicates = append(predicates, user.UsernameHasPrefix(*i.UsernameHasPrefix))
	}
	if i.UsernameHasSuffix != nil {
		predicates = append(predicates, user.UsernameHasSuffix(*i.UsernameHasSuffix))
	}
	if i.UsernameEqualFold != nil {
		predicates = append(predicates, user.UsernameEqualFold(*i.UsernameEqualFold))
	}
	if i.UsernameContainsFold != nil {
		predicates = append(predicates, user.UsernameContainsFold(*i.UsernameContainsFold))
	}
	if i.Phone != nil {
		predicates = append(predicates, user.PhoneEQ(*i.Phone))
	}
	if i.PhoneNEQ != nil {
		predicates = append(predicates, user.PhoneNEQ(*i.PhoneNEQ))
	}
	if len(i.PhoneIn) > 0 {
		predicates = append(predicates, user.PhoneIn(i.PhoneIn...))
	}
	if len(i.PhoneNotIn) > 0 {
		predicates = append(predicates, user.PhoneNotIn(i.PhoneNotIn...))
	}
	if i.PhoneGT != nil {
		predicates = append(predicates, user.PhoneGT(*i.PhoneGT))
	}
	if i.PhoneGTE != nil {
		predicates = append(predicates, user.PhoneGTE(*i.PhoneGTE))
	}
	if i.PhoneLT != nil {
		predicates = append(predicates, user.PhoneLT(*i.PhoneLT))
	}
	if i.PhoneLTE != nil {
		predicates = append(predicates, user.PhoneLTE(*i.PhoneLTE))
	}
	if i.PhoneContains != nil {
		predicates = append(predicates, user.PhoneContains(*i.PhoneContains))
	}
	if i.PhoneHasPrefix != nil {
		predicates = append(predicates, user.PhoneHasPrefix(*i.PhoneHasPrefix))
	}
	if i.PhoneHasSuffix != nil {
		predicates = append(predicates, user.PhoneHasSuffix(*i.PhoneHasSuffix))
	}
	if i.PhoneEqualFold != nil {
		predicates = append(predicates, user.PhoneEqualFold(*i.PhoneEqualFold))
	}
	if i.PhoneContainsFold != nil {
		predicates = append(predicates, user.PhoneContainsFold(*i.PhoneContainsFold))
	}
	if i.Image != nil {
		predicates = append(predicates, user.ImageEQ(*i.Image))
	}
	if i.ImageNEQ != nil {
		predicates = append(predicates, user.ImageNEQ(*i.ImageNEQ))
	}
	if len(i.ImageIn) > 0 {
		predicates = append(predicates, user.ImageIn(i.ImageIn...))
	}
	if len(i.ImageNotIn) > 0 {
		predicates = append(predicates, user.ImageNotIn(i.ImageNotIn...))
	}
	if i.ImageGT != nil {
		predicates = append(predicates, user.ImageGT(*i.ImageGT))
	}
	if i.ImageGTE != nil {
		predicates = append(predicates, user.ImageGTE(*i.ImageGTE))
	}
	if i.ImageLT != nil {
		predicates = append(predicates, user.ImageLT(*i.ImageLT))
	}
	if i.ImageLTE != nil {
		predicates = append(predicates, user.ImageLTE(*i.ImageLTE))
	}
	if i.ImageContains != nil {
		predicates = append(predicates, user.ImageContains(*i.ImageContains))
	}
	if i.ImageHasPrefix != nil {
		predicates = append(predicates, user.ImageHasPrefix(*i.ImageHasPrefix))
	}
	if i.ImageHasSuffix != nil {
		predicates = append(predicates, user.ImageHasSuffix(*i.ImageHasSuffix))
	}
	if i.ImageIsNil {
		predicates = append(predicates, user.ImageIsNil())
	}
	if i.ImageNotNil {
		predicates = append(predicates, user.ImageNotNil())
	}
	if i.ImageEqualFold != nil {
		predicates = append(predicates, user.ImageEqualFold(*i.ImageEqualFold))
	}
	if i.ImageContainsFold != nil {
		predicates = append(predicates, user.ImageContainsFold(*i.ImageContainsFold))
	}
	if i.Directory != nil {
		predicates = append(predicates, user.DirectoryEQ(*i.Directory))
	}
	if i.DirectoryNEQ != nil {
		predicates = append(predicates, user.DirectoryNEQ(*i.DirectoryNEQ))
	}
	if len(i.DirectoryIn) > 0 {
		predicates = append(predicates, user.DirectoryIn(i.DirectoryIn...))
	}
	if len(i.DirectoryNotIn) > 0 {
		predicates = append(predicates, user.DirectoryNotIn(i.DirectoryNotIn...))
	}
	if i.DirectoryGT != nil {
		predicates = append(predicates, user.DirectoryGT(*i.DirectoryGT))
	}
	if i.DirectoryGTE != nil {
		predicates = append(predicates, user.DirectoryGTE(*i.DirectoryGTE))
	}
	if i.DirectoryLT != nil {
		predicates = append(predicates, user.DirectoryLT(*i.DirectoryLT))
	}
	if i.DirectoryLTE != nil {
		predicates = append(predicates, user.DirectoryLTE(*i.DirectoryLTE))
	}
	if i.DirectoryContains != nil {
		predicates = append(predicates, user.DirectoryContains(*i.DirectoryContains))
	}
	if i.DirectoryHasPrefix != nil {
		predicates = append(predicates, user.DirectoryHasPrefix(*i.DirectoryHasPrefix))
	}
	if i.DirectoryHasSuffix != nil {
		predicates = append(predicates, user.DirectoryHasSuffix(*i.DirectoryHasSuffix))
	}
	if i.DirectoryEqualFold != nil {
		predicates = append(predicates, user.DirectoryEqualFold(*i.DirectoryEqualFold))
	}
	if i.DirectoryContainsFold != nil {
		predicates = append(predicates, user.DirectoryContainsFold(*i.DirectoryContainsFold))
	}
	if i.TokenVersion != nil {
		predicates = append(predicates, user.TokenVersionEQ(*i.TokenVersion))
	}
	if i.TokenVersionNEQ != nil {
		predicates = append(predicates, user.TokenVersionNEQ(*i.TokenVersionNEQ))
	}
	if len(i.TokenVersionIn) > 0 {
		predicates = append(predicates, user.TokenVersionIn(i.TokenVersionIn...))
	}
	if len(i.TokenVersionNotIn) > 0 {
		predicates = append(predicates, user.TokenVersionNotIn(i.TokenVersionNotIn...))
	}
	if i.TokenVersionGT != nil {
		predicates = append(predicates, user.TokenVersionGT(*i.TokenVersionGT))
	}
	if i.TokenVersionGTE != nil {
		predicates = append(predicates, user.TokenVersionGTE(*i.TokenVersionGTE))
	}
	if i.TokenVersionLT != nil {
		predicates = append(predicates, user.TokenVersionLT(*i.TokenVersionLT))
	}
	if i.TokenVersionLTE != nil {
		predicates = append(predicates, user.TokenVersionLTE(*i.TokenVersionLTE))
	}
	if i.Role != nil {
		predicates = append(predicates, user.RoleEQ(*i.Role))
	}
	if i.RoleNEQ != nil {
		predicates = append(predicates, user.RoleNEQ(*i.RoleNEQ))
	}
	if len(i.RoleIn) > 0 {
		predicates = append(predicates, user.RoleIn(i.RoleIn...))
	}
	if len(i.RoleNotIn) > 0 {
		predicates = append(predicates, user.RoleNotIn(i.RoleNotIn...))
	}
	if i.Active != nil {
		predicates = append(predicates, user.ActiveEQ(*i.Active))
	}
	if i.ActiveNEQ != nil {
		predicates = append(predicates, user.ActiveNEQ(*i.ActiveNEQ))
	}
	if i.DeletedAt != nil {
		predicates = append(predicates, user.DeletedAtEQ(*i.DeletedAt))
	}
	if i.DeletedAtNEQ != nil {
		predicates = append(predicates, user.DeletedAtNEQ(*i.DeletedAtNEQ))
	}
	if len(i.DeletedAtIn) > 0 {
		predicates = append(predicates, user.DeletedAtIn(i.DeletedAtIn...))
	}
	if len(i.DeletedAtNotIn) > 0 {
		predicates = append(predicates, user.DeletedAtNotIn(i.DeletedAtNotIn...))
	}
	if i.DeletedAtGT != nil {
		predicates = append(predicates, user.DeletedAtGT(*i.DeletedAtGT))
	}
	if i.DeletedAtGTE != nil {
		predicates = append(predicates, user.DeletedAtGTE(*i.DeletedAtGTE))
	}
	if i.DeletedAtLT != nil {
		predicates = append(predicates, user.DeletedAtLT(*i.DeletedAtLT))
	}
	if i.DeletedAtLTE != nil {
		predicates = append(predicates, user.DeletedAtLTE(*i.DeletedAtLTE))
	}
	if i.DeletedAtIsNil {
		predicates = append(predicates, user.DeletedAtIsNil())
	}
	if i.DeletedAtNotNil {
		predicates = append(predicates, user.DeletedAtNotNil())
	}

	if i.HasStage != nil {
		p := user.HasStage()
		if !*i.HasStage {
			p = user.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasStageWith) > 0 {
		with := make([]predicate.Stage, 0, len(i.HasStageWith))
		for _, w := range i.HasStageWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, user.HasStageWith(with...))
	}
	if i.HasSchool != nil {
		p := user.HasSchool()
		if !*i.HasSchool {
			p = user.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasSchoolWith) > 0 {
		with := make([]predicate.School, 0, len(i.HasSchoolWith))
		for _, w := range i.HasSchoolWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, user.HasSchoolWith(with...))
	}
	if i.HasClasses != nil {
		p := user.HasClasses()
		if !*i.HasClasses {
			p = user.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasClassesWith) > 0 {
		with := make([]predicate.Class, 0, len(i.HasClassesWith))
		for _, w := range i.HasClassesWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, user.HasClassesWith(with...))
	}
	if i.HasMessages != nil {
		p := user.HasMessages()
		if !*i.HasMessages {
			p = user.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasMessagesWith) > 0 {
		with := make([]predicate.Message, 0, len(i.HasMessagesWith))
		for _, w := range i.HasMessagesWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, user.HasMessagesWith(with...))
	}
	if i.HasSubmissions != nil {
		p := user.HasSubmissions()
		if !*i.HasSubmissions {
			p = user.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasSubmissionsWith) > 0 {
		with := make([]predicate.AssignmentSubmission, 0, len(i.HasSubmissionsWith))
		for _, w := range i.HasSubmissionsWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, user.HasSubmissionsWith(with...))
	}
	if i.HasAttendances != nil {
		p := user.HasAttendances()
		if !*i.HasAttendances {
			p = user.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasAttendancesWith) > 0 {
		with := make([]predicate.Attendance, 0, len(i.HasAttendancesWith))
		for _, w := range i.HasAttendancesWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, user.HasAttendancesWith(with...))
	}
	if i.HasPayments != nil {
		p := user.HasPayments()
		if !*i.HasPayments {
			p = user.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasPaymentsWith) > 0 {
		with := make([]predicate.TuitionPayment, 0, len(i.HasPaymentsWith))
		for _, w := range i.HasPaymentsWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, user.HasPaymentsWith(with...))
	}
	if i.HasGrades != nil {
		p := user.HasGrades()
		if !*i.HasGrades {
			p = user.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasGradesWith) > 0 {
		with := make([]predicate.Grade, 0, len(i.HasGradesWith))
		for _, w := range i.HasGradesWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, user.HasGradesWith(with...))
	}
	if i.HasGroups != nil {
		p := user.HasGroups()
		if !*i.HasGroups {
			p = user.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasGroupsWith) > 0 {
		with := make([]predicate.Group, 0, len(i.HasGroupsWith))
		for _, w := range i.HasGroupsWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, user.HasGroupsWith(with...))
	}
	if i.HasCourseGrades != nil {
		p := user.HasCourseGrades()
		if !*i.HasCourseGrades {
			p = user.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCourseGradesWith) > 0 {
		with := make([]predicate.CourseGrade, 0, len(i.HasCourseGradesWith))
		for _, w := range i.HasCourseGradesWith {
			p, err := w.P()
			if err != nil {
				return nil, err
			}
			with = append(with, p)
		}
		predicates = append(predicates, user.HasCourseGradesWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, fmt.Errorf("github.com/msal4/hassah_school_server/ent: empty predicate UserWhereInput")
	case 1:
		return predicates[0], nil
	default:
		return user.And(predicates...), nil
	}
}
