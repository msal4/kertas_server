// Code generated by entc, DO NOT EDIT.

package ent

import (
	"context"
	"fmt"
	"sync"
	"time"

	"github.com/msal4/hassah_school_server/ent/assignment"
	"github.com/msal4/hassah_school_server/ent/assignmentsubmission"
	"github.com/msal4/hassah_school_server/ent/attendance"
	"github.com/msal4/hassah_school_server/ent/class"
	"github.com/msal4/hassah_school_server/ent/grade"
	"github.com/msal4/hassah_school_server/ent/group"
	"github.com/msal4/hassah_school_server/ent/message"
	"github.com/msal4/hassah_school_server/ent/predicate"
	"github.com/msal4/hassah_school_server/ent/schedule"
	"github.com/msal4/hassah_school_server/ent/schema"
	"github.com/msal4/hassah_school_server/ent/school"
	"github.com/msal4/hassah_school_server/ent/stage"
	"github.com/msal4/hassah_school_server/ent/tuitionpayment"
	"github.com/msal4/hassah_school_server/ent/user"

	"entgo.io/ent"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeAssignment           = "Assignment"
	TypeAssignmentSubmission = "AssignmentSubmission"
	TypeAttendance           = "Attendance"
	TypeClass                = "Class"
	TypeGrade                = "Grade"
	TypeGroup                = "Group"
	TypeMessage              = "Message"
	TypeSchedule             = "Schedule"
	TypeSchool               = "School"
	TypeStage                = "Stage"
	TypeTuitionPayment       = "TuitionPayment"
	TypeUser                 = "User"
)

// AssignmentMutation represents an operation that mutates the Assignment nodes in the graph.
type AssignmentMutation struct {
	config
	op                 Op
	typ                string
	id                 *int
	created_at         *time.Time
	updated_at         *time.Time
	name               *string
	description        *string
	is_exam            *bool
	due_date           *time.Time
	duration           *int
	addduration        *int
	deleted_at         *time.Time
	clearedFields      map[string]struct{}
	class              *int
	clearedclass       bool
	submissions        map[int]struct{}
	removedsubmissions map[int]struct{}
	clearedsubmissions bool
	grades             map[int]struct{}
	removedgrades      map[int]struct{}
	clearedgrades      bool
	done               bool
	oldValue           func(context.Context) (*Assignment, error)
	predicates         []predicate.Assignment
}

var _ ent.Mutation = (*AssignmentMutation)(nil)

// assignmentOption allows management of the mutation configuration using functional options.
type assignmentOption func(*AssignmentMutation)

// newAssignmentMutation creates new mutation for the Assignment entity.
func newAssignmentMutation(c config, op Op, opts ...assignmentOption) *AssignmentMutation {
	m := &AssignmentMutation{
		config:        c,
		op:            op,
		typ:           TypeAssignment,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAssignmentID sets the ID field of the mutation.
func withAssignmentID(id int) assignmentOption {
	return func(m *AssignmentMutation) {
		var (
			err   error
			once  sync.Once
			value *Assignment
		)
		m.oldValue = func(ctx context.Context) (*Assignment, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Assignment.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAssignment sets the old Assignment of the mutation.
func withAssignment(node *Assignment) assignmentOption {
	return func(m *AssignmentMutation) {
		m.oldValue = func(context.Context) (*Assignment, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AssignmentMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AssignmentMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AssignmentMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreatedAt sets the "created_at" field.
func (m *AssignmentMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AssignmentMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Assignment entity.
// If the Assignment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssignmentMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AssignmentMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AssignmentMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AssignmentMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Assignment entity.
// If the Assignment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssignmentMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AssignmentMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetName sets the "name" field.
func (m *AssignmentMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *AssignmentMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Assignment entity.
// If the Assignment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssignmentMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *AssignmentMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *AssignmentMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *AssignmentMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Assignment entity.
// If the Assignment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssignmentMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *AssignmentMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[assignment.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *AssignmentMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[assignment.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *AssignmentMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, assignment.FieldDescription)
}

// SetIsExam sets the "is_exam" field.
func (m *AssignmentMutation) SetIsExam(b bool) {
	m.is_exam = &b
}

// IsExam returns the value of the "is_exam" field in the mutation.
func (m *AssignmentMutation) IsExam() (r bool, exists bool) {
	v := m.is_exam
	if v == nil {
		return
	}
	return *v, true
}

// OldIsExam returns the old "is_exam" field's value of the Assignment entity.
// If the Assignment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssignmentMutation) OldIsExam(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldIsExam is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldIsExam requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsExam: %w", err)
	}
	return oldValue.IsExam, nil
}

// ResetIsExam resets all changes to the "is_exam" field.
func (m *AssignmentMutation) ResetIsExam() {
	m.is_exam = nil
}

// SetDueDate sets the "due_date" field.
func (m *AssignmentMutation) SetDueDate(t time.Time) {
	m.due_date = &t
}

// DueDate returns the value of the "due_date" field in the mutation.
func (m *AssignmentMutation) DueDate() (r time.Time, exists bool) {
	v := m.due_date
	if v == nil {
		return
	}
	return *v, true
}

// OldDueDate returns the old "due_date" field's value of the Assignment entity.
// If the Assignment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssignmentMutation) OldDueDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDueDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDueDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDueDate: %w", err)
	}
	return oldValue.DueDate, nil
}

// ResetDueDate resets all changes to the "due_date" field.
func (m *AssignmentMutation) ResetDueDate() {
	m.due_date = nil
}

// SetDuration sets the "duration" field.
func (m *AssignmentMutation) SetDuration(i int) {
	m.duration = &i
	m.addduration = nil
}

// Duration returns the value of the "duration" field in the mutation.
func (m *AssignmentMutation) Duration() (r int, exists bool) {
	v := m.duration
	if v == nil {
		return
	}
	return *v, true
}

// OldDuration returns the old "duration" field's value of the Assignment entity.
// If the Assignment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssignmentMutation) OldDuration(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDuration is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDuration requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDuration: %w", err)
	}
	return oldValue.Duration, nil
}

// AddDuration adds i to the "duration" field.
func (m *AssignmentMutation) AddDuration(i int) {
	if m.addduration != nil {
		*m.addduration += i
	} else {
		m.addduration = &i
	}
}

// AddedDuration returns the value that was added to the "duration" field in this mutation.
func (m *AssignmentMutation) AddedDuration() (r int, exists bool) {
	v := m.addduration
	if v == nil {
		return
	}
	return *v, true
}

// ClearDuration clears the value of the "duration" field.
func (m *AssignmentMutation) ClearDuration() {
	m.duration = nil
	m.addduration = nil
	m.clearedFields[assignment.FieldDuration] = struct{}{}
}

// DurationCleared returns if the "duration" field was cleared in this mutation.
func (m *AssignmentMutation) DurationCleared() bool {
	_, ok := m.clearedFields[assignment.FieldDuration]
	return ok
}

// ResetDuration resets all changes to the "duration" field.
func (m *AssignmentMutation) ResetDuration() {
	m.duration = nil
	m.addduration = nil
	delete(m.clearedFields, assignment.FieldDuration)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *AssignmentMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *AssignmentMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Assignment entity.
// If the Assignment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssignmentMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *AssignmentMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[assignment.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *AssignmentMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[assignment.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *AssignmentMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, assignment.FieldDeletedAt)
}

// SetClassID sets the "class" edge to the Class entity by id.
func (m *AssignmentMutation) SetClassID(id int) {
	m.class = &id
}

// ClearClass clears the "class" edge to the Class entity.
func (m *AssignmentMutation) ClearClass() {
	m.clearedclass = true
}

// ClassCleared reports if the "class" edge to the Class entity was cleared.
func (m *AssignmentMutation) ClassCleared() bool {
	return m.clearedclass
}

// ClassID returns the "class" edge ID in the mutation.
func (m *AssignmentMutation) ClassID() (id int, exists bool) {
	if m.class != nil {
		return *m.class, true
	}
	return
}

// ClassIDs returns the "class" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ClassID instead. It exists only for internal usage by the builders.
func (m *AssignmentMutation) ClassIDs() (ids []int) {
	if id := m.class; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetClass resets all changes to the "class" edge.
func (m *AssignmentMutation) ResetClass() {
	m.class = nil
	m.clearedclass = false
}

// AddSubmissionIDs adds the "submissions" edge to the AssignmentSubmission entity by ids.
func (m *AssignmentMutation) AddSubmissionIDs(ids ...int) {
	if m.submissions == nil {
		m.submissions = make(map[int]struct{})
	}
	for i := range ids {
		m.submissions[ids[i]] = struct{}{}
	}
}

// ClearSubmissions clears the "submissions" edge to the AssignmentSubmission entity.
func (m *AssignmentMutation) ClearSubmissions() {
	m.clearedsubmissions = true
}

// SubmissionsCleared reports if the "submissions" edge to the AssignmentSubmission entity was cleared.
func (m *AssignmentMutation) SubmissionsCleared() bool {
	return m.clearedsubmissions
}

// RemoveSubmissionIDs removes the "submissions" edge to the AssignmentSubmission entity by IDs.
func (m *AssignmentMutation) RemoveSubmissionIDs(ids ...int) {
	if m.removedsubmissions == nil {
		m.removedsubmissions = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.submissions, ids[i])
		m.removedsubmissions[ids[i]] = struct{}{}
	}
}

// RemovedSubmissions returns the removed IDs of the "submissions" edge to the AssignmentSubmission entity.
func (m *AssignmentMutation) RemovedSubmissionsIDs() (ids []int) {
	for id := range m.removedsubmissions {
		ids = append(ids, id)
	}
	return
}

// SubmissionsIDs returns the "submissions" edge IDs in the mutation.
func (m *AssignmentMutation) SubmissionsIDs() (ids []int) {
	for id := range m.submissions {
		ids = append(ids, id)
	}
	return
}

// ResetSubmissions resets all changes to the "submissions" edge.
func (m *AssignmentMutation) ResetSubmissions() {
	m.submissions = nil
	m.clearedsubmissions = false
	m.removedsubmissions = nil
}

// AddGradeIDs adds the "grades" edge to the Grade entity by ids.
func (m *AssignmentMutation) AddGradeIDs(ids ...int) {
	if m.grades == nil {
		m.grades = make(map[int]struct{})
	}
	for i := range ids {
		m.grades[ids[i]] = struct{}{}
	}
}

// ClearGrades clears the "grades" edge to the Grade entity.
func (m *AssignmentMutation) ClearGrades() {
	m.clearedgrades = true
}

// GradesCleared reports if the "grades" edge to the Grade entity was cleared.
func (m *AssignmentMutation) GradesCleared() bool {
	return m.clearedgrades
}

// RemoveGradeIDs removes the "grades" edge to the Grade entity by IDs.
func (m *AssignmentMutation) RemoveGradeIDs(ids ...int) {
	if m.removedgrades == nil {
		m.removedgrades = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.grades, ids[i])
		m.removedgrades[ids[i]] = struct{}{}
	}
}

// RemovedGrades returns the removed IDs of the "grades" edge to the Grade entity.
func (m *AssignmentMutation) RemovedGradesIDs() (ids []int) {
	for id := range m.removedgrades {
		ids = append(ids, id)
	}
	return
}

// GradesIDs returns the "grades" edge IDs in the mutation.
func (m *AssignmentMutation) GradesIDs() (ids []int) {
	for id := range m.grades {
		ids = append(ids, id)
	}
	return
}

// ResetGrades resets all changes to the "grades" edge.
func (m *AssignmentMutation) ResetGrades() {
	m.grades = nil
	m.clearedgrades = false
	m.removedgrades = nil
}

// Where appends a list predicates to the AssignmentMutation builder.
func (m *AssignmentMutation) Where(ps ...predicate.Assignment) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *AssignmentMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Assignment).
func (m *AssignmentMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AssignmentMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.created_at != nil {
		fields = append(fields, assignment.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, assignment.FieldUpdatedAt)
	}
	if m.name != nil {
		fields = append(fields, assignment.FieldName)
	}
	if m.description != nil {
		fields = append(fields, assignment.FieldDescription)
	}
	if m.is_exam != nil {
		fields = append(fields, assignment.FieldIsExam)
	}
	if m.due_date != nil {
		fields = append(fields, assignment.FieldDueDate)
	}
	if m.duration != nil {
		fields = append(fields, assignment.FieldDuration)
	}
	if m.deleted_at != nil {
		fields = append(fields, assignment.FieldDeletedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AssignmentMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case assignment.FieldCreatedAt:
		return m.CreatedAt()
	case assignment.FieldUpdatedAt:
		return m.UpdatedAt()
	case assignment.FieldName:
		return m.Name()
	case assignment.FieldDescription:
		return m.Description()
	case assignment.FieldIsExam:
		return m.IsExam()
	case assignment.FieldDueDate:
		return m.DueDate()
	case assignment.FieldDuration:
		return m.Duration()
	case assignment.FieldDeletedAt:
		return m.DeletedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AssignmentMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case assignment.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case assignment.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case assignment.FieldName:
		return m.OldName(ctx)
	case assignment.FieldDescription:
		return m.OldDescription(ctx)
	case assignment.FieldIsExam:
		return m.OldIsExam(ctx)
	case assignment.FieldDueDate:
		return m.OldDueDate(ctx)
	case assignment.FieldDuration:
		return m.OldDuration(ctx)
	case assignment.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Assignment field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AssignmentMutation) SetField(name string, value ent.Value) error {
	switch name {
	case assignment.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case assignment.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case assignment.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case assignment.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case assignment.FieldIsExam:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsExam(v)
		return nil
	case assignment.FieldDueDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDueDate(v)
		return nil
	case assignment.FieldDuration:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDuration(v)
		return nil
	case assignment.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Assignment field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AssignmentMutation) AddedFields() []string {
	var fields []string
	if m.addduration != nil {
		fields = append(fields, assignment.FieldDuration)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AssignmentMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case assignment.FieldDuration:
		return m.AddedDuration()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AssignmentMutation) AddField(name string, value ent.Value) error {
	switch name {
	case assignment.FieldDuration:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDuration(v)
		return nil
	}
	return fmt.Errorf("unknown Assignment numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AssignmentMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(assignment.FieldDescription) {
		fields = append(fields, assignment.FieldDescription)
	}
	if m.FieldCleared(assignment.FieldDuration) {
		fields = append(fields, assignment.FieldDuration)
	}
	if m.FieldCleared(assignment.FieldDeletedAt) {
		fields = append(fields, assignment.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AssignmentMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AssignmentMutation) ClearField(name string) error {
	switch name {
	case assignment.FieldDescription:
		m.ClearDescription()
		return nil
	case assignment.FieldDuration:
		m.ClearDuration()
		return nil
	case assignment.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown Assignment nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AssignmentMutation) ResetField(name string) error {
	switch name {
	case assignment.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case assignment.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case assignment.FieldName:
		m.ResetName()
		return nil
	case assignment.FieldDescription:
		m.ResetDescription()
		return nil
	case assignment.FieldIsExam:
		m.ResetIsExam()
		return nil
	case assignment.FieldDueDate:
		m.ResetDueDate()
		return nil
	case assignment.FieldDuration:
		m.ResetDuration()
		return nil
	case assignment.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown Assignment field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AssignmentMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.class != nil {
		edges = append(edges, assignment.EdgeClass)
	}
	if m.submissions != nil {
		edges = append(edges, assignment.EdgeSubmissions)
	}
	if m.grades != nil {
		edges = append(edges, assignment.EdgeGrades)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AssignmentMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case assignment.EdgeClass:
		if id := m.class; id != nil {
			return []ent.Value{*id}
		}
	case assignment.EdgeSubmissions:
		ids := make([]ent.Value, 0, len(m.submissions))
		for id := range m.submissions {
			ids = append(ids, id)
		}
		return ids
	case assignment.EdgeGrades:
		ids := make([]ent.Value, 0, len(m.grades))
		for id := range m.grades {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AssignmentMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedsubmissions != nil {
		edges = append(edges, assignment.EdgeSubmissions)
	}
	if m.removedgrades != nil {
		edges = append(edges, assignment.EdgeGrades)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AssignmentMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case assignment.EdgeSubmissions:
		ids := make([]ent.Value, 0, len(m.removedsubmissions))
		for id := range m.removedsubmissions {
			ids = append(ids, id)
		}
		return ids
	case assignment.EdgeGrades:
		ids := make([]ent.Value, 0, len(m.removedgrades))
		for id := range m.removedgrades {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AssignmentMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedclass {
		edges = append(edges, assignment.EdgeClass)
	}
	if m.clearedsubmissions {
		edges = append(edges, assignment.EdgeSubmissions)
	}
	if m.clearedgrades {
		edges = append(edges, assignment.EdgeGrades)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AssignmentMutation) EdgeCleared(name string) bool {
	switch name {
	case assignment.EdgeClass:
		return m.clearedclass
	case assignment.EdgeSubmissions:
		return m.clearedsubmissions
	case assignment.EdgeGrades:
		return m.clearedgrades
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AssignmentMutation) ClearEdge(name string) error {
	switch name {
	case assignment.EdgeClass:
		m.ClearClass()
		return nil
	}
	return fmt.Errorf("unknown Assignment unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AssignmentMutation) ResetEdge(name string) error {
	switch name {
	case assignment.EdgeClass:
		m.ResetClass()
		return nil
	case assignment.EdgeSubmissions:
		m.ResetSubmissions()
		return nil
	case assignment.EdgeGrades:
		m.ResetGrades()
		return nil
	}
	return fmt.Errorf("unknown Assignment edge %s", name)
}

// AssignmentSubmissionMutation represents an operation that mutates the AssignmentSubmission nodes in the graph.
type AssignmentSubmissionMutation struct {
	config
	op                Op
	typ               string
	id                *int
	created_at        *time.Time
	updated_at        *time.Time
	files             *[]string
	submitted_at      *time.Time
	clearedFields     map[string]struct{}
	student           *int
	clearedstudent    bool
	assignment        *int
	clearedassignment bool
	done              bool
	oldValue          func(context.Context) (*AssignmentSubmission, error)
	predicates        []predicate.AssignmentSubmission
}

var _ ent.Mutation = (*AssignmentSubmissionMutation)(nil)

// assignmentsubmissionOption allows management of the mutation configuration using functional options.
type assignmentsubmissionOption func(*AssignmentSubmissionMutation)

// newAssignmentSubmissionMutation creates new mutation for the AssignmentSubmission entity.
func newAssignmentSubmissionMutation(c config, op Op, opts ...assignmentsubmissionOption) *AssignmentSubmissionMutation {
	m := &AssignmentSubmissionMutation{
		config:        c,
		op:            op,
		typ:           TypeAssignmentSubmission,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAssignmentSubmissionID sets the ID field of the mutation.
func withAssignmentSubmissionID(id int) assignmentsubmissionOption {
	return func(m *AssignmentSubmissionMutation) {
		var (
			err   error
			once  sync.Once
			value *AssignmentSubmission
		)
		m.oldValue = func(ctx context.Context) (*AssignmentSubmission, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AssignmentSubmission.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAssignmentSubmission sets the old AssignmentSubmission of the mutation.
func withAssignmentSubmission(node *AssignmentSubmission) assignmentsubmissionOption {
	return func(m *AssignmentSubmissionMutation) {
		m.oldValue = func(context.Context) (*AssignmentSubmission, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AssignmentSubmissionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AssignmentSubmissionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AssignmentSubmissionMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreatedAt sets the "created_at" field.
func (m *AssignmentSubmissionMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AssignmentSubmissionMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the AssignmentSubmission entity.
// If the AssignmentSubmission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssignmentSubmissionMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AssignmentSubmissionMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AssignmentSubmissionMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AssignmentSubmissionMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the AssignmentSubmission entity.
// If the AssignmentSubmission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssignmentSubmissionMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AssignmentSubmissionMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetFiles sets the "files" field.
func (m *AssignmentSubmissionMutation) SetFiles(s []string) {
	m.files = &s
}

// Files returns the value of the "files" field in the mutation.
func (m *AssignmentSubmissionMutation) Files() (r []string, exists bool) {
	v := m.files
	if v == nil {
		return
	}
	return *v, true
}

// OldFiles returns the old "files" field's value of the AssignmentSubmission entity.
// If the AssignmentSubmission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssignmentSubmissionMutation) OldFiles(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldFiles is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldFiles requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFiles: %w", err)
	}
	return oldValue.Files, nil
}

// ResetFiles resets all changes to the "files" field.
func (m *AssignmentSubmissionMutation) ResetFiles() {
	m.files = nil
}

// SetSubmittedAt sets the "submitted_at" field.
func (m *AssignmentSubmissionMutation) SetSubmittedAt(t time.Time) {
	m.submitted_at = &t
}

// SubmittedAt returns the value of the "submitted_at" field in the mutation.
func (m *AssignmentSubmissionMutation) SubmittedAt() (r time.Time, exists bool) {
	v := m.submitted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldSubmittedAt returns the old "submitted_at" field's value of the AssignmentSubmission entity.
// If the AssignmentSubmission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssignmentSubmissionMutation) OldSubmittedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSubmittedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSubmittedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSubmittedAt: %w", err)
	}
	return oldValue.SubmittedAt, nil
}

// ClearSubmittedAt clears the value of the "submitted_at" field.
func (m *AssignmentSubmissionMutation) ClearSubmittedAt() {
	m.submitted_at = nil
	m.clearedFields[assignmentsubmission.FieldSubmittedAt] = struct{}{}
}

// SubmittedAtCleared returns if the "submitted_at" field was cleared in this mutation.
func (m *AssignmentSubmissionMutation) SubmittedAtCleared() bool {
	_, ok := m.clearedFields[assignmentsubmission.FieldSubmittedAt]
	return ok
}

// ResetSubmittedAt resets all changes to the "submitted_at" field.
func (m *AssignmentSubmissionMutation) ResetSubmittedAt() {
	m.submitted_at = nil
	delete(m.clearedFields, assignmentsubmission.FieldSubmittedAt)
}

// SetStudentID sets the "student" edge to the User entity by id.
func (m *AssignmentSubmissionMutation) SetStudentID(id int) {
	m.student = &id
}

// ClearStudent clears the "student" edge to the User entity.
func (m *AssignmentSubmissionMutation) ClearStudent() {
	m.clearedstudent = true
}

// StudentCleared reports if the "student" edge to the User entity was cleared.
func (m *AssignmentSubmissionMutation) StudentCleared() bool {
	return m.clearedstudent
}

// StudentID returns the "student" edge ID in the mutation.
func (m *AssignmentSubmissionMutation) StudentID() (id int, exists bool) {
	if m.student != nil {
		return *m.student, true
	}
	return
}

// StudentIDs returns the "student" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// StudentID instead. It exists only for internal usage by the builders.
func (m *AssignmentSubmissionMutation) StudentIDs() (ids []int) {
	if id := m.student; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetStudent resets all changes to the "student" edge.
func (m *AssignmentSubmissionMutation) ResetStudent() {
	m.student = nil
	m.clearedstudent = false
}

// SetAssignmentID sets the "assignment" edge to the Assignment entity by id.
func (m *AssignmentSubmissionMutation) SetAssignmentID(id int) {
	m.assignment = &id
}

// ClearAssignment clears the "assignment" edge to the Assignment entity.
func (m *AssignmentSubmissionMutation) ClearAssignment() {
	m.clearedassignment = true
}

// AssignmentCleared reports if the "assignment" edge to the Assignment entity was cleared.
func (m *AssignmentSubmissionMutation) AssignmentCleared() bool {
	return m.clearedassignment
}

// AssignmentID returns the "assignment" edge ID in the mutation.
func (m *AssignmentSubmissionMutation) AssignmentID() (id int, exists bool) {
	if m.assignment != nil {
		return *m.assignment, true
	}
	return
}

// AssignmentIDs returns the "assignment" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AssignmentID instead. It exists only for internal usage by the builders.
func (m *AssignmentSubmissionMutation) AssignmentIDs() (ids []int) {
	if id := m.assignment; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAssignment resets all changes to the "assignment" edge.
func (m *AssignmentSubmissionMutation) ResetAssignment() {
	m.assignment = nil
	m.clearedassignment = false
}

// Where appends a list predicates to the AssignmentSubmissionMutation builder.
func (m *AssignmentSubmissionMutation) Where(ps ...predicate.AssignmentSubmission) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *AssignmentSubmissionMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (AssignmentSubmission).
func (m *AssignmentSubmissionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AssignmentSubmissionMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.created_at != nil {
		fields = append(fields, assignmentsubmission.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, assignmentsubmission.FieldUpdatedAt)
	}
	if m.files != nil {
		fields = append(fields, assignmentsubmission.FieldFiles)
	}
	if m.submitted_at != nil {
		fields = append(fields, assignmentsubmission.FieldSubmittedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AssignmentSubmissionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case assignmentsubmission.FieldCreatedAt:
		return m.CreatedAt()
	case assignmentsubmission.FieldUpdatedAt:
		return m.UpdatedAt()
	case assignmentsubmission.FieldFiles:
		return m.Files()
	case assignmentsubmission.FieldSubmittedAt:
		return m.SubmittedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AssignmentSubmissionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case assignmentsubmission.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case assignmentsubmission.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case assignmentsubmission.FieldFiles:
		return m.OldFiles(ctx)
	case assignmentsubmission.FieldSubmittedAt:
		return m.OldSubmittedAt(ctx)
	}
	return nil, fmt.Errorf("unknown AssignmentSubmission field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AssignmentSubmissionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case assignmentsubmission.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case assignmentsubmission.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case assignmentsubmission.FieldFiles:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFiles(v)
		return nil
	case assignmentsubmission.FieldSubmittedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSubmittedAt(v)
		return nil
	}
	return fmt.Errorf("unknown AssignmentSubmission field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AssignmentSubmissionMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AssignmentSubmissionMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AssignmentSubmissionMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown AssignmentSubmission numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AssignmentSubmissionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(assignmentsubmission.FieldSubmittedAt) {
		fields = append(fields, assignmentsubmission.FieldSubmittedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AssignmentSubmissionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AssignmentSubmissionMutation) ClearField(name string) error {
	switch name {
	case assignmentsubmission.FieldSubmittedAt:
		m.ClearSubmittedAt()
		return nil
	}
	return fmt.Errorf("unknown AssignmentSubmission nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AssignmentSubmissionMutation) ResetField(name string) error {
	switch name {
	case assignmentsubmission.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case assignmentsubmission.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case assignmentsubmission.FieldFiles:
		m.ResetFiles()
		return nil
	case assignmentsubmission.FieldSubmittedAt:
		m.ResetSubmittedAt()
		return nil
	}
	return fmt.Errorf("unknown AssignmentSubmission field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AssignmentSubmissionMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.student != nil {
		edges = append(edges, assignmentsubmission.EdgeStudent)
	}
	if m.assignment != nil {
		edges = append(edges, assignmentsubmission.EdgeAssignment)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AssignmentSubmissionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case assignmentsubmission.EdgeStudent:
		if id := m.student; id != nil {
			return []ent.Value{*id}
		}
	case assignmentsubmission.EdgeAssignment:
		if id := m.assignment; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AssignmentSubmissionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AssignmentSubmissionMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AssignmentSubmissionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedstudent {
		edges = append(edges, assignmentsubmission.EdgeStudent)
	}
	if m.clearedassignment {
		edges = append(edges, assignmentsubmission.EdgeAssignment)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AssignmentSubmissionMutation) EdgeCleared(name string) bool {
	switch name {
	case assignmentsubmission.EdgeStudent:
		return m.clearedstudent
	case assignmentsubmission.EdgeAssignment:
		return m.clearedassignment
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AssignmentSubmissionMutation) ClearEdge(name string) error {
	switch name {
	case assignmentsubmission.EdgeStudent:
		m.ClearStudent()
		return nil
	case assignmentsubmission.EdgeAssignment:
		m.ClearAssignment()
		return nil
	}
	return fmt.Errorf("unknown AssignmentSubmission unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AssignmentSubmissionMutation) ResetEdge(name string) error {
	switch name {
	case assignmentsubmission.EdgeStudent:
		m.ResetStudent()
		return nil
	case assignmentsubmission.EdgeAssignment:
		m.ResetAssignment()
		return nil
	}
	return fmt.Errorf("unknown AssignmentSubmission edge %s", name)
}

// AttendanceMutation represents an operation that mutates the Attendance nodes in the graph.
type AttendanceMutation struct {
	config
	op             Op
	typ            string
	id             *int
	created_at     *time.Time
	updated_at     *time.Time
	date           *time.Time
	state          *attendance.State
	clearedFields  map[string]struct{}
	class          *int
	clearedclass   bool
	student        *int
	clearedstudent bool
	done           bool
	oldValue       func(context.Context) (*Attendance, error)
	predicates     []predicate.Attendance
}

var _ ent.Mutation = (*AttendanceMutation)(nil)

// attendanceOption allows management of the mutation configuration using functional options.
type attendanceOption func(*AttendanceMutation)

// newAttendanceMutation creates new mutation for the Attendance entity.
func newAttendanceMutation(c config, op Op, opts ...attendanceOption) *AttendanceMutation {
	m := &AttendanceMutation{
		config:        c,
		op:            op,
		typ:           TypeAttendance,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAttendanceID sets the ID field of the mutation.
func withAttendanceID(id int) attendanceOption {
	return func(m *AttendanceMutation) {
		var (
			err   error
			once  sync.Once
			value *Attendance
		)
		m.oldValue = func(ctx context.Context) (*Attendance, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Attendance.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAttendance sets the old Attendance of the mutation.
func withAttendance(node *Attendance) attendanceOption {
	return func(m *AttendanceMutation) {
		m.oldValue = func(context.Context) (*Attendance, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AttendanceMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AttendanceMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AttendanceMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreatedAt sets the "created_at" field.
func (m *AttendanceMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AttendanceMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Attendance entity.
// If the Attendance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AttendanceMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AttendanceMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AttendanceMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AttendanceMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Attendance entity.
// If the Attendance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AttendanceMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AttendanceMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDate sets the "date" field.
func (m *AttendanceMutation) SetDate(t time.Time) {
	m.date = &t
}

// Date returns the value of the "date" field in the mutation.
func (m *AttendanceMutation) Date() (r time.Time, exists bool) {
	v := m.date
	if v == nil {
		return
	}
	return *v, true
}

// OldDate returns the old "date" field's value of the Attendance entity.
// If the Attendance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AttendanceMutation) OldDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDate: %w", err)
	}
	return oldValue.Date, nil
}

// ResetDate resets all changes to the "date" field.
func (m *AttendanceMutation) ResetDate() {
	m.date = nil
}

// SetState sets the "state" field.
func (m *AttendanceMutation) SetState(a attendance.State) {
	m.state = &a
}

// State returns the value of the "state" field in the mutation.
func (m *AttendanceMutation) State() (r attendance.State, exists bool) {
	v := m.state
	if v == nil {
		return
	}
	return *v, true
}

// OldState returns the old "state" field's value of the Attendance entity.
// If the Attendance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AttendanceMutation) OldState(ctx context.Context) (v attendance.State, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldState is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldState requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldState: %w", err)
	}
	return oldValue.State, nil
}

// ResetState resets all changes to the "state" field.
func (m *AttendanceMutation) ResetState() {
	m.state = nil
}

// SetClassID sets the "class" edge to the Class entity by id.
func (m *AttendanceMutation) SetClassID(id int) {
	m.class = &id
}

// ClearClass clears the "class" edge to the Class entity.
func (m *AttendanceMutation) ClearClass() {
	m.clearedclass = true
}

// ClassCleared reports if the "class" edge to the Class entity was cleared.
func (m *AttendanceMutation) ClassCleared() bool {
	return m.clearedclass
}

// ClassID returns the "class" edge ID in the mutation.
func (m *AttendanceMutation) ClassID() (id int, exists bool) {
	if m.class != nil {
		return *m.class, true
	}
	return
}

// ClassIDs returns the "class" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ClassID instead. It exists only for internal usage by the builders.
func (m *AttendanceMutation) ClassIDs() (ids []int) {
	if id := m.class; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetClass resets all changes to the "class" edge.
func (m *AttendanceMutation) ResetClass() {
	m.class = nil
	m.clearedclass = false
}

// SetStudentID sets the "student" edge to the User entity by id.
func (m *AttendanceMutation) SetStudentID(id int) {
	m.student = &id
}

// ClearStudent clears the "student" edge to the User entity.
func (m *AttendanceMutation) ClearStudent() {
	m.clearedstudent = true
}

// StudentCleared reports if the "student" edge to the User entity was cleared.
func (m *AttendanceMutation) StudentCleared() bool {
	return m.clearedstudent
}

// StudentID returns the "student" edge ID in the mutation.
func (m *AttendanceMutation) StudentID() (id int, exists bool) {
	if m.student != nil {
		return *m.student, true
	}
	return
}

// StudentIDs returns the "student" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// StudentID instead. It exists only for internal usage by the builders.
func (m *AttendanceMutation) StudentIDs() (ids []int) {
	if id := m.student; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetStudent resets all changes to the "student" edge.
func (m *AttendanceMutation) ResetStudent() {
	m.student = nil
	m.clearedstudent = false
}

// Where appends a list predicates to the AttendanceMutation builder.
func (m *AttendanceMutation) Where(ps ...predicate.Attendance) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *AttendanceMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Attendance).
func (m *AttendanceMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AttendanceMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.created_at != nil {
		fields = append(fields, attendance.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, attendance.FieldUpdatedAt)
	}
	if m.date != nil {
		fields = append(fields, attendance.FieldDate)
	}
	if m.state != nil {
		fields = append(fields, attendance.FieldState)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AttendanceMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case attendance.FieldCreatedAt:
		return m.CreatedAt()
	case attendance.FieldUpdatedAt:
		return m.UpdatedAt()
	case attendance.FieldDate:
		return m.Date()
	case attendance.FieldState:
		return m.State()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AttendanceMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case attendance.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case attendance.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case attendance.FieldDate:
		return m.OldDate(ctx)
	case attendance.FieldState:
		return m.OldState(ctx)
	}
	return nil, fmt.Errorf("unknown Attendance field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AttendanceMutation) SetField(name string, value ent.Value) error {
	switch name {
	case attendance.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case attendance.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case attendance.FieldDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDate(v)
		return nil
	case attendance.FieldState:
		v, ok := value.(attendance.State)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetState(v)
		return nil
	}
	return fmt.Errorf("unknown Attendance field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AttendanceMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AttendanceMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AttendanceMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Attendance numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AttendanceMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AttendanceMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AttendanceMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Attendance nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AttendanceMutation) ResetField(name string) error {
	switch name {
	case attendance.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case attendance.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case attendance.FieldDate:
		m.ResetDate()
		return nil
	case attendance.FieldState:
		m.ResetState()
		return nil
	}
	return fmt.Errorf("unknown Attendance field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AttendanceMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.class != nil {
		edges = append(edges, attendance.EdgeClass)
	}
	if m.student != nil {
		edges = append(edges, attendance.EdgeStudent)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AttendanceMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case attendance.EdgeClass:
		if id := m.class; id != nil {
			return []ent.Value{*id}
		}
	case attendance.EdgeStudent:
		if id := m.student; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AttendanceMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AttendanceMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AttendanceMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedclass {
		edges = append(edges, attendance.EdgeClass)
	}
	if m.clearedstudent {
		edges = append(edges, attendance.EdgeStudent)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AttendanceMutation) EdgeCleared(name string) bool {
	switch name {
	case attendance.EdgeClass:
		return m.clearedclass
	case attendance.EdgeStudent:
		return m.clearedstudent
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AttendanceMutation) ClearEdge(name string) error {
	switch name {
	case attendance.EdgeClass:
		m.ClearClass()
		return nil
	case attendance.EdgeStudent:
		m.ClearStudent()
		return nil
	}
	return fmt.Errorf("unknown Attendance unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AttendanceMutation) ResetEdge(name string) error {
	switch name {
	case attendance.EdgeClass:
		m.ResetClass()
		return nil
	case attendance.EdgeStudent:
		m.ResetStudent()
		return nil
	}
	return fmt.Errorf("unknown Attendance edge %s", name)
}

// ClassMutation represents an operation that mutates the Class nodes in the graph.
type ClassMutation struct {
	config
	op                 Op
	typ                string
	id                 *int
	created_at         *time.Time
	updated_at         *time.Time
	name               *string
	status             *schema.Status
	clearedFields      map[string]struct{}
	stage              *int
	clearedstage       bool
	teacher            *int
	clearedteacher     bool
	group              *int
	clearedgroup       bool
	assignments        map[int]struct{}
	removedassignments map[int]struct{}
	clearedassignments bool
	attendances        map[int]struct{}
	removedattendances map[int]struct{}
	clearedattendances bool
	schedules          map[int]struct{}
	removedschedules   map[int]struct{}
	clearedschedules   bool
	done               bool
	oldValue           func(context.Context) (*Class, error)
	predicates         []predicate.Class
}

var _ ent.Mutation = (*ClassMutation)(nil)

// classOption allows management of the mutation configuration using functional options.
type classOption func(*ClassMutation)

// newClassMutation creates new mutation for the Class entity.
func newClassMutation(c config, op Op, opts ...classOption) *ClassMutation {
	m := &ClassMutation{
		config:        c,
		op:            op,
		typ:           TypeClass,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withClassID sets the ID field of the mutation.
func withClassID(id int) classOption {
	return func(m *ClassMutation) {
		var (
			err   error
			once  sync.Once
			value *Class
		)
		m.oldValue = func(ctx context.Context) (*Class, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Class.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withClass sets the old Class of the mutation.
func withClass(node *Class) classOption {
	return func(m *ClassMutation) {
		m.oldValue = func(context.Context) (*Class, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ClassMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ClassMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ClassMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreatedAt sets the "created_at" field.
func (m *ClassMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ClassMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Class entity.
// If the Class object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ClassMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ClassMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ClassMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ClassMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Class entity.
// If the Class object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ClassMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ClassMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetName sets the "name" field.
func (m *ClassMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ClassMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Class entity.
// If the Class object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ClassMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ClassMutation) ResetName() {
	m.name = nil
}

// SetStatus sets the "status" field.
func (m *ClassMutation) SetStatus(s schema.Status) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *ClassMutation) Status() (r schema.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Class entity.
// If the Class object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ClassMutation) OldStatus(ctx context.Context) (v schema.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *ClassMutation) ResetStatus() {
	m.status = nil
}

// SetStageID sets the "stage" edge to the Stage entity by id.
func (m *ClassMutation) SetStageID(id int) {
	m.stage = &id
}

// ClearStage clears the "stage" edge to the Stage entity.
func (m *ClassMutation) ClearStage() {
	m.clearedstage = true
}

// StageCleared reports if the "stage" edge to the Stage entity was cleared.
func (m *ClassMutation) StageCleared() bool {
	return m.clearedstage
}

// StageID returns the "stage" edge ID in the mutation.
func (m *ClassMutation) StageID() (id int, exists bool) {
	if m.stage != nil {
		return *m.stage, true
	}
	return
}

// StageIDs returns the "stage" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// StageID instead. It exists only for internal usage by the builders.
func (m *ClassMutation) StageIDs() (ids []int) {
	if id := m.stage; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetStage resets all changes to the "stage" edge.
func (m *ClassMutation) ResetStage() {
	m.stage = nil
	m.clearedstage = false
}

// SetTeacherID sets the "teacher" edge to the User entity by id.
func (m *ClassMutation) SetTeacherID(id int) {
	m.teacher = &id
}

// ClearTeacher clears the "teacher" edge to the User entity.
func (m *ClassMutation) ClearTeacher() {
	m.clearedteacher = true
}

// TeacherCleared reports if the "teacher" edge to the User entity was cleared.
func (m *ClassMutation) TeacherCleared() bool {
	return m.clearedteacher
}

// TeacherID returns the "teacher" edge ID in the mutation.
func (m *ClassMutation) TeacherID() (id int, exists bool) {
	if m.teacher != nil {
		return *m.teacher, true
	}
	return
}

// TeacherIDs returns the "teacher" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TeacherID instead. It exists only for internal usage by the builders.
func (m *ClassMutation) TeacherIDs() (ids []int) {
	if id := m.teacher; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTeacher resets all changes to the "teacher" edge.
func (m *ClassMutation) ResetTeacher() {
	m.teacher = nil
	m.clearedteacher = false
}

// SetGroupID sets the "group" edge to the Group entity by id.
func (m *ClassMutation) SetGroupID(id int) {
	m.group = &id
}

// ClearGroup clears the "group" edge to the Group entity.
func (m *ClassMutation) ClearGroup() {
	m.clearedgroup = true
}

// GroupCleared reports if the "group" edge to the Group entity was cleared.
func (m *ClassMutation) GroupCleared() bool {
	return m.clearedgroup
}

// GroupID returns the "group" edge ID in the mutation.
func (m *ClassMutation) GroupID() (id int, exists bool) {
	if m.group != nil {
		return *m.group, true
	}
	return
}

// GroupIDs returns the "group" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// GroupID instead. It exists only for internal usage by the builders.
func (m *ClassMutation) GroupIDs() (ids []int) {
	if id := m.group; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetGroup resets all changes to the "group" edge.
func (m *ClassMutation) ResetGroup() {
	m.group = nil
	m.clearedgroup = false
}

// AddAssignmentIDs adds the "assignments" edge to the Assignment entity by ids.
func (m *ClassMutation) AddAssignmentIDs(ids ...int) {
	if m.assignments == nil {
		m.assignments = make(map[int]struct{})
	}
	for i := range ids {
		m.assignments[ids[i]] = struct{}{}
	}
}

// ClearAssignments clears the "assignments" edge to the Assignment entity.
func (m *ClassMutation) ClearAssignments() {
	m.clearedassignments = true
}

// AssignmentsCleared reports if the "assignments" edge to the Assignment entity was cleared.
func (m *ClassMutation) AssignmentsCleared() bool {
	return m.clearedassignments
}

// RemoveAssignmentIDs removes the "assignments" edge to the Assignment entity by IDs.
func (m *ClassMutation) RemoveAssignmentIDs(ids ...int) {
	if m.removedassignments == nil {
		m.removedassignments = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.assignments, ids[i])
		m.removedassignments[ids[i]] = struct{}{}
	}
}

// RemovedAssignments returns the removed IDs of the "assignments" edge to the Assignment entity.
func (m *ClassMutation) RemovedAssignmentsIDs() (ids []int) {
	for id := range m.removedassignments {
		ids = append(ids, id)
	}
	return
}

// AssignmentsIDs returns the "assignments" edge IDs in the mutation.
func (m *ClassMutation) AssignmentsIDs() (ids []int) {
	for id := range m.assignments {
		ids = append(ids, id)
	}
	return
}

// ResetAssignments resets all changes to the "assignments" edge.
func (m *ClassMutation) ResetAssignments() {
	m.assignments = nil
	m.clearedassignments = false
	m.removedassignments = nil
}

// AddAttendanceIDs adds the "attendances" edge to the Attendance entity by ids.
func (m *ClassMutation) AddAttendanceIDs(ids ...int) {
	if m.attendances == nil {
		m.attendances = make(map[int]struct{})
	}
	for i := range ids {
		m.attendances[ids[i]] = struct{}{}
	}
}

// ClearAttendances clears the "attendances" edge to the Attendance entity.
func (m *ClassMutation) ClearAttendances() {
	m.clearedattendances = true
}

// AttendancesCleared reports if the "attendances" edge to the Attendance entity was cleared.
func (m *ClassMutation) AttendancesCleared() bool {
	return m.clearedattendances
}

// RemoveAttendanceIDs removes the "attendances" edge to the Attendance entity by IDs.
func (m *ClassMutation) RemoveAttendanceIDs(ids ...int) {
	if m.removedattendances == nil {
		m.removedattendances = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.attendances, ids[i])
		m.removedattendances[ids[i]] = struct{}{}
	}
}

// RemovedAttendances returns the removed IDs of the "attendances" edge to the Attendance entity.
func (m *ClassMutation) RemovedAttendancesIDs() (ids []int) {
	for id := range m.removedattendances {
		ids = append(ids, id)
	}
	return
}

// AttendancesIDs returns the "attendances" edge IDs in the mutation.
func (m *ClassMutation) AttendancesIDs() (ids []int) {
	for id := range m.attendances {
		ids = append(ids, id)
	}
	return
}

// ResetAttendances resets all changes to the "attendances" edge.
func (m *ClassMutation) ResetAttendances() {
	m.attendances = nil
	m.clearedattendances = false
	m.removedattendances = nil
}

// AddScheduleIDs adds the "schedules" edge to the Schedule entity by ids.
func (m *ClassMutation) AddScheduleIDs(ids ...int) {
	if m.schedules == nil {
		m.schedules = make(map[int]struct{})
	}
	for i := range ids {
		m.schedules[ids[i]] = struct{}{}
	}
}

// ClearSchedules clears the "schedules" edge to the Schedule entity.
func (m *ClassMutation) ClearSchedules() {
	m.clearedschedules = true
}

// SchedulesCleared reports if the "schedules" edge to the Schedule entity was cleared.
func (m *ClassMutation) SchedulesCleared() bool {
	return m.clearedschedules
}

// RemoveScheduleIDs removes the "schedules" edge to the Schedule entity by IDs.
func (m *ClassMutation) RemoveScheduleIDs(ids ...int) {
	if m.removedschedules == nil {
		m.removedschedules = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.schedules, ids[i])
		m.removedschedules[ids[i]] = struct{}{}
	}
}

// RemovedSchedules returns the removed IDs of the "schedules" edge to the Schedule entity.
func (m *ClassMutation) RemovedSchedulesIDs() (ids []int) {
	for id := range m.removedschedules {
		ids = append(ids, id)
	}
	return
}

// SchedulesIDs returns the "schedules" edge IDs in the mutation.
func (m *ClassMutation) SchedulesIDs() (ids []int) {
	for id := range m.schedules {
		ids = append(ids, id)
	}
	return
}

// ResetSchedules resets all changes to the "schedules" edge.
func (m *ClassMutation) ResetSchedules() {
	m.schedules = nil
	m.clearedschedules = false
	m.removedschedules = nil
}

// Where appends a list predicates to the ClassMutation builder.
func (m *ClassMutation) Where(ps ...predicate.Class) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *ClassMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Class).
func (m *ClassMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ClassMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.created_at != nil {
		fields = append(fields, class.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, class.FieldUpdatedAt)
	}
	if m.name != nil {
		fields = append(fields, class.FieldName)
	}
	if m.status != nil {
		fields = append(fields, class.FieldStatus)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ClassMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case class.FieldCreatedAt:
		return m.CreatedAt()
	case class.FieldUpdatedAt:
		return m.UpdatedAt()
	case class.FieldName:
		return m.Name()
	case class.FieldStatus:
		return m.Status()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ClassMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case class.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case class.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case class.FieldName:
		return m.OldName(ctx)
	case class.FieldStatus:
		return m.OldStatus(ctx)
	}
	return nil, fmt.Errorf("unknown Class field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ClassMutation) SetField(name string, value ent.Value) error {
	switch name {
	case class.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case class.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case class.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case class.FieldStatus:
		v, ok := value.(schema.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	}
	return fmt.Errorf("unknown Class field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ClassMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ClassMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ClassMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Class numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ClassMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ClassMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ClassMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Class nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ClassMutation) ResetField(name string) error {
	switch name {
	case class.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case class.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case class.FieldName:
		m.ResetName()
		return nil
	case class.FieldStatus:
		m.ResetStatus()
		return nil
	}
	return fmt.Errorf("unknown Class field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ClassMutation) AddedEdges() []string {
	edges := make([]string, 0, 6)
	if m.stage != nil {
		edges = append(edges, class.EdgeStage)
	}
	if m.teacher != nil {
		edges = append(edges, class.EdgeTeacher)
	}
	if m.group != nil {
		edges = append(edges, class.EdgeGroup)
	}
	if m.assignments != nil {
		edges = append(edges, class.EdgeAssignments)
	}
	if m.attendances != nil {
		edges = append(edges, class.EdgeAttendances)
	}
	if m.schedules != nil {
		edges = append(edges, class.EdgeSchedules)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ClassMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case class.EdgeStage:
		if id := m.stage; id != nil {
			return []ent.Value{*id}
		}
	case class.EdgeTeacher:
		if id := m.teacher; id != nil {
			return []ent.Value{*id}
		}
	case class.EdgeGroup:
		if id := m.group; id != nil {
			return []ent.Value{*id}
		}
	case class.EdgeAssignments:
		ids := make([]ent.Value, 0, len(m.assignments))
		for id := range m.assignments {
			ids = append(ids, id)
		}
		return ids
	case class.EdgeAttendances:
		ids := make([]ent.Value, 0, len(m.attendances))
		for id := range m.attendances {
			ids = append(ids, id)
		}
		return ids
	case class.EdgeSchedules:
		ids := make([]ent.Value, 0, len(m.schedules))
		for id := range m.schedules {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ClassMutation) RemovedEdges() []string {
	edges := make([]string, 0, 6)
	if m.removedassignments != nil {
		edges = append(edges, class.EdgeAssignments)
	}
	if m.removedattendances != nil {
		edges = append(edges, class.EdgeAttendances)
	}
	if m.removedschedules != nil {
		edges = append(edges, class.EdgeSchedules)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ClassMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case class.EdgeAssignments:
		ids := make([]ent.Value, 0, len(m.removedassignments))
		for id := range m.removedassignments {
			ids = append(ids, id)
		}
		return ids
	case class.EdgeAttendances:
		ids := make([]ent.Value, 0, len(m.removedattendances))
		for id := range m.removedattendances {
			ids = append(ids, id)
		}
		return ids
	case class.EdgeSchedules:
		ids := make([]ent.Value, 0, len(m.removedschedules))
		for id := range m.removedschedules {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ClassMutation) ClearedEdges() []string {
	edges := make([]string, 0, 6)
	if m.clearedstage {
		edges = append(edges, class.EdgeStage)
	}
	if m.clearedteacher {
		edges = append(edges, class.EdgeTeacher)
	}
	if m.clearedgroup {
		edges = append(edges, class.EdgeGroup)
	}
	if m.clearedassignments {
		edges = append(edges, class.EdgeAssignments)
	}
	if m.clearedattendances {
		edges = append(edges, class.EdgeAttendances)
	}
	if m.clearedschedules {
		edges = append(edges, class.EdgeSchedules)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ClassMutation) EdgeCleared(name string) bool {
	switch name {
	case class.EdgeStage:
		return m.clearedstage
	case class.EdgeTeacher:
		return m.clearedteacher
	case class.EdgeGroup:
		return m.clearedgroup
	case class.EdgeAssignments:
		return m.clearedassignments
	case class.EdgeAttendances:
		return m.clearedattendances
	case class.EdgeSchedules:
		return m.clearedschedules
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ClassMutation) ClearEdge(name string) error {
	switch name {
	case class.EdgeStage:
		m.ClearStage()
		return nil
	case class.EdgeTeacher:
		m.ClearTeacher()
		return nil
	case class.EdgeGroup:
		m.ClearGroup()
		return nil
	}
	return fmt.Errorf("unknown Class unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ClassMutation) ResetEdge(name string) error {
	switch name {
	case class.EdgeStage:
		m.ResetStage()
		return nil
	case class.EdgeTeacher:
		m.ResetTeacher()
		return nil
	case class.EdgeGroup:
		m.ResetGroup()
		return nil
	case class.EdgeAssignments:
		m.ResetAssignments()
		return nil
	case class.EdgeAttendances:
		m.ResetAttendances()
		return nil
	case class.EdgeSchedules:
		m.ResetSchedules()
		return nil
	}
	return fmt.Errorf("unknown Class edge %s", name)
}

// GradeMutation represents an operation that mutates the Grade nodes in the graph.
type GradeMutation struct {
	config
	op             Op
	typ            string
	id             *int
	created_at     *time.Time
	updated_at     *time.Time
	exam_grade     *float64
	addexam_grade  *float64
	clearedFields  map[string]struct{}
	student        *int
	clearedstudent bool
	exam           *int
	clearedexam    bool
	done           bool
	oldValue       func(context.Context) (*Grade, error)
	predicates     []predicate.Grade
}

var _ ent.Mutation = (*GradeMutation)(nil)

// gradeOption allows management of the mutation configuration using functional options.
type gradeOption func(*GradeMutation)

// newGradeMutation creates new mutation for the Grade entity.
func newGradeMutation(c config, op Op, opts ...gradeOption) *GradeMutation {
	m := &GradeMutation{
		config:        c,
		op:            op,
		typ:           TypeGrade,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withGradeID sets the ID field of the mutation.
func withGradeID(id int) gradeOption {
	return func(m *GradeMutation) {
		var (
			err   error
			once  sync.Once
			value *Grade
		)
		m.oldValue = func(ctx context.Context) (*Grade, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Grade.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withGrade sets the old Grade of the mutation.
func withGrade(node *Grade) gradeOption {
	return func(m *GradeMutation) {
		m.oldValue = func(context.Context) (*Grade, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m GradeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m GradeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *GradeMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreatedAt sets the "created_at" field.
func (m *GradeMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *GradeMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Grade entity.
// If the Grade object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GradeMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *GradeMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *GradeMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *GradeMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Grade entity.
// If the Grade object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GradeMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *GradeMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetExamGrade sets the "exam_grade" field.
func (m *GradeMutation) SetExamGrade(f float64) {
	m.exam_grade = &f
	m.addexam_grade = nil
}

// ExamGrade returns the value of the "exam_grade" field in the mutation.
func (m *GradeMutation) ExamGrade() (r float64, exists bool) {
	v := m.exam_grade
	if v == nil {
		return
	}
	return *v, true
}

// OldExamGrade returns the old "exam_grade" field's value of the Grade entity.
// If the Grade object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GradeMutation) OldExamGrade(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldExamGrade is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldExamGrade requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExamGrade: %w", err)
	}
	return oldValue.ExamGrade, nil
}

// AddExamGrade adds f to the "exam_grade" field.
func (m *GradeMutation) AddExamGrade(f float64) {
	if m.addexam_grade != nil {
		*m.addexam_grade += f
	} else {
		m.addexam_grade = &f
	}
}

// AddedExamGrade returns the value that was added to the "exam_grade" field in this mutation.
func (m *GradeMutation) AddedExamGrade() (r float64, exists bool) {
	v := m.addexam_grade
	if v == nil {
		return
	}
	return *v, true
}

// ResetExamGrade resets all changes to the "exam_grade" field.
func (m *GradeMutation) ResetExamGrade() {
	m.exam_grade = nil
	m.addexam_grade = nil
}

// SetStudentID sets the "student" edge to the User entity by id.
func (m *GradeMutation) SetStudentID(id int) {
	m.student = &id
}

// ClearStudent clears the "student" edge to the User entity.
func (m *GradeMutation) ClearStudent() {
	m.clearedstudent = true
}

// StudentCleared reports if the "student" edge to the User entity was cleared.
func (m *GradeMutation) StudentCleared() bool {
	return m.clearedstudent
}

// StudentID returns the "student" edge ID in the mutation.
func (m *GradeMutation) StudentID() (id int, exists bool) {
	if m.student != nil {
		return *m.student, true
	}
	return
}

// StudentIDs returns the "student" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// StudentID instead. It exists only for internal usage by the builders.
func (m *GradeMutation) StudentIDs() (ids []int) {
	if id := m.student; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetStudent resets all changes to the "student" edge.
func (m *GradeMutation) ResetStudent() {
	m.student = nil
	m.clearedstudent = false
}

// SetExamID sets the "exam" edge to the Assignment entity by id.
func (m *GradeMutation) SetExamID(id int) {
	m.exam = &id
}

// ClearExam clears the "exam" edge to the Assignment entity.
func (m *GradeMutation) ClearExam() {
	m.clearedexam = true
}

// ExamCleared reports if the "exam" edge to the Assignment entity was cleared.
func (m *GradeMutation) ExamCleared() bool {
	return m.clearedexam
}

// ExamID returns the "exam" edge ID in the mutation.
func (m *GradeMutation) ExamID() (id int, exists bool) {
	if m.exam != nil {
		return *m.exam, true
	}
	return
}

// ExamIDs returns the "exam" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ExamID instead. It exists only for internal usage by the builders.
func (m *GradeMutation) ExamIDs() (ids []int) {
	if id := m.exam; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetExam resets all changes to the "exam" edge.
func (m *GradeMutation) ResetExam() {
	m.exam = nil
	m.clearedexam = false
}

// Where appends a list predicates to the GradeMutation builder.
func (m *GradeMutation) Where(ps ...predicate.Grade) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *GradeMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Grade).
func (m *GradeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *GradeMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.created_at != nil {
		fields = append(fields, grade.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, grade.FieldUpdatedAt)
	}
	if m.exam_grade != nil {
		fields = append(fields, grade.FieldExamGrade)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *GradeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case grade.FieldCreatedAt:
		return m.CreatedAt()
	case grade.FieldUpdatedAt:
		return m.UpdatedAt()
	case grade.FieldExamGrade:
		return m.ExamGrade()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *GradeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case grade.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case grade.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case grade.FieldExamGrade:
		return m.OldExamGrade(ctx)
	}
	return nil, fmt.Errorf("unknown Grade field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GradeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case grade.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case grade.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case grade.FieldExamGrade:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExamGrade(v)
		return nil
	}
	return fmt.Errorf("unknown Grade field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *GradeMutation) AddedFields() []string {
	var fields []string
	if m.addexam_grade != nil {
		fields = append(fields, grade.FieldExamGrade)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *GradeMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case grade.FieldExamGrade:
		return m.AddedExamGrade()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GradeMutation) AddField(name string, value ent.Value) error {
	switch name {
	case grade.FieldExamGrade:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddExamGrade(v)
		return nil
	}
	return fmt.Errorf("unknown Grade numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *GradeMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *GradeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *GradeMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Grade nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *GradeMutation) ResetField(name string) error {
	switch name {
	case grade.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case grade.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case grade.FieldExamGrade:
		m.ResetExamGrade()
		return nil
	}
	return fmt.Errorf("unknown Grade field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *GradeMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.student != nil {
		edges = append(edges, grade.EdgeStudent)
	}
	if m.exam != nil {
		edges = append(edges, grade.EdgeExam)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *GradeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case grade.EdgeStudent:
		if id := m.student; id != nil {
			return []ent.Value{*id}
		}
	case grade.EdgeExam:
		if id := m.exam; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *GradeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *GradeMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *GradeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedstudent {
		edges = append(edges, grade.EdgeStudent)
	}
	if m.clearedexam {
		edges = append(edges, grade.EdgeExam)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *GradeMutation) EdgeCleared(name string) bool {
	switch name {
	case grade.EdgeStudent:
		return m.clearedstudent
	case grade.EdgeExam:
		return m.clearedexam
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *GradeMutation) ClearEdge(name string) error {
	switch name {
	case grade.EdgeStudent:
		m.ClearStudent()
		return nil
	case grade.EdgeExam:
		m.ClearExam()
		return nil
	}
	return fmt.Errorf("unknown Grade unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *GradeMutation) ResetEdge(name string) error {
	switch name {
	case grade.EdgeStudent:
		m.ResetStudent()
		return nil
	case grade.EdgeExam:
		m.ResetExam()
		return nil
	}
	return fmt.Errorf("unknown Grade edge %s", name)
}

// GroupMutation represents an operation that mutates the Group nodes in the graph.
type GroupMutation struct {
	config
	op              Op
	typ             string
	id              *int
	created_at      *time.Time
	updated_at      *time.Time
	name            *string
	_type           *group.Type
	status          *schema.Status
	clearedFields   map[string]struct{}
	class           *int
	clearedclass    bool
	messages        map[int]struct{}
	removedmessages map[int]struct{}
	clearedmessages bool
	done            bool
	oldValue        func(context.Context) (*Group, error)
	predicates      []predicate.Group
}

var _ ent.Mutation = (*GroupMutation)(nil)

// groupOption allows management of the mutation configuration using functional options.
type groupOption func(*GroupMutation)

// newGroupMutation creates new mutation for the Group entity.
func newGroupMutation(c config, op Op, opts ...groupOption) *GroupMutation {
	m := &GroupMutation{
		config:        c,
		op:            op,
		typ:           TypeGroup,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withGroupID sets the ID field of the mutation.
func withGroupID(id int) groupOption {
	return func(m *GroupMutation) {
		var (
			err   error
			once  sync.Once
			value *Group
		)
		m.oldValue = func(ctx context.Context) (*Group, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Group.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withGroup sets the old Group of the mutation.
func withGroup(node *Group) groupOption {
	return func(m *GroupMutation) {
		m.oldValue = func(context.Context) (*Group, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m GroupMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m GroupMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *GroupMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreatedAt sets the "created_at" field.
func (m *GroupMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *GroupMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Group entity.
// If the Group object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroupMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *GroupMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *GroupMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *GroupMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Group entity.
// If the Group object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroupMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *GroupMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetName sets the "name" field.
func (m *GroupMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *GroupMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Group entity.
// If the Group object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroupMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ClearName clears the value of the "name" field.
func (m *GroupMutation) ClearName() {
	m.name = nil
	m.clearedFields[group.FieldName] = struct{}{}
}

// NameCleared returns if the "name" field was cleared in this mutation.
func (m *GroupMutation) NameCleared() bool {
	_, ok := m.clearedFields[group.FieldName]
	return ok
}

// ResetName resets all changes to the "name" field.
func (m *GroupMutation) ResetName() {
	m.name = nil
	delete(m.clearedFields, group.FieldName)
}

// SetType sets the "type" field.
func (m *GroupMutation) SetType(gr group.Type) {
	m._type = &gr
}

// GetType returns the value of the "type" field in the mutation.
func (m *GroupMutation) GetType() (r group.Type, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Group entity.
// If the Group object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroupMutation) OldType(ctx context.Context) (v group.Type, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *GroupMutation) ResetType() {
	m._type = nil
}

// SetStatus sets the "status" field.
func (m *GroupMutation) SetStatus(s schema.Status) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *GroupMutation) Status() (r schema.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Group entity.
// If the Group object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroupMutation) OldStatus(ctx context.Context) (v schema.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *GroupMutation) ResetStatus() {
	m.status = nil
}

// SetClassID sets the "class" edge to the Class entity by id.
func (m *GroupMutation) SetClassID(id int) {
	m.class = &id
}

// ClearClass clears the "class" edge to the Class entity.
func (m *GroupMutation) ClearClass() {
	m.clearedclass = true
}

// ClassCleared reports if the "class" edge to the Class entity was cleared.
func (m *GroupMutation) ClassCleared() bool {
	return m.clearedclass
}

// ClassID returns the "class" edge ID in the mutation.
func (m *GroupMutation) ClassID() (id int, exists bool) {
	if m.class != nil {
		return *m.class, true
	}
	return
}

// ClassIDs returns the "class" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ClassID instead. It exists only for internal usage by the builders.
func (m *GroupMutation) ClassIDs() (ids []int) {
	if id := m.class; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetClass resets all changes to the "class" edge.
func (m *GroupMutation) ResetClass() {
	m.class = nil
	m.clearedclass = false
}

// AddMessageIDs adds the "messages" edge to the Message entity by ids.
func (m *GroupMutation) AddMessageIDs(ids ...int) {
	if m.messages == nil {
		m.messages = make(map[int]struct{})
	}
	for i := range ids {
		m.messages[ids[i]] = struct{}{}
	}
}

// ClearMessages clears the "messages" edge to the Message entity.
func (m *GroupMutation) ClearMessages() {
	m.clearedmessages = true
}

// MessagesCleared reports if the "messages" edge to the Message entity was cleared.
func (m *GroupMutation) MessagesCleared() bool {
	return m.clearedmessages
}

// RemoveMessageIDs removes the "messages" edge to the Message entity by IDs.
func (m *GroupMutation) RemoveMessageIDs(ids ...int) {
	if m.removedmessages == nil {
		m.removedmessages = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.messages, ids[i])
		m.removedmessages[ids[i]] = struct{}{}
	}
}

// RemovedMessages returns the removed IDs of the "messages" edge to the Message entity.
func (m *GroupMutation) RemovedMessagesIDs() (ids []int) {
	for id := range m.removedmessages {
		ids = append(ids, id)
	}
	return
}

// MessagesIDs returns the "messages" edge IDs in the mutation.
func (m *GroupMutation) MessagesIDs() (ids []int) {
	for id := range m.messages {
		ids = append(ids, id)
	}
	return
}

// ResetMessages resets all changes to the "messages" edge.
func (m *GroupMutation) ResetMessages() {
	m.messages = nil
	m.clearedmessages = false
	m.removedmessages = nil
}

// Where appends a list predicates to the GroupMutation builder.
func (m *GroupMutation) Where(ps ...predicate.Group) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *GroupMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Group).
func (m *GroupMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *GroupMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.created_at != nil {
		fields = append(fields, group.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, group.FieldUpdatedAt)
	}
	if m.name != nil {
		fields = append(fields, group.FieldName)
	}
	if m._type != nil {
		fields = append(fields, group.FieldType)
	}
	if m.status != nil {
		fields = append(fields, group.FieldStatus)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *GroupMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case group.FieldCreatedAt:
		return m.CreatedAt()
	case group.FieldUpdatedAt:
		return m.UpdatedAt()
	case group.FieldName:
		return m.Name()
	case group.FieldType:
		return m.GetType()
	case group.FieldStatus:
		return m.Status()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *GroupMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case group.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case group.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case group.FieldName:
		return m.OldName(ctx)
	case group.FieldType:
		return m.OldType(ctx)
	case group.FieldStatus:
		return m.OldStatus(ctx)
	}
	return nil, fmt.Errorf("unknown Group field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GroupMutation) SetField(name string, value ent.Value) error {
	switch name {
	case group.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case group.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case group.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case group.FieldType:
		v, ok := value.(group.Type)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case group.FieldStatus:
		v, ok := value.(schema.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	}
	return fmt.Errorf("unknown Group field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *GroupMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *GroupMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GroupMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Group numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *GroupMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(group.FieldName) {
		fields = append(fields, group.FieldName)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *GroupMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *GroupMutation) ClearField(name string) error {
	switch name {
	case group.FieldName:
		m.ClearName()
		return nil
	}
	return fmt.Errorf("unknown Group nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *GroupMutation) ResetField(name string) error {
	switch name {
	case group.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case group.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case group.FieldName:
		m.ResetName()
		return nil
	case group.FieldType:
		m.ResetType()
		return nil
	case group.FieldStatus:
		m.ResetStatus()
		return nil
	}
	return fmt.Errorf("unknown Group field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *GroupMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.class != nil {
		edges = append(edges, group.EdgeClass)
	}
	if m.messages != nil {
		edges = append(edges, group.EdgeMessages)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *GroupMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case group.EdgeClass:
		if id := m.class; id != nil {
			return []ent.Value{*id}
		}
	case group.EdgeMessages:
		ids := make([]ent.Value, 0, len(m.messages))
		for id := range m.messages {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *GroupMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedmessages != nil {
		edges = append(edges, group.EdgeMessages)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *GroupMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case group.EdgeMessages:
		ids := make([]ent.Value, 0, len(m.removedmessages))
		for id := range m.removedmessages {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *GroupMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedclass {
		edges = append(edges, group.EdgeClass)
	}
	if m.clearedmessages {
		edges = append(edges, group.EdgeMessages)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *GroupMutation) EdgeCleared(name string) bool {
	switch name {
	case group.EdgeClass:
		return m.clearedclass
	case group.EdgeMessages:
		return m.clearedmessages
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *GroupMutation) ClearEdge(name string) error {
	switch name {
	case group.EdgeClass:
		m.ClearClass()
		return nil
	}
	return fmt.Errorf("unknown Group unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *GroupMutation) ResetEdge(name string) error {
	switch name {
	case group.EdgeClass:
		m.ResetClass()
		return nil
	case group.EdgeMessages:
		m.ResetMessages()
		return nil
	}
	return fmt.Errorf("unknown Group edge %s", name)
}

// MessageMutation represents an operation that mutates the Message nodes in the graph.
type MessageMutation struct {
	config
	op            Op
	typ           string
	id            *int
	created_at    *time.Time
	updated_at    *time.Time
	content       *string
	attachment    *string
	deleted_at    *time.Time
	clearedFields map[string]struct{}
	group         *int
	clearedgroup  bool
	owner         *int
	clearedowner  bool
	done          bool
	oldValue      func(context.Context) (*Message, error)
	predicates    []predicate.Message
}

var _ ent.Mutation = (*MessageMutation)(nil)

// messageOption allows management of the mutation configuration using functional options.
type messageOption func(*MessageMutation)

// newMessageMutation creates new mutation for the Message entity.
func newMessageMutation(c config, op Op, opts ...messageOption) *MessageMutation {
	m := &MessageMutation{
		config:        c,
		op:            op,
		typ:           TypeMessage,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMessageID sets the ID field of the mutation.
func withMessageID(id int) messageOption {
	return func(m *MessageMutation) {
		var (
			err   error
			once  sync.Once
			value *Message
		)
		m.oldValue = func(ctx context.Context) (*Message, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Message.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMessage sets the old Message of the mutation.
func withMessage(node *Message) messageOption {
	return func(m *MessageMutation) {
		m.oldValue = func(context.Context) (*Message, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MessageMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MessageMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *MessageMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreatedAt sets the "created_at" field.
func (m *MessageMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *MessageMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Message entity.
// If the Message object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MessageMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *MessageMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *MessageMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *MessageMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Message entity.
// If the Message object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MessageMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *MessageMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetContent sets the "content" field.
func (m *MessageMutation) SetContent(s string) {
	m.content = &s
}

// Content returns the value of the "content" field in the mutation.
func (m *MessageMutation) Content() (r string, exists bool) {
	v := m.content
	if v == nil {
		return
	}
	return *v, true
}

// OldContent returns the old "content" field's value of the Message entity.
// If the Message object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MessageMutation) OldContent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldContent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldContent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContent: %w", err)
	}
	return oldValue.Content, nil
}

// ClearContent clears the value of the "content" field.
func (m *MessageMutation) ClearContent() {
	m.content = nil
	m.clearedFields[message.FieldContent] = struct{}{}
}

// ContentCleared returns if the "content" field was cleared in this mutation.
func (m *MessageMutation) ContentCleared() bool {
	_, ok := m.clearedFields[message.FieldContent]
	return ok
}

// ResetContent resets all changes to the "content" field.
func (m *MessageMutation) ResetContent() {
	m.content = nil
	delete(m.clearedFields, message.FieldContent)
}

// SetAttachment sets the "attachment" field.
func (m *MessageMutation) SetAttachment(s string) {
	m.attachment = &s
}

// Attachment returns the value of the "attachment" field in the mutation.
func (m *MessageMutation) Attachment() (r string, exists bool) {
	v := m.attachment
	if v == nil {
		return
	}
	return *v, true
}

// OldAttachment returns the old "attachment" field's value of the Message entity.
// If the Message object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MessageMutation) OldAttachment(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAttachment is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAttachment requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAttachment: %w", err)
	}
	return oldValue.Attachment, nil
}

// ClearAttachment clears the value of the "attachment" field.
func (m *MessageMutation) ClearAttachment() {
	m.attachment = nil
	m.clearedFields[message.FieldAttachment] = struct{}{}
}

// AttachmentCleared returns if the "attachment" field was cleared in this mutation.
func (m *MessageMutation) AttachmentCleared() bool {
	_, ok := m.clearedFields[message.FieldAttachment]
	return ok
}

// ResetAttachment resets all changes to the "attachment" field.
func (m *MessageMutation) ResetAttachment() {
	m.attachment = nil
	delete(m.clearedFields, message.FieldAttachment)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *MessageMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *MessageMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Message entity.
// If the Message object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MessageMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *MessageMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[message.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *MessageMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[message.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *MessageMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, message.FieldDeletedAt)
}

// SetGroupID sets the "group" edge to the Group entity by id.
func (m *MessageMutation) SetGroupID(id int) {
	m.group = &id
}

// ClearGroup clears the "group" edge to the Group entity.
func (m *MessageMutation) ClearGroup() {
	m.clearedgroup = true
}

// GroupCleared reports if the "group" edge to the Group entity was cleared.
func (m *MessageMutation) GroupCleared() bool {
	return m.clearedgroup
}

// GroupID returns the "group" edge ID in the mutation.
func (m *MessageMutation) GroupID() (id int, exists bool) {
	if m.group != nil {
		return *m.group, true
	}
	return
}

// GroupIDs returns the "group" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// GroupID instead. It exists only for internal usage by the builders.
func (m *MessageMutation) GroupIDs() (ids []int) {
	if id := m.group; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetGroup resets all changes to the "group" edge.
func (m *MessageMutation) ResetGroup() {
	m.group = nil
	m.clearedgroup = false
}

// SetOwnerID sets the "owner" edge to the User entity by id.
func (m *MessageMutation) SetOwnerID(id int) {
	m.owner = &id
}

// ClearOwner clears the "owner" edge to the User entity.
func (m *MessageMutation) ClearOwner() {
	m.clearedowner = true
}

// OwnerCleared reports if the "owner" edge to the User entity was cleared.
func (m *MessageMutation) OwnerCleared() bool {
	return m.clearedowner
}

// OwnerID returns the "owner" edge ID in the mutation.
func (m *MessageMutation) OwnerID() (id int, exists bool) {
	if m.owner != nil {
		return *m.owner, true
	}
	return
}

// OwnerIDs returns the "owner" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OwnerID instead. It exists only for internal usage by the builders.
func (m *MessageMutation) OwnerIDs() (ids []int) {
	if id := m.owner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOwner resets all changes to the "owner" edge.
func (m *MessageMutation) ResetOwner() {
	m.owner = nil
	m.clearedowner = false
}

// Where appends a list predicates to the MessageMutation builder.
func (m *MessageMutation) Where(ps ...predicate.Message) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *MessageMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Message).
func (m *MessageMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MessageMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.created_at != nil {
		fields = append(fields, message.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, message.FieldUpdatedAt)
	}
	if m.content != nil {
		fields = append(fields, message.FieldContent)
	}
	if m.attachment != nil {
		fields = append(fields, message.FieldAttachment)
	}
	if m.deleted_at != nil {
		fields = append(fields, message.FieldDeletedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MessageMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case message.FieldCreatedAt:
		return m.CreatedAt()
	case message.FieldUpdatedAt:
		return m.UpdatedAt()
	case message.FieldContent:
		return m.Content()
	case message.FieldAttachment:
		return m.Attachment()
	case message.FieldDeletedAt:
		return m.DeletedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MessageMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case message.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case message.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case message.FieldContent:
		return m.OldContent(ctx)
	case message.FieldAttachment:
		return m.OldAttachment(ctx)
	case message.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Message field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MessageMutation) SetField(name string, value ent.Value) error {
	switch name {
	case message.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case message.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case message.FieldContent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContent(v)
		return nil
	case message.FieldAttachment:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAttachment(v)
		return nil
	case message.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Message field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MessageMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MessageMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MessageMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Message numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MessageMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(message.FieldContent) {
		fields = append(fields, message.FieldContent)
	}
	if m.FieldCleared(message.FieldAttachment) {
		fields = append(fields, message.FieldAttachment)
	}
	if m.FieldCleared(message.FieldDeletedAt) {
		fields = append(fields, message.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MessageMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MessageMutation) ClearField(name string) error {
	switch name {
	case message.FieldContent:
		m.ClearContent()
		return nil
	case message.FieldAttachment:
		m.ClearAttachment()
		return nil
	case message.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown Message nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MessageMutation) ResetField(name string) error {
	switch name {
	case message.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case message.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case message.FieldContent:
		m.ResetContent()
		return nil
	case message.FieldAttachment:
		m.ResetAttachment()
		return nil
	case message.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown Message field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MessageMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.group != nil {
		edges = append(edges, message.EdgeGroup)
	}
	if m.owner != nil {
		edges = append(edges, message.EdgeOwner)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MessageMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case message.EdgeGroup:
		if id := m.group; id != nil {
			return []ent.Value{*id}
		}
	case message.EdgeOwner:
		if id := m.owner; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MessageMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MessageMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MessageMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedgroup {
		edges = append(edges, message.EdgeGroup)
	}
	if m.clearedowner {
		edges = append(edges, message.EdgeOwner)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MessageMutation) EdgeCleared(name string) bool {
	switch name {
	case message.EdgeGroup:
		return m.clearedgroup
	case message.EdgeOwner:
		return m.clearedowner
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MessageMutation) ClearEdge(name string) error {
	switch name {
	case message.EdgeGroup:
		m.ClearGroup()
		return nil
	case message.EdgeOwner:
		m.ClearOwner()
		return nil
	}
	return fmt.Errorf("unknown Message unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MessageMutation) ResetEdge(name string) error {
	switch name {
	case message.EdgeGroup:
		m.ResetGroup()
		return nil
	case message.EdgeOwner:
		m.ResetOwner()
		return nil
	}
	return fmt.Errorf("unknown Message edge %s", name)
}

// ScheduleMutation represents an operation that mutates the Schedule nodes in the graph.
type ScheduleMutation struct {
	config
	op            Op
	typ           string
	id            *int
	weekday       *uint8
	addweekday    *uint8
	starts_at     *time.Time
	duration      *int
	addduration   *int
	clearedFields map[string]struct{}
	class         *int
	clearedclass  bool
	done          bool
	oldValue      func(context.Context) (*Schedule, error)
	predicates    []predicate.Schedule
}

var _ ent.Mutation = (*ScheduleMutation)(nil)

// scheduleOption allows management of the mutation configuration using functional options.
type scheduleOption func(*ScheduleMutation)

// newScheduleMutation creates new mutation for the Schedule entity.
func newScheduleMutation(c config, op Op, opts ...scheduleOption) *ScheduleMutation {
	m := &ScheduleMutation{
		config:        c,
		op:            op,
		typ:           TypeSchedule,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withScheduleID sets the ID field of the mutation.
func withScheduleID(id int) scheduleOption {
	return func(m *ScheduleMutation) {
		var (
			err   error
			once  sync.Once
			value *Schedule
		)
		m.oldValue = func(ctx context.Context) (*Schedule, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Schedule.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSchedule sets the old Schedule of the mutation.
func withSchedule(node *Schedule) scheduleOption {
	return func(m *ScheduleMutation) {
		m.oldValue = func(context.Context) (*Schedule, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ScheduleMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ScheduleMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ScheduleMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetWeekday sets the "weekday" field.
func (m *ScheduleMutation) SetWeekday(u uint8) {
	m.weekday = &u
	m.addweekday = nil
}

// Weekday returns the value of the "weekday" field in the mutation.
func (m *ScheduleMutation) Weekday() (r uint8, exists bool) {
	v := m.weekday
	if v == nil {
		return
	}
	return *v, true
}

// OldWeekday returns the old "weekday" field's value of the Schedule entity.
// If the Schedule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScheduleMutation) OldWeekday(ctx context.Context) (v uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldWeekday is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldWeekday requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWeekday: %w", err)
	}
	return oldValue.Weekday, nil
}

// AddWeekday adds u to the "weekday" field.
func (m *ScheduleMutation) AddWeekday(u uint8) {
	if m.addweekday != nil {
		*m.addweekday += u
	} else {
		m.addweekday = &u
	}
}

// AddedWeekday returns the value that was added to the "weekday" field in this mutation.
func (m *ScheduleMutation) AddedWeekday() (r uint8, exists bool) {
	v := m.addweekday
	if v == nil {
		return
	}
	return *v, true
}

// ResetWeekday resets all changes to the "weekday" field.
func (m *ScheduleMutation) ResetWeekday() {
	m.weekday = nil
	m.addweekday = nil
}

// SetStartsAt sets the "starts_at" field.
func (m *ScheduleMutation) SetStartsAt(t time.Time) {
	m.starts_at = &t
}

// StartsAt returns the value of the "starts_at" field in the mutation.
func (m *ScheduleMutation) StartsAt() (r time.Time, exists bool) {
	v := m.starts_at
	if v == nil {
		return
	}
	return *v, true
}

// OldStartsAt returns the old "starts_at" field's value of the Schedule entity.
// If the Schedule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScheduleMutation) OldStartsAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStartsAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStartsAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartsAt: %w", err)
	}
	return oldValue.StartsAt, nil
}

// ResetStartsAt resets all changes to the "starts_at" field.
func (m *ScheduleMutation) ResetStartsAt() {
	m.starts_at = nil
}

// SetDuration sets the "duration" field.
func (m *ScheduleMutation) SetDuration(i int) {
	m.duration = &i
	m.addduration = nil
}

// Duration returns the value of the "duration" field in the mutation.
func (m *ScheduleMutation) Duration() (r int, exists bool) {
	v := m.duration
	if v == nil {
		return
	}
	return *v, true
}

// OldDuration returns the old "duration" field's value of the Schedule entity.
// If the Schedule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScheduleMutation) OldDuration(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDuration is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDuration requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDuration: %w", err)
	}
	return oldValue.Duration, nil
}

// AddDuration adds i to the "duration" field.
func (m *ScheduleMutation) AddDuration(i int) {
	if m.addduration != nil {
		*m.addduration += i
	} else {
		m.addduration = &i
	}
}

// AddedDuration returns the value that was added to the "duration" field in this mutation.
func (m *ScheduleMutation) AddedDuration() (r int, exists bool) {
	v := m.addduration
	if v == nil {
		return
	}
	return *v, true
}

// ResetDuration resets all changes to the "duration" field.
func (m *ScheduleMutation) ResetDuration() {
	m.duration = nil
	m.addduration = nil
}

// SetClassID sets the "class" edge to the Class entity by id.
func (m *ScheduleMutation) SetClassID(id int) {
	m.class = &id
}

// ClearClass clears the "class" edge to the Class entity.
func (m *ScheduleMutation) ClearClass() {
	m.clearedclass = true
}

// ClassCleared reports if the "class" edge to the Class entity was cleared.
func (m *ScheduleMutation) ClassCleared() bool {
	return m.clearedclass
}

// ClassID returns the "class" edge ID in the mutation.
func (m *ScheduleMutation) ClassID() (id int, exists bool) {
	if m.class != nil {
		return *m.class, true
	}
	return
}

// ClassIDs returns the "class" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ClassID instead. It exists only for internal usage by the builders.
func (m *ScheduleMutation) ClassIDs() (ids []int) {
	if id := m.class; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetClass resets all changes to the "class" edge.
func (m *ScheduleMutation) ResetClass() {
	m.class = nil
	m.clearedclass = false
}

// Where appends a list predicates to the ScheduleMutation builder.
func (m *ScheduleMutation) Where(ps ...predicate.Schedule) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *ScheduleMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Schedule).
func (m *ScheduleMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ScheduleMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.weekday != nil {
		fields = append(fields, schedule.FieldWeekday)
	}
	if m.starts_at != nil {
		fields = append(fields, schedule.FieldStartsAt)
	}
	if m.duration != nil {
		fields = append(fields, schedule.FieldDuration)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ScheduleMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case schedule.FieldWeekday:
		return m.Weekday()
	case schedule.FieldStartsAt:
		return m.StartsAt()
	case schedule.FieldDuration:
		return m.Duration()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ScheduleMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case schedule.FieldWeekday:
		return m.OldWeekday(ctx)
	case schedule.FieldStartsAt:
		return m.OldStartsAt(ctx)
	case schedule.FieldDuration:
		return m.OldDuration(ctx)
	}
	return nil, fmt.Errorf("unknown Schedule field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ScheduleMutation) SetField(name string, value ent.Value) error {
	switch name {
	case schedule.FieldWeekday:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWeekday(v)
		return nil
	case schedule.FieldStartsAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartsAt(v)
		return nil
	case schedule.FieldDuration:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDuration(v)
		return nil
	}
	return fmt.Errorf("unknown Schedule field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ScheduleMutation) AddedFields() []string {
	var fields []string
	if m.addweekday != nil {
		fields = append(fields, schedule.FieldWeekday)
	}
	if m.addduration != nil {
		fields = append(fields, schedule.FieldDuration)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ScheduleMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case schedule.FieldWeekday:
		return m.AddedWeekday()
	case schedule.FieldDuration:
		return m.AddedDuration()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ScheduleMutation) AddField(name string, value ent.Value) error {
	switch name {
	case schedule.FieldWeekday:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddWeekday(v)
		return nil
	case schedule.FieldDuration:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDuration(v)
		return nil
	}
	return fmt.Errorf("unknown Schedule numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ScheduleMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ScheduleMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ScheduleMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Schedule nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ScheduleMutation) ResetField(name string) error {
	switch name {
	case schedule.FieldWeekday:
		m.ResetWeekday()
		return nil
	case schedule.FieldStartsAt:
		m.ResetStartsAt()
		return nil
	case schedule.FieldDuration:
		m.ResetDuration()
		return nil
	}
	return fmt.Errorf("unknown Schedule field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ScheduleMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.class != nil {
		edges = append(edges, schedule.EdgeClass)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ScheduleMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case schedule.EdgeClass:
		if id := m.class; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ScheduleMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ScheduleMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ScheduleMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedclass {
		edges = append(edges, schedule.EdgeClass)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ScheduleMutation) EdgeCleared(name string) bool {
	switch name {
	case schedule.EdgeClass:
		return m.clearedclass
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ScheduleMutation) ClearEdge(name string) error {
	switch name {
	case schedule.EdgeClass:
		m.ClearClass()
		return nil
	}
	return fmt.Errorf("unknown Schedule unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ScheduleMutation) ResetEdge(name string) error {
	switch name {
	case schedule.EdgeClass:
		m.ResetClass()
		return nil
	}
	return fmt.Errorf("unknown Schedule edge %s", name)
}

// SchoolMutation represents an operation that mutates the School nodes in the graph.
type SchoolMutation struct {
	config
	op            Op
	typ           string
	id            *int
	created_at    *time.Time
	updated_at    *time.Time
	name          *string
	image         *string
	status        *schema.Status
	clearedFields map[string]struct{}
	users         map[int]struct{}
	removedusers  map[int]struct{}
	clearedusers  bool
	stages        map[int]struct{}
	removedstages map[int]struct{}
	clearedstages bool
	done          bool
	oldValue      func(context.Context) (*School, error)
	predicates    []predicate.School
}

var _ ent.Mutation = (*SchoolMutation)(nil)

// schoolOption allows management of the mutation configuration using functional options.
type schoolOption func(*SchoolMutation)

// newSchoolMutation creates new mutation for the School entity.
func newSchoolMutation(c config, op Op, opts ...schoolOption) *SchoolMutation {
	m := &SchoolMutation{
		config:        c,
		op:            op,
		typ:           TypeSchool,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSchoolID sets the ID field of the mutation.
func withSchoolID(id int) schoolOption {
	return func(m *SchoolMutation) {
		var (
			err   error
			once  sync.Once
			value *School
		)
		m.oldValue = func(ctx context.Context) (*School, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().School.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSchool sets the old School of the mutation.
func withSchool(node *School) schoolOption {
	return func(m *SchoolMutation) {
		m.oldValue = func(context.Context) (*School, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SchoolMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SchoolMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SchoolMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreatedAt sets the "created_at" field.
func (m *SchoolMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *SchoolMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the School entity.
// If the School object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SchoolMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *SchoolMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *SchoolMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *SchoolMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the School entity.
// If the School object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SchoolMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *SchoolMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetName sets the "name" field.
func (m *SchoolMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *SchoolMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the School entity.
// If the School object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SchoolMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *SchoolMutation) ResetName() {
	m.name = nil
}

// SetImage sets the "image" field.
func (m *SchoolMutation) SetImage(s string) {
	m.image = &s
}

// Image returns the value of the "image" field in the mutation.
func (m *SchoolMutation) Image() (r string, exists bool) {
	v := m.image
	if v == nil {
		return
	}
	return *v, true
}

// OldImage returns the old "image" field's value of the School entity.
// If the School object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SchoolMutation) OldImage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldImage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldImage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldImage: %w", err)
	}
	return oldValue.Image, nil
}

// ResetImage resets all changes to the "image" field.
func (m *SchoolMutation) ResetImage() {
	m.image = nil
}

// SetStatus sets the "status" field.
func (m *SchoolMutation) SetStatus(s schema.Status) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *SchoolMutation) Status() (r schema.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the School entity.
// If the School object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SchoolMutation) OldStatus(ctx context.Context) (v schema.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *SchoolMutation) ResetStatus() {
	m.status = nil
}

// AddUserIDs adds the "users" edge to the User entity by ids.
func (m *SchoolMutation) AddUserIDs(ids ...int) {
	if m.users == nil {
		m.users = make(map[int]struct{})
	}
	for i := range ids {
		m.users[ids[i]] = struct{}{}
	}
}

// ClearUsers clears the "users" edge to the User entity.
func (m *SchoolMutation) ClearUsers() {
	m.clearedusers = true
}

// UsersCleared reports if the "users" edge to the User entity was cleared.
func (m *SchoolMutation) UsersCleared() bool {
	return m.clearedusers
}

// RemoveUserIDs removes the "users" edge to the User entity by IDs.
func (m *SchoolMutation) RemoveUserIDs(ids ...int) {
	if m.removedusers == nil {
		m.removedusers = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.users, ids[i])
		m.removedusers[ids[i]] = struct{}{}
	}
}

// RemovedUsers returns the removed IDs of the "users" edge to the User entity.
func (m *SchoolMutation) RemovedUsersIDs() (ids []int) {
	for id := range m.removedusers {
		ids = append(ids, id)
	}
	return
}

// UsersIDs returns the "users" edge IDs in the mutation.
func (m *SchoolMutation) UsersIDs() (ids []int) {
	for id := range m.users {
		ids = append(ids, id)
	}
	return
}

// ResetUsers resets all changes to the "users" edge.
func (m *SchoolMutation) ResetUsers() {
	m.users = nil
	m.clearedusers = false
	m.removedusers = nil
}

// AddStageIDs adds the "stages" edge to the Stage entity by ids.
func (m *SchoolMutation) AddStageIDs(ids ...int) {
	if m.stages == nil {
		m.stages = make(map[int]struct{})
	}
	for i := range ids {
		m.stages[ids[i]] = struct{}{}
	}
}

// ClearStages clears the "stages" edge to the Stage entity.
func (m *SchoolMutation) ClearStages() {
	m.clearedstages = true
}

// StagesCleared reports if the "stages" edge to the Stage entity was cleared.
func (m *SchoolMutation) StagesCleared() bool {
	return m.clearedstages
}

// RemoveStageIDs removes the "stages" edge to the Stage entity by IDs.
func (m *SchoolMutation) RemoveStageIDs(ids ...int) {
	if m.removedstages == nil {
		m.removedstages = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.stages, ids[i])
		m.removedstages[ids[i]] = struct{}{}
	}
}

// RemovedStages returns the removed IDs of the "stages" edge to the Stage entity.
func (m *SchoolMutation) RemovedStagesIDs() (ids []int) {
	for id := range m.removedstages {
		ids = append(ids, id)
	}
	return
}

// StagesIDs returns the "stages" edge IDs in the mutation.
func (m *SchoolMutation) StagesIDs() (ids []int) {
	for id := range m.stages {
		ids = append(ids, id)
	}
	return
}

// ResetStages resets all changes to the "stages" edge.
func (m *SchoolMutation) ResetStages() {
	m.stages = nil
	m.clearedstages = false
	m.removedstages = nil
}

// Where appends a list predicates to the SchoolMutation builder.
func (m *SchoolMutation) Where(ps ...predicate.School) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *SchoolMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (School).
func (m *SchoolMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SchoolMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.created_at != nil {
		fields = append(fields, school.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, school.FieldUpdatedAt)
	}
	if m.name != nil {
		fields = append(fields, school.FieldName)
	}
	if m.image != nil {
		fields = append(fields, school.FieldImage)
	}
	if m.status != nil {
		fields = append(fields, school.FieldStatus)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SchoolMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case school.FieldCreatedAt:
		return m.CreatedAt()
	case school.FieldUpdatedAt:
		return m.UpdatedAt()
	case school.FieldName:
		return m.Name()
	case school.FieldImage:
		return m.Image()
	case school.FieldStatus:
		return m.Status()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SchoolMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case school.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case school.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case school.FieldName:
		return m.OldName(ctx)
	case school.FieldImage:
		return m.OldImage(ctx)
	case school.FieldStatus:
		return m.OldStatus(ctx)
	}
	return nil, fmt.Errorf("unknown School field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SchoolMutation) SetField(name string, value ent.Value) error {
	switch name {
	case school.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case school.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case school.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case school.FieldImage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetImage(v)
		return nil
	case school.FieldStatus:
		v, ok := value.(schema.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	}
	return fmt.Errorf("unknown School field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SchoolMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SchoolMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SchoolMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown School numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SchoolMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SchoolMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SchoolMutation) ClearField(name string) error {
	return fmt.Errorf("unknown School nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SchoolMutation) ResetField(name string) error {
	switch name {
	case school.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case school.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case school.FieldName:
		m.ResetName()
		return nil
	case school.FieldImage:
		m.ResetImage()
		return nil
	case school.FieldStatus:
		m.ResetStatus()
		return nil
	}
	return fmt.Errorf("unknown School field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SchoolMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.users != nil {
		edges = append(edges, school.EdgeUsers)
	}
	if m.stages != nil {
		edges = append(edges, school.EdgeStages)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SchoolMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case school.EdgeUsers:
		ids := make([]ent.Value, 0, len(m.users))
		for id := range m.users {
			ids = append(ids, id)
		}
		return ids
	case school.EdgeStages:
		ids := make([]ent.Value, 0, len(m.stages))
		for id := range m.stages {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SchoolMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedusers != nil {
		edges = append(edges, school.EdgeUsers)
	}
	if m.removedstages != nil {
		edges = append(edges, school.EdgeStages)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SchoolMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case school.EdgeUsers:
		ids := make([]ent.Value, 0, len(m.removedusers))
		for id := range m.removedusers {
			ids = append(ids, id)
		}
		return ids
	case school.EdgeStages:
		ids := make([]ent.Value, 0, len(m.removedstages))
		for id := range m.removedstages {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SchoolMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedusers {
		edges = append(edges, school.EdgeUsers)
	}
	if m.clearedstages {
		edges = append(edges, school.EdgeStages)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SchoolMutation) EdgeCleared(name string) bool {
	switch name {
	case school.EdgeUsers:
		return m.clearedusers
	case school.EdgeStages:
		return m.clearedstages
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SchoolMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown School unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SchoolMutation) ResetEdge(name string) error {
	switch name {
	case school.EdgeUsers:
		m.ResetUsers()
		return nil
	case school.EdgeStages:
		m.ResetStages()
		return nil
	}
	return fmt.Errorf("unknown School edge %s", name)
}

// StageMutation represents an operation that mutates the Stage nodes in the graph.
type StageMutation struct {
	config
	op                Op
	typ               string
	id                *int
	created_at        *time.Time
	updated_at        *time.Time
	name              *string
	tuition_amount    *int
	addtuition_amount *int
	status            *schema.Status
	clearedFields     map[string]struct{}
	school            *int
	clearedschool     bool
	classes           map[int]struct{}
	removedclasses    map[int]struct{}
	clearedclasses    bool
	payments          map[int]struct{}
	removedpayments   map[int]struct{}
	clearedpayments   bool
	students          map[int]struct{}
	removedstudents   map[int]struct{}
	clearedstudents   bool
	done              bool
	oldValue          func(context.Context) (*Stage, error)
	predicates        []predicate.Stage
}

var _ ent.Mutation = (*StageMutation)(nil)

// stageOption allows management of the mutation configuration using functional options.
type stageOption func(*StageMutation)

// newStageMutation creates new mutation for the Stage entity.
func newStageMutation(c config, op Op, opts ...stageOption) *StageMutation {
	m := &StageMutation{
		config:        c,
		op:            op,
		typ:           TypeStage,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withStageID sets the ID field of the mutation.
func withStageID(id int) stageOption {
	return func(m *StageMutation) {
		var (
			err   error
			once  sync.Once
			value *Stage
		)
		m.oldValue = func(ctx context.Context) (*Stage, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Stage.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withStage sets the old Stage of the mutation.
func withStage(node *Stage) stageOption {
	return func(m *StageMutation) {
		m.oldValue = func(context.Context) (*Stage, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m StageMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m StageMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *StageMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreatedAt sets the "created_at" field.
func (m *StageMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *StageMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Stage entity.
// If the Stage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StageMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *StageMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *StageMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *StageMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Stage entity.
// If the Stage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StageMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *StageMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetName sets the "name" field.
func (m *StageMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *StageMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Stage entity.
// If the Stage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StageMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *StageMutation) ResetName() {
	m.name = nil
}

// SetTuitionAmount sets the "tuition_amount" field.
func (m *StageMutation) SetTuitionAmount(i int) {
	m.tuition_amount = &i
	m.addtuition_amount = nil
}

// TuitionAmount returns the value of the "tuition_amount" field in the mutation.
func (m *StageMutation) TuitionAmount() (r int, exists bool) {
	v := m.tuition_amount
	if v == nil {
		return
	}
	return *v, true
}

// OldTuitionAmount returns the old "tuition_amount" field's value of the Stage entity.
// If the Stage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StageMutation) OldTuitionAmount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTuitionAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTuitionAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTuitionAmount: %w", err)
	}
	return oldValue.TuitionAmount, nil
}

// AddTuitionAmount adds i to the "tuition_amount" field.
func (m *StageMutation) AddTuitionAmount(i int) {
	if m.addtuition_amount != nil {
		*m.addtuition_amount += i
	} else {
		m.addtuition_amount = &i
	}
}

// AddedTuitionAmount returns the value that was added to the "tuition_amount" field in this mutation.
func (m *StageMutation) AddedTuitionAmount() (r int, exists bool) {
	v := m.addtuition_amount
	if v == nil {
		return
	}
	return *v, true
}

// ResetTuitionAmount resets all changes to the "tuition_amount" field.
func (m *StageMutation) ResetTuitionAmount() {
	m.tuition_amount = nil
	m.addtuition_amount = nil
}

// SetStatus sets the "status" field.
func (m *StageMutation) SetStatus(s schema.Status) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *StageMutation) Status() (r schema.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Stage entity.
// If the Stage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StageMutation) OldStatus(ctx context.Context) (v schema.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *StageMutation) ResetStatus() {
	m.status = nil
}

// SetSchoolID sets the "school" edge to the School entity by id.
func (m *StageMutation) SetSchoolID(id int) {
	m.school = &id
}

// ClearSchool clears the "school" edge to the School entity.
func (m *StageMutation) ClearSchool() {
	m.clearedschool = true
}

// SchoolCleared reports if the "school" edge to the School entity was cleared.
func (m *StageMutation) SchoolCleared() bool {
	return m.clearedschool
}

// SchoolID returns the "school" edge ID in the mutation.
func (m *StageMutation) SchoolID() (id int, exists bool) {
	if m.school != nil {
		return *m.school, true
	}
	return
}

// SchoolIDs returns the "school" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SchoolID instead. It exists only for internal usage by the builders.
func (m *StageMutation) SchoolIDs() (ids []int) {
	if id := m.school; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSchool resets all changes to the "school" edge.
func (m *StageMutation) ResetSchool() {
	m.school = nil
	m.clearedschool = false
}

// AddClassIDs adds the "classes" edge to the Class entity by ids.
func (m *StageMutation) AddClassIDs(ids ...int) {
	if m.classes == nil {
		m.classes = make(map[int]struct{})
	}
	for i := range ids {
		m.classes[ids[i]] = struct{}{}
	}
}

// ClearClasses clears the "classes" edge to the Class entity.
func (m *StageMutation) ClearClasses() {
	m.clearedclasses = true
}

// ClassesCleared reports if the "classes" edge to the Class entity was cleared.
func (m *StageMutation) ClassesCleared() bool {
	return m.clearedclasses
}

// RemoveClassIDs removes the "classes" edge to the Class entity by IDs.
func (m *StageMutation) RemoveClassIDs(ids ...int) {
	if m.removedclasses == nil {
		m.removedclasses = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.classes, ids[i])
		m.removedclasses[ids[i]] = struct{}{}
	}
}

// RemovedClasses returns the removed IDs of the "classes" edge to the Class entity.
func (m *StageMutation) RemovedClassesIDs() (ids []int) {
	for id := range m.removedclasses {
		ids = append(ids, id)
	}
	return
}

// ClassesIDs returns the "classes" edge IDs in the mutation.
func (m *StageMutation) ClassesIDs() (ids []int) {
	for id := range m.classes {
		ids = append(ids, id)
	}
	return
}

// ResetClasses resets all changes to the "classes" edge.
func (m *StageMutation) ResetClasses() {
	m.classes = nil
	m.clearedclasses = false
	m.removedclasses = nil
}

// AddPaymentIDs adds the "payments" edge to the TuitionPayment entity by ids.
func (m *StageMutation) AddPaymentIDs(ids ...int) {
	if m.payments == nil {
		m.payments = make(map[int]struct{})
	}
	for i := range ids {
		m.payments[ids[i]] = struct{}{}
	}
}

// ClearPayments clears the "payments" edge to the TuitionPayment entity.
func (m *StageMutation) ClearPayments() {
	m.clearedpayments = true
}

// PaymentsCleared reports if the "payments" edge to the TuitionPayment entity was cleared.
func (m *StageMutation) PaymentsCleared() bool {
	return m.clearedpayments
}

// RemovePaymentIDs removes the "payments" edge to the TuitionPayment entity by IDs.
func (m *StageMutation) RemovePaymentIDs(ids ...int) {
	if m.removedpayments == nil {
		m.removedpayments = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.payments, ids[i])
		m.removedpayments[ids[i]] = struct{}{}
	}
}

// RemovedPayments returns the removed IDs of the "payments" edge to the TuitionPayment entity.
func (m *StageMutation) RemovedPaymentsIDs() (ids []int) {
	for id := range m.removedpayments {
		ids = append(ids, id)
	}
	return
}

// PaymentsIDs returns the "payments" edge IDs in the mutation.
func (m *StageMutation) PaymentsIDs() (ids []int) {
	for id := range m.payments {
		ids = append(ids, id)
	}
	return
}

// ResetPayments resets all changes to the "payments" edge.
func (m *StageMutation) ResetPayments() {
	m.payments = nil
	m.clearedpayments = false
	m.removedpayments = nil
}

// AddStudentIDs adds the "students" edge to the User entity by ids.
func (m *StageMutation) AddStudentIDs(ids ...int) {
	if m.students == nil {
		m.students = make(map[int]struct{})
	}
	for i := range ids {
		m.students[ids[i]] = struct{}{}
	}
}

// ClearStudents clears the "students" edge to the User entity.
func (m *StageMutation) ClearStudents() {
	m.clearedstudents = true
}

// StudentsCleared reports if the "students" edge to the User entity was cleared.
func (m *StageMutation) StudentsCleared() bool {
	return m.clearedstudents
}

// RemoveStudentIDs removes the "students" edge to the User entity by IDs.
func (m *StageMutation) RemoveStudentIDs(ids ...int) {
	if m.removedstudents == nil {
		m.removedstudents = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.students, ids[i])
		m.removedstudents[ids[i]] = struct{}{}
	}
}

// RemovedStudents returns the removed IDs of the "students" edge to the User entity.
func (m *StageMutation) RemovedStudentsIDs() (ids []int) {
	for id := range m.removedstudents {
		ids = append(ids, id)
	}
	return
}

// StudentsIDs returns the "students" edge IDs in the mutation.
func (m *StageMutation) StudentsIDs() (ids []int) {
	for id := range m.students {
		ids = append(ids, id)
	}
	return
}

// ResetStudents resets all changes to the "students" edge.
func (m *StageMutation) ResetStudents() {
	m.students = nil
	m.clearedstudents = false
	m.removedstudents = nil
}

// Where appends a list predicates to the StageMutation builder.
func (m *StageMutation) Where(ps ...predicate.Stage) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *StageMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Stage).
func (m *StageMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *StageMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.created_at != nil {
		fields = append(fields, stage.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, stage.FieldUpdatedAt)
	}
	if m.name != nil {
		fields = append(fields, stage.FieldName)
	}
	if m.tuition_amount != nil {
		fields = append(fields, stage.FieldTuitionAmount)
	}
	if m.status != nil {
		fields = append(fields, stage.FieldStatus)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *StageMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case stage.FieldCreatedAt:
		return m.CreatedAt()
	case stage.FieldUpdatedAt:
		return m.UpdatedAt()
	case stage.FieldName:
		return m.Name()
	case stage.FieldTuitionAmount:
		return m.TuitionAmount()
	case stage.FieldStatus:
		return m.Status()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *StageMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case stage.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case stage.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case stage.FieldName:
		return m.OldName(ctx)
	case stage.FieldTuitionAmount:
		return m.OldTuitionAmount(ctx)
	case stage.FieldStatus:
		return m.OldStatus(ctx)
	}
	return nil, fmt.Errorf("unknown Stage field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *StageMutation) SetField(name string, value ent.Value) error {
	switch name {
	case stage.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case stage.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case stage.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case stage.FieldTuitionAmount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTuitionAmount(v)
		return nil
	case stage.FieldStatus:
		v, ok := value.(schema.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	}
	return fmt.Errorf("unknown Stage field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *StageMutation) AddedFields() []string {
	var fields []string
	if m.addtuition_amount != nil {
		fields = append(fields, stage.FieldTuitionAmount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *StageMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case stage.FieldTuitionAmount:
		return m.AddedTuitionAmount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *StageMutation) AddField(name string, value ent.Value) error {
	switch name {
	case stage.FieldTuitionAmount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTuitionAmount(v)
		return nil
	}
	return fmt.Errorf("unknown Stage numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *StageMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *StageMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *StageMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Stage nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *StageMutation) ResetField(name string) error {
	switch name {
	case stage.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case stage.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case stage.FieldName:
		m.ResetName()
		return nil
	case stage.FieldTuitionAmount:
		m.ResetTuitionAmount()
		return nil
	case stage.FieldStatus:
		m.ResetStatus()
		return nil
	}
	return fmt.Errorf("unknown Stage field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *StageMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.school != nil {
		edges = append(edges, stage.EdgeSchool)
	}
	if m.classes != nil {
		edges = append(edges, stage.EdgeClasses)
	}
	if m.payments != nil {
		edges = append(edges, stage.EdgePayments)
	}
	if m.students != nil {
		edges = append(edges, stage.EdgeStudents)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *StageMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case stage.EdgeSchool:
		if id := m.school; id != nil {
			return []ent.Value{*id}
		}
	case stage.EdgeClasses:
		ids := make([]ent.Value, 0, len(m.classes))
		for id := range m.classes {
			ids = append(ids, id)
		}
		return ids
	case stage.EdgePayments:
		ids := make([]ent.Value, 0, len(m.payments))
		for id := range m.payments {
			ids = append(ids, id)
		}
		return ids
	case stage.EdgeStudents:
		ids := make([]ent.Value, 0, len(m.students))
		for id := range m.students {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *StageMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedclasses != nil {
		edges = append(edges, stage.EdgeClasses)
	}
	if m.removedpayments != nil {
		edges = append(edges, stage.EdgePayments)
	}
	if m.removedstudents != nil {
		edges = append(edges, stage.EdgeStudents)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *StageMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case stage.EdgeClasses:
		ids := make([]ent.Value, 0, len(m.removedclasses))
		for id := range m.removedclasses {
			ids = append(ids, id)
		}
		return ids
	case stage.EdgePayments:
		ids := make([]ent.Value, 0, len(m.removedpayments))
		for id := range m.removedpayments {
			ids = append(ids, id)
		}
		return ids
	case stage.EdgeStudents:
		ids := make([]ent.Value, 0, len(m.removedstudents))
		for id := range m.removedstudents {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *StageMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedschool {
		edges = append(edges, stage.EdgeSchool)
	}
	if m.clearedclasses {
		edges = append(edges, stage.EdgeClasses)
	}
	if m.clearedpayments {
		edges = append(edges, stage.EdgePayments)
	}
	if m.clearedstudents {
		edges = append(edges, stage.EdgeStudents)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *StageMutation) EdgeCleared(name string) bool {
	switch name {
	case stage.EdgeSchool:
		return m.clearedschool
	case stage.EdgeClasses:
		return m.clearedclasses
	case stage.EdgePayments:
		return m.clearedpayments
	case stage.EdgeStudents:
		return m.clearedstudents
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *StageMutation) ClearEdge(name string) error {
	switch name {
	case stage.EdgeSchool:
		m.ClearSchool()
		return nil
	}
	return fmt.Errorf("unknown Stage unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *StageMutation) ResetEdge(name string) error {
	switch name {
	case stage.EdgeSchool:
		m.ResetSchool()
		return nil
	case stage.EdgeClasses:
		m.ResetClasses()
		return nil
	case stage.EdgePayments:
		m.ResetPayments()
		return nil
	case stage.EdgeStudents:
		m.ResetStudents()
		return nil
	}
	return fmt.Errorf("unknown Stage edge %s", name)
}

// TuitionPaymentMutation represents an operation that mutates the TuitionPayment nodes in the graph.
type TuitionPaymentMutation struct {
	config
	op             Op
	typ            string
	id             *int
	created_at     *time.Time
	updated_at     *time.Time
	paid_amount    *int
	addpaid_amount *int
	clearedFields  map[string]struct{}
	student        *int
	clearedstudent bool
	stage          *int
	clearedstage   bool
	done           bool
	oldValue       func(context.Context) (*TuitionPayment, error)
	predicates     []predicate.TuitionPayment
}

var _ ent.Mutation = (*TuitionPaymentMutation)(nil)

// tuitionpaymentOption allows management of the mutation configuration using functional options.
type tuitionpaymentOption func(*TuitionPaymentMutation)

// newTuitionPaymentMutation creates new mutation for the TuitionPayment entity.
func newTuitionPaymentMutation(c config, op Op, opts ...tuitionpaymentOption) *TuitionPaymentMutation {
	m := &TuitionPaymentMutation{
		config:        c,
		op:            op,
		typ:           TypeTuitionPayment,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTuitionPaymentID sets the ID field of the mutation.
func withTuitionPaymentID(id int) tuitionpaymentOption {
	return func(m *TuitionPaymentMutation) {
		var (
			err   error
			once  sync.Once
			value *TuitionPayment
		)
		m.oldValue = func(ctx context.Context) (*TuitionPayment, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().TuitionPayment.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTuitionPayment sets the old TuitionPayment of the mutation.
func withTuitionPayment(node *TuitionPayment) tuitionpaymentOption {
	return func(m *TuitionPaymentMutation) {
		m.oldValue = func(context.Context) (*TuitionPayment, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TuitionPaymentMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TuitionPaymentMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TuitionPaymentMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreatedAt sets the "created_at" field.
func (m *TuitionPaymentMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TuitionPaymentMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the TuitionPayment entity.
// If the TuitionPayment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TuitionPaymentMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TuitionPaymentMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *TuitionPaymentMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *TuitionPaymentMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the TuitionPayment entity.
// If the TuitionPayment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TuitionPaymentMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *TuitionPaymentMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetPaidAmount sets the "paid_amount" field.
func (m *TuitionPaymentMutation) SetPaidAmount(i int) {
	m.paid_amount = &i
	m.addpaid_amount = nil
}

// PaidAmount returns the value of the "paid_amount" field in the mutation.
func (m *TuitionPaymentMutation) PaidAmount() (r int, exists bool) {
	v := m.paid_amount
	if v == nil {
		return
	}
	return *v, true
}

// OldPaidAmount returns the old "paid_amount" field's value of the TuitionPayment entity.
// If the TuitionPayment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TuitionPaymentMutation) OldPaidAmount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPaidAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPaidAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPaidAmount: %w", err)
	}
	return oldValue.PaidAmount, nil
}

// AddPaidAmount adds i to the "paid_amount" field.
func (m *TuitionPaymentMutation) AddPaidAmount(i int) {
	if m.addpaid_amount != nil {
		*m.addpaid_amount += i
	} else {
		m.addpaid_amount = &i
	}
}

// AddedPaidAmount returns the value that was added to the "paid_amount" field in this mutation.
func (m *TuitionPaymentMutation) AddedPaidAmount() (r int, exists bool) {
	v := m.addpaid_amount
	if v == nil {
		return
	}
	return *v, true
}

// ResetPaidAmount resets all changes to the "paid_amount" field.
func (m *TuitionPaymentMutation) ResetPaidAmount() {
	m.paid_amount = nil
	m.addpaid_amount = nil
}

// SetStudentID sets the "student" edge to the User entity by id.
func (m *TuitionPaymentMutation) SetStudentID(id int) {
	m.student = &id
}

// ClearStudent clears the "student" edge to the User entity.
func (m *TuitionPaymentMutation) ClearStudent() {
	m.clearedstudent = true
}

// StudentCleared reports if the "student" edge to the User entity was cleared.
func (m *TuitionPaymentMutation) StudentCleared() bool {
	return m.clearedstudent
}

// StudentID returns the "student" edge ID in the mutation.
func (m *TuitionPaymentMutation) StudentID() (id int, exists bool) {
	if m.student != nil {
		return *m.student, true
	}
	return
}

// StudentIDs returns the "student" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// StudentID instead. It exists only for internal usage by the builders.
func (m *TuitionPaymentMutation) StudentIDs() (ids []int) {
	if id := m.student; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetStudent resets all changes to the "student" edge.
func (m *TuitionPaymentMutation) ResetStudent() {
	m.student = nil
	m.clearedstudent = false
}

// SetStageID sets the "stage" edge to the Stage entity by id.
func (m *TuitionPaymentMutation) SetStageID(id int) {
	m.stage = &id
}

// ClearStage clears the "stage" edge to the Stage entity.
func (m *TuitionPaymentMutation) ClearStage() {
	m.clearedstage = true
}

// StageCleared reports if the "stage" edge to the Stage entity was cleared.
func (m *TuitionPaymentMutation) StageCleared() bool {
	return m.clearedstage
}

// StageID returns the "stage" edge ID in the mutation.
func (m *TuitionPaymentMutation) StageID() (id int, exists bool) {
	if m.stage != nil {
		return *m.stage, true
	}
	return
}

// StageIDs returns the "stage" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// StageID instead. It exists only for internal usage by the builders.
func (m *TuitionPaymentMutation) StageIDs() (ids []int) {
	if id := m.stage; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetStage resets all changes to the "stage" edge.
func (m *TuitionPaymentMutation) ResetStage() {
	m.stage = nil
	m.clearedstage = false
}

// Where appends a list predicates to the TuitionPaymentMutation builder.
func (m *TuitionPaymentMutation) Where(ps ...predicate.TuitionPayment) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *TuitionPaymentMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (TuitionPayment).
func (m *TuitionPaymentMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TuitionPaymentMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.created_at != nil {
		fields = append(fields, tuitionpayment.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, tuitionpayment.FieldUpdatedAt)
	}
	if m.paid_amount != nil {
		fields = append(fields, tuitionpayment.FieldPaidAmount)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TuitionPaymentMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case tuitionpayment.FieldCreatedAt:
		return m.CreatedAt()
	case tuitionpayment.FieldUpdatedAt:
		return m.UpdatedAt()
	case tuitionpayment.FieldPaidAmount:
		return m.PaidAmount()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TuitionPaymentMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case tuitionpayment.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case tuitionpayment.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case tuitionpayment.FieldPaidAmount:
		return m.OldPaidAmount(ctx)
	}
	return nil, fmt.Errorf("unknown TuitionPayment field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TuitionPaymentMutation) SetField(name string, value ent.Value) error {
	switch name {
	case tuitionpayment.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case tuitionpayment.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case tuitionpayment.FieldPaidAmount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPaidAmount(v)
		return nil
	}
	return fmt.Errorf("unknown TuitionPayment field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TuitionPaymentMutation) AddedFields() []string {
	var fields []string
	if m.addpaid_amount != nil {
		fields = append(fields, tuitionpayment.FieldPaidAmount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TuitionPaymentMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case tuitionpayment.FieldPaidAmount:
		return m.AddedPaidAmount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TuitionPaymentMutation) AddField(name string, value ent.Value) error {
	switch name {
	case tuitionpayment.FieldPaidAmount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPaidAmount(v)
		return nil
	}
	return fmt.Errorf("unknown TuitionPayment numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TuitionPaymentMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TuitionPaymentMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TuitionPaymentMutation) ClearField(name string) error {
	return fmt.Errorf("unknown TuitionPayment nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TuitionPaymentMutation) ResetField(name string) error {
	switch name {
	case tuitionpayment.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case tuitionpayment.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case tuitionpayment.FieldPaidAmount:
		m.ResetPaidAmount()
		return nil
	}
	return fmt.Errorf("unknown TuitionPayment field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TuitionPaymentMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.student != nil {
		edges = append(edges, tuitionpayment.EdgeStudent)
	}
	if m.stage != nil {
		edges = append(edges, tuitionpayment.EdgeStage)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TuitionPaymentMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case tuitionpayment.EdgeStudent:
		if id := m.student; id != nil {
			return []ent.Value{*id}
		}
	case tuitionpayment.EdgeStage:
		if id := m.stage; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TuitionPaymentMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TuitionPaymentMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TuitionPaymentMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedstudent {
		edges = append(edges, tuitionpayment.EdgeStudent)
	}
	if m.clearedstage {
		edges = append(edges, tuitionpayment.EdgeStage)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TuitionPaymentMutation) EdgeCleared(name string) bool {
	switch name {
	case tuitionpayment.EdgeStudent:
		return m.clearedstudent
	case tuitionpayment.EdgeStage:
		return m.clearedstage
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TuitionPaymentMutation) ClearEdge(name string) error {
	switch name {
	case tuitionpayment.EdgeStudent:
		m.ClearStudent()
		return nil
	case tuitionpayment.EdgeStage:
		m.ClearStage()
		return nil
	}
	return fmt.Errorf("unknown TuitionPayment unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TuitionPaymentMutation) ResetEdge(name string) error {
	switch name {
	case tuitionpayment.EdgeStudent:
		m.ResetStudent()
		return nil
	case tuitionpayment.EdgeStage:
		m.ResetStage()
		return nil
	}
	return fmt.Errorf("unknown TuitionPayment edge %s", name)
}

// UserMutation represents an operation that mutates the User nodes in the graph.
type UserMutation struct {
	config
	op                 Op
	typ                string
	id                 *int
	created_at         *time.Time
	updated_at         *time.Time
	name               *string
	username           *string
	password           *string
	phone              *string
	image              *string
	token_version      *int
	addtoken_version   *int
	role               *user.Role
	status             *schema.Status
	clearedFields      map[string]struct{}
	stage              *int
	clearedstage       bool
	school             *int
	clearedschool      bool
	classes            map[int]struct{}
	removedclasses     map[int]struct{}
	clearedclasses     bool
	messages           map[int]struct{}
	removedmessages    map[int]struct{}
	clearedmessages    bool
	submissions        map[int]struct{}
	removedsubmissions map[int]struct{}
	clearedsubmissions bool
	attendances        map[int]struct{}
	removedattendances map[int]struct{}
	clearedattendances bool
	payments           map[int]struct{}
	removedpayments    map[int]struct{}
	clearedpayments    bool
	grades             map[int]struct{}
	removedgrades      map[int]struct{}
	clearedgrades      bool
	done               bool
	oldValue           func(context.Context) (*User, error)
	predicates         []predicate.User
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows management of the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for the User entity.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the ID field of the mutation.
func withUserID(id int) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreatedAt sets the "created_at" field.
func (m *UserMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UserMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UserMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UserMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetName sets the "name" field.
func (m *UserMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *UserMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *UserMutation) ResetName() {
	m.name = nil
}

// SetUsername sets the "username" field.
func (m *UserMutation) SetUsername(s string) {
	m.username = &s
}

// Username returns the value of the "username" field in the mutation.
func (m *UserMutation) Username() (r string, exists bool) {
	v := m.username
	if v == nil {
		return
	}
	return *v, true
}

// OldUsername returns the old "username" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUsername(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUsername is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUsername requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsername: %w", err)
	}
	return oldValue.Username, nil
}

// ResetUsername resets all changes to the "username" field.
func (m *UserMutation) ResetUsername() {
	m.username = nil
}

// SetPassword sets the "password" field.
func (m *UserMutation) SetPassword(s string) {
	m.password = &s
}

// Password returns the value of the "password" field in the mutation.
func (m *UserMutation) Password() (r string, exists bool) {
	v := m.password
	if v == nil {
		return
	}
	return *v, true
}

// OldPassword returns the old "password" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPassword(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPassword is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPassword: %w", err)
	}
	return oldValue.Password, nil
}

// ResetPassword resets all changes to the "password" field.
func (m *UserMutation) ResetPassword() {
	m.password = nil
}

// SetPhone sets the "phone" field.
func (m *UserMutation) SetPhone(s string) {
	m.phone = &s
}

// Phone returns the value of the "phone" field in the mutation.
func (m *UserMutation) Phone() (r string, exists bool) {
	v := m.phone
	if v == nil {
		return
	}
	return *v, true
}

// OldPhone returns the old "phone" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPhone(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPhone is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPhone requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhone: %w", err)
	}
	return oldValue.Phone, nil
}

// ResetPhone resets all changes to the "phone" field.
func (m *UserMutation) ResetPhone() {
	m.phone = nil
}

// SetImage sets the "image" field.
func (m *UserMutation) SetImage(s string) {
	m.image = &s
}

// Image returns the value of the "image" field in the mutation.
func (m *UserMutation) Image() (r string, exists bool) {
	v := m.image
	if v == nil {
		return
	}
	return *v, true
}

// OldImage returns the old "image" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldImage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldImage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldImage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldImage: %w", err)
	}
	return oldValue.Image, nil
}

// ClearImage clears the value of the "image" field.
func (m *UserMutation) ClearImage() {
	m.image = nil
	m.clearedFields[user.FieldImage] = struct{}{}
}

// ImageCleared returns if the "image" field was cleared in this mutation.
func (m *UserMutation) ImageCleared() bool {
	_, ok := m.clearedFields[user.FieldImage]
	return ok
}

// ResetImage resets all changes to the "image" field.
func (m *UserMutation) ResetImage() {
	m.image = nil
	delete(m.clearedFields, user.FieldImage)
}

// SetTokenVersion sets the "token_version" field.
func (m *UserMutation) SetTokenVersion(i int) {
	m.token_version = &i
	m.addtoken_version = nil
}

// TokenVersion returns the value of the "token_version" field in the mutation.
func (m *UserMutation) TokenVersion() (r int, exists bool) {
	v := m.token_version
	if v == nil {
		return
	}
	return *v, true
}

// OldTokenVersion returns the old "token_version" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldTokenVersion(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTokenVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTokenVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTokenVersion: %w", err)
	}
	return oldValue.TokenVersion, nil
}

// AddTokenVersion adds i to the "token_version" field.
func (m *UserMutation) AddTokenVersion(i int) {
	if m.addtoken_version != nil {
		*m.addtoken_version += i
	} else {
		m.addtoken_version = &i
	}
}

// AddedTokenVersion returns the value that was added to the "token_version" field in this mutation.
func (m *UserMutation) AddedTokenVersion() (r int, exists bool) {
	v := m.addtoken_version
	if v == nil {
		return
	}
	return *v, true
}

// ResetTokenVersion resets all changes to the "token_version" field.
func (m *UserMutation) ResetTokenVersion() {
	m.token_version = nil
	m.addtoken_version = nil
}

// SetRole sets the "role" field.
func (m *UserMutation) SetRole(u user.Role) {
	m.role = &u
}

// Role returns the value of the "role" field in the mutation.
func (m *UserMutation) Role() (r user.Role, exists bool) {
	v := m.role
	if v == nil {
		return
	}
	return *v, true
}

// OldRole returns the old "role" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldRole(ctx context.Context) (v user.Role, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldRole is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldRole requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRole: %w", err)
	}
	return oldValue.Role, nil
}

// ResetRole resets all changes to the "role" field.
func (m *UserMutation) ResetRole() {
	m.role = nil
}

// SetStatus sets the "status" field.
func (m *UserMutation) SetStatus(s schema.Status) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *UserMutation) Status() (r schema.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldStatus(ctx context.Context) (v schema.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *UserMutation) ResetStatus() {
	m.status = nil
}

// SetStageID sets the "stage" edge to the Stage entity by id.
func (m *UserMutation) SetStageID(id int) {
	m.stage = &id
}

// ClearStage clears the "stage" edge to the Stage entity.
func (m *UserMutation) ClearStage() {
	m.clearedstage = true
}

// StageCleared reports if the "stage" edge to the Stage entity was cleared.
func (m *UserMutation) StageCleared() bool {
	return m.clearedstage
}

// StageID returns the "stage" edge ID in the mutation.
func (m *UserMutation) StageID() (id int, exists bool) {
	if m.stage != nil {
		return *m.stage, true
	}
	return
}

// StageIDs returns the "stage" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// StageID instead. It exists only for internal usage by the builders.
func (m *UserMutation) StageIDs() (ids []int) {
	if id := m.stage; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetStage resets all changes to the "stage" edge.
func (m *UserMutation) ResetStage() {
	m.stage = nil
	m.clearedstage = false
}

// SetSchoolID sets the "school" edge to the School entity by id.
func (m *UserMutation) SetSchoolID(id int) {
	m.school = &id
}

// ClearSchool clears the "school" edge to the School entity.
func (m *UserMutation) ClearSchool() {
	m.clearedschool = true
}

// SchoolCleared reports if the "school" edge to the School entity was cleared.
func (m *UserMutation) SchoolCleared() bool {
	return m.clearedschool
}

// SchoolID returns the "school" edge ID in the mutation.
func (m *UserMutation) SchoolID() (id int, exists bool) {
	if m.school != nil {
		return *m.school, true
	}
	return
}

// SchoolIDs returns the "school" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SchoolID instead. It exists only for internal usage by the builders.
func (m *UserMutation) SchoolIDs() (ids []int) {
	if id := m.school; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSchool resets all changes to the "school" edge.
func (m *UserMutation) ResetSchool() {
	m.school = nil
	m.clearedschool = false
}

// AddClassIDs adds the "classes" edge to the Class entity by ids.
func (m *UserMutation) AddClassIDs(ids ...int) {
	if m.classes == nil {
		m.classes = make(map[int]struct{})
	}
	for i := range ids {
		m.classes[ids[i]] = struct{}{}
	}
}

// ClearClasses clears the "classes" edge to the Class entity.
func (m *UserMutation) ClearClasses() {
	m.clearedclasses = true
}

// ClassesCleared reports if the "classes" edge to the Class entity was cleared.
func (m *UserMutation) ClassesCleared() bool {
	return m.clearedclasses
}

// RemoveClassIDs removes the "classes" edge to the Class entity by IDs.
func (m *UserMutation) RemoveClassIDs(ids ...int) {
	if m.removedclasses == nil {
		m.removedclasses = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.classes, ids[i])
		m.removedclasses[ids[i]] = struct{}{}
	}
}

// RemovedClasses returns the removed IDs of the "classes" edge to the Class entity.
func (m *UserMutation) RemovedClassesIDs() (ids []int) {
	for id := range m.removedclasses {
		ids = append(ids, id)
	}
	return
}

// ClassesIDs returns the "classes" edge IDs in the mutation.
func (m *UserMutation) ClassesIDs() (ids []int) {
	for id := range m.classes {
		ids = append(ids, id)
	}
	return
}

// ResetClasses resets all changes to the "classes" edge.
func (m *UserMutation) ResetClasses() {
	m.classes = nil
	m.clearedclasses = false
	m.removedclasses = nil
}

// AddMessageIDs adds the "messages" edge to the Message entity by ids.
func (m *UserMutation) AddMessageIDs(ids ...int) {
	if m.messages == nil {
		m.messages = make(map[int]struct{})
	}
	for i := range ids {
		m.messages[ids[i]] = struct{}{}
	}
}

// ClearMessages clears the "messages" edge to the Message entity.
func (m *UserMutation) ClearMessages() {
	m.clearedmessages = true
}

// MessagesCleared reports if the "messages" edge to the Message entity was cleared.
func (m *UserMutation) MessagesCleared() bool {
	return m.clearedmessages
}

// RemoveMessageIDs removes the "messages" edge to the Message entity by IDs.
func (m *UserMutation) RemoveMessageIDs(ids ...int) {
	if m.removedmessages == nil {
		m.removedmessages = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.messages, ids[i])
		m.removedmessages[ids[i]] = struct{}{}
	}
}

// RemovedMessages returns the removed IDs of the "messages" edge to the Message entity.
func (m *UserMutation) RemovedMessagesIDs() (ids []int) {
	for id := range m.removedmessages {
		ids = append(ids, id)
	}
	return
}

// MessagesIDs returns the "messages" edge IDs in the mutation.
func (m *UserMutation) MessagesIDs() (ids []int) {
	for id := range m.messages {
		ids = append(ids, id)
	}
	return
}

// ResetMessages resets all changes to the "messages" edge.
func (m *UserMutation) ResetMessages() {
	m.messages = nil
	m.clearedmessages = false
	m.removedmessages = nil
}

// AddSubmissionIDs adds the "submissions" edge to the AssignmentSubmission entity by ids.
func (m *UserMutation) AddSubmissionIDs(ids ...int) {
	if m.submissions == nil {
		m.submissions = make(map[int]struct{})
	}
	for i := range ids {
		m.submissions[ids[i]] = struct{}{}
	}
}

// ClearSubmissions clears the "submissions" edge to the AssignmentSubmission entity.
func (m *UserMutation) ClearSubmissions() {
	m.clearedsubmissions = true
}

// SubmissionsCleared reports if the "submissions" edge to the AssignmentSubmission entity was cleared.
func (m *UserMutation) SubmissionsCleared() bool {
	return m.clearedsubmissions
}

// RemoveSubmissionIDs removes the "submissions" edge to the AssignmentSubmission entity by IDs.
func (m *UserMutation) RemoveSubmissionIDs(ids ...int) {
	if m.removedsubmissions == nil {
		m.removedsubmissions = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.submissions, ids[i])
		m.removedsubmissions[ids[i]] = struct{}{}
	}
}

// RemovedSubmissions returns the removed IDs of the "submissions" edge to the AssignmentSubmission entity.
func (m *UserMutation) RemovedSubmissionsIDs() (ids []int) {
	for id := range m.removedsubmissions {
		ids = append(ids, id)
	}
	return
}

// SubmissionsIDs returns the "submissions" edge IDs in the mutation.
func (m *UserMutation) SubmissionsIDs() (ids []int) {
	for id := range m.submissions {
		ids = append(ids, id)
	}
	return
}

// ResetSubmissions resets all changes to the "submissions" edge.
func (m *UserMutation) ResetSubmissions() {
	m.submissions = nil
	m.clearedsubmissions = false
	m.removedsubmissions = nil
}

// AddAttendanceIDs adds the "attendances" edge to the Attendance entity by ids.
func (m *UserMutation) AddAttendanceIDs(ids ...int) {
	if m.attendances == nil {
		m.attendances = make(map[int]struct{})
	}
	for i := range ids {
		m.attendances[ids[i]] = struct{}{}
	}
}

// ClearAttendances clears the "attendances" edge to the Attendance entity.
func (m *UserMutation) ClearAttendances() {
	m.clearedattendances = true
}

// AttendancesCleared reports if the "attendances" edge to the Attendance entity was cleared.
func (m *UserMutation) AttendancesCleared() bool {
	return m.clearedattendances
}

// RemoveAttendanceIDs removes the "attendances" edge to the Attendance entity by IDs.
func (m *UserMutation) RemoveAttendanceIDs(ids ...int) {
	if m.removedattendances == nil {
		m.removedattendances = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.attendances, ids[i])
		m.removedattendances[ids[i]] = struct{}{}
	}
}

// RemovedAttendances returns the removed IDs of the "attendances" edge to the Attendance entity.
func (m *UserMutation) RemovedAttendancesIDs() (ids []int) {
	for id := range m.removedattendances {
		ids = append(ids, id)
	}
	return
}

// AttendancesIDs returns the "attendances" edge IDs in the mutation.
func (m *UserMutation) AttendancesIDs() (ids []int) {
	for id := range m.attendances {
		ids = append(ids, id)
	}
	return
}

// ResetAttendances resets all changes to the "attendances" edge.
func (m *UserMutation) ResetAttendances() {
	m.attendances = nil
	m.clearedattendances = false
	m.removedattendances = nil
}

// AddPaymentIDs adds the "payments" edge to the TuitionPayment entity by ids.
func (m *UserMutation) AddPaymentIDs(ids ...int) {
	if m.payments == nil {
		m.payments = make(map[int]struct{})
	}
	for i := range ids {
		m.payments[ids[i]] = struct{}{}
	}
}

// ClearPayments clears the "payments" edge to the TuitionPayment entity.
func (m *UserMutation) ClearPayments() {
	m.clearedpayments = true
}

// PaymentsCleared reports if the "payments" edge to the TuitionPayment entity was cleared.
func (m *UserMutation) PaymentsCleared() bool {
	return m.clearedpayments
}

// RemovePaymentIDs removes the "payments" edge to the TuitionPayment entity by IDs.
func (m *UserMutation) RemovePaymentIDs(ids ...int) {
	if m.removedpayments == nil {
		m.removedpayments = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.payments, ids[i])
		m.removedpayments[ids[i]] = struct{}{}
	}
}

// RemovedPayments returns the removed IDs of the "payments" edge to the TuitionPayment entity.
func (m *UserMutation) RemovedPaymentsIDs() (ids []int) {
	for id := range m.removedpayments {
		ids = append(ids, id)
	}
	return
}

// PaymentsIDs returns the "payments" edge IDs in the mutation.
func (m *UserMutation) PaymentsIDs() (ids []int) {
	for id := range m.payments {
		ids = append(ids, id)
	}
	return
}

// ResetPayments resets all changes to the "payments" edge.
func (m *UserMutation) ResetPayments() {
	m.payments = nil
	m.clearedpayments = false
	m.removedpayments = nil
}

// AddGradeIDs adds the "grades" edge to the Grade entity by ids.
func (m *UserMutation) AddGradeIDs(ids ...int) {
	if m.grades == nil {
		m.grades = make(map[int]struct{})
	}
	for i := range ids {
		m.grades[ids[i]] = struct{}{}
	}
}

// ClearGrades clears the "grades" edge to the Grade entity.
func (m *UserMutation) ClearGrades() {
	m.clearedgrades = true
}

// GradesCleared reports if the "grades" edge to the Grade entity was cleared.
func (m *UserMutation) GradesCleared() bool {
	return m.clearedgrades
}

// RemoveGradeIDs removes the "grades" edge to the Grade entity by IDs.
func (m *UserMutation) RemoveGradeIDs(ids ...int) {
	if m.removedgrades == nil {
		m.removedgrades = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.grades, ids[i])
		m.removedgrades[ids[i]] = struct{}{}
	}
}

// RemovedGrades returns the removed IDs of the "grades" edge to the Grade entity.
func (m *UserMutation) RemovedGradesIDs() (ids []int) {
	for id := range m.removedgrades {
		ids = append(ids, id)
	}
	return
}

// GradesIDs returns the "grades" edge IDs in the mutation.
func (m *UserMutation) GradesIDs() (ids []int) {
	for id := range m.grades {
		ids = append(ids, id)
	}
	return
}

// ResetGrades resets all changes to the "grades" edge.
func (m *UserMutation) ResetGrades() {
	m.grades = nil
	m.clearedgrades = false
	m.removedgrades = nil
}

// Where appends a list predicates to the UserMutation builder.
func (m *UserMutation) Where(ps ...predicate.User) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.created_at != nil {
		fields = append(fields, user.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, user.FieldUpdatedAt)
	}
	if m.name != nil {
		fields = append(fields, user.FieldName)
	}
	if m.username != nil {
		fields = append(fields, user.FieldUsername)
	}
	if m.password != nil {
		fields = append(fields, user.FieldPassword)
	}
	if m.phone != nil {
		fields = append(fields, user.FieldPhone)
	}
	if m.image != nil {
		fields = append(fields, user.FieldImage)
	}
	if m.token_version != nil {
		fields = append(fields, user.FieldTokenVersion)
	}
	if m.role != nil {
		fields = append(fields, user.FieldRole)
	}
	if m.status != nil {
		fields = append(fields, user.FieldStatus)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldCreatedAt:
		return m.CreatedAt()
	case user.FieldUpdatedAt:
		return m.UpdatedAt()
	case user.FieldName:
		return m.Name()
	case user.FieldUsername:
		return m.Username()
	case user.FieldPassword:
		return m.Password()
	case user.FieldPhone:
		return m.Phone()
	case user.FieldImage:
		return m.Image()
	case user.FieldTokenVersion:
		return m.TokenVersion()
	case user.FieldRole:
		return m.Role()
	case user.FieldStatus:
		return m.Status()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case user.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case user.FieldName:
		return m.OldName(ctx)
	case user.FieldUsername:
		return m.OldUsername(ctx)
	case user.FieldPassword:
		return m.OldPassword(ctx)
	case user.FieldPhone:
		return m.OldPhone(ctx)
	case user.FieldImage:
		return m.OldImage(ctx)
	case user.FieldTokenVersion:
		return m.OldTokenVersion(ctx)
	case user.FieldRole:
		return m.OldRole(ctx)
	case user.FieldStatus:
		return m.OldStatus(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case user.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case user.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case user.FieldUsername:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsername(v)
		return nil
	case user.FieldPassword:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPassword(v)
		return nil
	case user.FieldPhone:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhone(v)
		return nil
	case user.FieldImage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetImage(v)
		return nil
	case user.FieldTokenVersion:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTokenVersion(v)
		return nil
	case user.FieldRole:
		v, ok := value.(user.Role)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRole(v)
		return nil
	case user.FieldStatus:
		v, ok := value.(schema.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserMutation) AddedFields() []string {
	var fields []string
	if m.addtoken_version != nil {
		fields = append(fields, user.FieldTokenVersion)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case user.FieldTokenVersion:
		return m.AddedTokenVersion()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	case user.FieldTokenVersion:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTokenVersion(v)
		return nil
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(user.FieldImage) {
		fields = append(fields, user.FieldImage)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	switch name {
	case user.FieldImage:
		m.ClearImage()
		return nil
	}
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case user.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case user.FieldName:
		m.ResetName()
		return nil
	case user.FieldUsername:
		m.ResetUsername()
		return nil
	case user.FieldPassword:
		m.ResetPassword()
		return nil
	case user.FieldPhone:
		m.ResetPhone()
		return nil
	case user.FieldImage:
		m.ResetImage()
		return nil
	case user.FieldTokenVersion:
		m.ResetTokenVersion()
		return nil
	case user.FieldRole:
		m.ResetRole()
		return nil
	case user.FieldStatus:
		m.ResetStatus()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 8)
	if m.stage != nil {
		edges = append(edges, user.EdgeStage)
	}
	if m.school != nil {
		edges = append(edges, user.EdgeSchool)
	}
	if m.classes != nil {
		edges = append(edges, user.EdgeClasses)
	}
	if m.messages != nil {
		edges = append(edges, user.EdgeMessages)
	}
	if m.submissions != nil {
		edges = append(edges, user.EdgeSubmissions)
	}
	if m.attendances != nil {
		edges = append(edges, user.EdgeAttendances)
	}
	if m.payments != nil {
		edges = append(edges, user.EdgePayments)
	}
	if m.grades != nil {
		edges = append(edges, user.EdgeGrades)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeStage:
		if id := m.stage; id != nil {
			return []ent.Value{*id}
		}
	case user.EdgeSchool:
		if id := m.school; id != nil {
			return []ent.Value{*id}
		}
	case user.EdgeClasses:
		ids := make([]ent.Value, 0, len(m.classes))
		for id := range m.classes {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeMessages:
		ids := make([]ent.Value, 0, len(m.messages))
		for id := range m.messages {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeSubmissions:
		ids := make([]ent.Value, 0, len(m.submissions))
		for id := range m.submissions {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeAttendances:
		ids := make([]ent.Value, 0, len(m.attendances))
		for id := range m.attendances {
			ids = append(ids, id)
		}
		return ids
	case user.EdgePayments:
		ids := make([]ent.Value, 0, len(m.payments))
		for id := range m.payments {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeGrades:
		ids := make([]ent.Value, 0, len(m.grades))
		for id := range m.grades {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 8)
	if m.removedclasses != nil {
		edges = append(edges, user.EdgeClasses)
	}
	if m.removedmessages != nil {
		edges = append(edges, user.EdgeMessages)
	}
	if m.removedsubmissions != nil {
		edges = append(edges, user.EdgeSubmissions)
	}
	if m.removedattendances != nil {
		edges = append(edges, user.EdgeAttendances)
	}
	if m.removedpayments != nil {
		edges = append(edges, user.EdgePayments)
	}
	if m.removedgrades != nil {
		edges = append(edges, user.EdgeGrades)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeClasses:
		ids := make([]ent.Value, 0, len(m.removedclasses))
		for id := range m.removedclasses {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeMessages:
		ids := make([]ent.Value, 0, len(m.removedmessages))
		for id := range m.removedmessages {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeSubmissions:
		ids := make([]ent.Value, 0, len(m.removedsubmissions))
		for id := range m.removedsubmissions {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeAttendances:
		ids := make([]ent.Value, 0, len(m.removedattendances))
		for id := range m.removedattendances {
			ids = append(ids, id)
		}
		return ids
	case user.EdgePayments:
		ids := make([]ent.Value, 0, len(m.removedpayments))
		for id := range m.removedpayments {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeGrades:
		ids := make([]ent.Value, 0, len(m.removedgrades))
		for id := range m.removedgrades {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 8)
	if m.clearedstage {
		edges = append(edges, user.EdgeStage)
	}
	if m.clearedschool {
		edges = append(edges, user.EdgeSchool)
	}
	if m.clearedclasses {
		edges = append(edges, user.EdgeClasses)
	}
	if m.clearedmessages {
		edges = append(edges, user.EdgeMessages)
	}
	if m.clearedsubmissions {
		edges = append(edges, user.EdgeSubmissions)
	}
	if m.clearedattendances {
		edges = append(edges, user.EdgeAttendances)
	}
	if m.clearedpayments {
		edges = append(edges, user.EdgePayments)
	}
	if m.clearedgrades {
		edges = append(edges, user.EdgeGrades)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	switch name {
	case user.EdgeStage:
		return m.clearedstage
	case user.EdgeSchool:
		return m.clearedschool
	case user.EdgeClasses:
		return m.clearedclasses
	case user.EdgeMessages:
		return m.clearedmessages
	case user.EdgeSubmissions:
		return m.clearedsubmissions
	case user.EdgeAttendances:
		return m.clearedattendances
	case user.EdgePayments:
		return m.clearedpayments
	case user.EdgeGrades:
		return m.clearedgrades
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	switch name {
	case user.EdgeStage:
		m.ClearStage()
		return nil
	case user.EdgeSchool:
		m.ClearSchool()
		return nil
	}
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	switch name {
	case user.EdgeStage:
		m.ResetStage()
		return nil
	case user.EdgeSchool:
		m.ResetSchool()
		return nil
	case user.EdgeClasses:
		m.ResetClasses()
		return nil
	case user.EdgeMessages:
		m.ResetMessages()
		return nil
	case user.EdgeSubmissions:
		m.ResetSubmissions()
		return nil
	case user.EdgeAttendances:
		m.ResetAttendances()
		return nil
	case user.EdgePayments:
		m.ResetPayments()
		return nil
	case user.EdgeGrades:
		m.ResetGrades()
		return nil
	}
	return fmt.Errorf("unknown User edge %s", name)
}
